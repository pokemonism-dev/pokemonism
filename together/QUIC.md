터넷 엔지니어링 태스크포스(IETF) J. Iyengar, Ed.
의견 요청: 9000 Fastly
카테고리: 표준 트랙 M. Thomson, Ed.
ISSN: 2070-1721 모질라
2021년 5월

           QUIC: UDP 기반 다중화 및 보안 전송

추상적인

이 문서는 QUIC 전송 프로토콜의 핵심을 정의합니다. QUIC
구조화된 흐름 제어 스트림을 애플리케이션에 제공합니다.
통신, 저지연 연결 설정 및 네트워크 경로
마이그레이션. QUIC에는 다음을 보장하는 보안 조치가 포함되어 있습니다.
다양한 배포 범위에서 기밀성, 무결성 및 가용성
상황. 첨부 문서에는 통합에 대한 설명이 나와 있습니다.
키 협상, 손실 감지 및 모범적인 혼잡을 위한 TLS
제어 알고리즘.

이 메모의 상태

이것은 인터넷 표준 트랙 문서입니다.

이 문서는 인터넷 엔지니어링 태스크포스의 제품입니다.
(IETF). 이는 IETF 커뮤니티의 합의를 나타냅니다.
공개 검토를 받았으며 출판이 승인되었습니다.
인터넷 엔지니어링 운영 그룹(IESG). 추가 정보
인터넷 표준은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류에 대한 정보
이에 대한 피드백을 제공하는 방법은 다음에서 얻을 수 있습니다.
https://www.rfc-editor.org/info/rfc9000.

저작권 고지

저작권 (c) 2021 IETF Trust 및 다음과 같이 식별된 사람
문서 작성자. 모든 권리 보유.

이 문서는 BCP 78 및 IETF Trust의 법률을 따릅니다.
IETF 문서 관련 조항
(https://trustee.ietf.org/license-info) 날짜부터 유효함
이 문서의 발행에 대해 자세히 알아보십시오. 다음 문서를 검토하십시오.
귀하의 권리와 제한 사항을 설명할 때 주의 깊게 읽으십시오.
이 문서에. 이 문서에서 추출한 코드 구성 요소는
섹션 4e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함합니다.
신탁법 조항은 보증 없이 제공됩니다.
단순화된 BSD 라이센스에 설명되어 있습니다.

목차

1. 개요
   1.1. 문서 구조
   1.2. 용어 및 정의
   1.3. 표기 규칙
2. 스트림
   2.1. 스트림 유형 및 식별자
   2.2. 데이터 송수신
   2.3. 스트림 우선 순위 지정
   2.4. 스트림 작업
3. 스트림 상태
   3.1. 스트림 상태 전송
   3.2. 스트림 상태 수신
   3.3. 허용되는 프레임 유형
   3.4. 양방향 스트림 상태
   3.5. 요청된 상태 전환
4. 흐름 제어
   4.1. 데이터 흐름 제어
   4.2. 유량 제어 한계 증가
   4.3. 흐름 제어 성능
   4.4. 스트림 취소 처리
   4.5. 스트림 최종 크기
   4.6. 동시성 제어
5. 연결
   5.1. 연결 ID
   5.1.1. 연결 ID 발급
   5.1.2. 연결 ID 사용 및 폐기
   5.2. 패킷을 연결에 일치시키기
   5.2.1. 클라이언트 패킷 처리
   5.2.2. 서버 패킷 처리
   5.2.3. 단순 로드 밸런서 고려 사항
   5.3. 연결 작업
6. 버전 협상
   6.1. 버전 협상 패킷 전송
   6.2. 버전 협상 패킷 처리
   6.3. 예약된 버전 사용
7. 암호화 및 전송 핸드셰이크
   7.1. 핸드셰이크 흐름 예시
   7.2. 연결 ID 협상
   7.3. 연결 ID 인증
   7.4. 전송 매개변수
   7.4.1. 0-RTT에 대한 전송 매개변수 값
   7.4.2. 새로운 전송 매개변수
   7.5. 암호화 메시지 버퍼링
8. 주소 확인
   8.1. 연결 설정 중 주소 유효성 검사
   8.1.1. 토큰 구성
   8.1.2. 재시도 패킷을 사용한 주소 검증
   8.1.3. 향후 연결을 위한 주소 유효성 검사
   8.1.4. 주소 검증 토큰 무결성
   8.2. 경로 검증
   8.2.1. 경로 검증 시작
   8.2.2. 경로 검증 응답
   8.2.3. 성공적인 경로 검증
   8.2.4. 실패한 경로 검증
9. 연결 마이그레이션
   9.1. 새로운 경로 탐색
   9.2. 연결 마이그레이션 시작
   9.3. 연결 마이그레이션에 대한 응답
   9.3.1. 피어 주소 스푸핑
   9.3.2. 경로상 주소 스푸핑
   9.3.3. 오프패스 패킷 전달
   9.4. 손실 감지 및 혼잡 제어
   9.5. 연결 마이그레이션의 개인 정보 보호 영향
   9.6. 서버의 기본 주소
   9.6.1. 선호하는 주소 전달
   9.6.2. 기본 주소로 마이그레이션
   9.6.3. 클라이언트 마이그레이션과 기본 주소의 상호 작용
   9.7. IPv6 흐름 레이블 및 마이그레이션 사용
10. 연결 종료
    10.1. 유휴 시간 초과
    10.1.1. 활성 테스트
    10.1.2. 유휴 시간 초과 연기
    10.2. 즉시 종결
    10.2.1. 연결 상태 닫기
    10.2.2. 배수 연결 상태
    10.2.3. 핸드셰이크 중 즉시 종료
    10.3. 상태 비저장 재설정
    10.3.1. 상태 비저장 재설정 감지
    10.3.2. 상태 비저장 재설정 토큰 계산
    10.3.3. 루핑
11. 오류 처리
    11.1. 연결 오류
    11.2. 스트림 오류
12. 패킷과 프레임
    12.1. 보호된 패킷
    12.2. 패킷 병합
    12.3. 패킷 번호
    12.4. 프레임 및 프레임 유형
    12.5. 프레임과 숫자 공간
13. 패킷화 및 신뢰성
    13.1. 패킷 처리
    13.2. 확인 메시지 생성
    13.2.1. ACK 프레임 전송
    13.2.2. 확인 빈도
    13.2.3. ACK 범위 관리
    13.2.4. ACK 프레임 추적을 통한 범위 제한
    13.2.5. 호스트 지연 측정 및 보고
    13.2.6. ACK 프레임 및 패킷 보호
    13.2.7. 패딩 프레임은 혼잡 윈도우를 소모합니다.
    13.3. 정보 재전송
    13.4. 명시적 혼잡 알림
    13.4.1. ECN 수 보고
    13.4.2. ECN 검증
14. 데이터그램 크기
    14.1. 초기 데이터그램 크기
    14.2. 경로 최대 전송 단위
    14.2.1. PMTUD에 의한 ICMP 메시지 처리
    14.3. 데이터그램 패킷화 계층 PMTU 검색
    14.3.1. DPLPMTUD 및 초기 연결
    14.3.2. DPLPMTUD를 사용하여 네트워크 경로 검증
    14.3.3. DPLPMTUD에 의한 ICMP 메시지 처리
    14.4. QUIC PMTU 프로브 보내기
    14.4.1. 소스 연결 ID를 포함하는 PMTU 프로브
15. 버전
16. 가변 길이 정수 인코딩
17. 패킷 포맷
    17.1. 패킷 번호 인코딩 및 디코딩
    17.2. 긴 헤더 패킷
    17.2.1. 버전 협상 패킷
    17.2.2. 초기 패킷
    17.2.3. 0-RTT
    17.2.4. 핸드셰이크 패킷
    17.2.5. 재시도 패킷
    17.3. 짧은 헤더 패킷
    17.3.1. 1-RTT 패킷
    17.4. 레이턴시 스핀 비트
18. 전송 매개변수 인코딩
    18.1. 예약된 전송 매개변수
    18.2. 전송 매개변수 정의
19. 프레임 유형 및 형식
    19.1. 패딩 프레임
    19.2. PING 프레임
    19.3. ACK 프레임
    19.3.1. ACK 범위
    19.3.2. ECN 카운트
    19.4. RESET_STREAM 프레임
    19.5. STOP_SENDING 프레임
    19.6. CRYPTO 프레임
    19.7. NEW_TOKEN 프레임
    19.8. STREAM 프레임
    19.9. MAX_DATA 프레임
    19.10. MAX_STREAM_DATA 프레임
    19.11. MAX_STREAMS 프레임
    19.12. DATA_BLOCKED 프레임
    19.13. STREAM_DATA_BLOCKED 프레임
    19.14. STREAMS_BLOCKED 프레임
    19.15. NEW_CONNECTION_ID 프레임
    19.16. RETIRE_CONNECTION_ID 프레임
    19.17. PATH_CHALLENGE 프레임
    19.18. PATH_RESPONSE 프레임
    19.19. CONNECTION_CLOSE 프레임
    19.20. HANDSHAKE_DONE 프레임
    19.21. 확장 프레임
20. 오류 코드
    20.1. 전송 오류 코드
    20.2. 애플리케이션 프로토콜 오류 코드
21. 보안 고려 사항
    21.1. 보안 속성 개요
    21.1.1. 핸드셰이크
    21.1.2. 보호된 패킷
    21.1.3. 연결 마이그레이션
    21.2. 핸드셰이크 서비스 거부
    21.3. 증폭 공격
    21.4. 낙관적 ACK 공격
    21.5. 요청 위조 공격
    21.5.1. 엔드포인트에 대한 제어 옵션
    21.5.2. 클라이언트 초기 패킷을 이용한 요청 위조
    21.5.3. 선호 주소를 사용한 요청 위조
    21.5.4. 스푸핑된 마이그레이션을 통한 요청 위조
    21.5.5. 버전 협상을 통한 요청 위조
    21.5.6. 일반 요청 위조 대응책
    21.6. 슬로로리스 공격
    21.7. 스트림 조각화 및 재조립 공격
    21.8. 스트림 커밋 공격
    21.9. 피어 서비스 거부
    21.10. 명시적 혼잡 알림 공격
    21.11. 상태 비저장 Oracle 재설정
    21.12. 버전 다운그레이드
    21.13. 라우팅을 통한 타겟 공격
    21.14. 트래픽 분석
22. IANA 고려 사항
    22.1. QUIC 레지스트리 등록 정책
    22.1.1. 임시 등록
    22.1.2. 코드포인트 선택
    22.1.3. 임시 코드포인트 회수
    22.1.4. 영구 등록
    22.2. QUIC 버전 레지스트리
    22.3. QUIC 전송 매개변수 레지스트리
    22.4. QUIC 프레임 유형 레지스트리
    22.5. QUIC 전송 오류 코드 레지스트리
23. 참고문헌
    23.1. 규범적 참조
    23.2. 정보 참고 자료
    부록 A. 의사코드
    A.1. 가변 길이 정수 디코딩 샘플
    A.2. 샘플 패킷 번호 인코딩 알고리즘
    A.3. 샘플 패킷 번호 디코딩 알고리즘
    A.4. ECN 검증 알고리즘 샘플
    기여자
    저자 주소

1. 개요

   QUIC은 안전한 범용 전송 프로토콜입니다. 이 문서는
   버전 독립적인 QUIC 버전 1을 정의합니다.
   [QUIC-INVARIANTS]에 정의된 QUIC의 속성.

   QUIC는 상태 기반 연결을 생성하는 연결 지향 프로토콜입니다.
   클라이언트와 서버 간의 상호작용.

   QUIC 핸드셰이크는 암호화 및
   전송 매개변수. QUIC은 TLS 핸드셰이크[TLS13]를 통합합니다.
   패킷을 보호하기 위해 맞춤형 프레이밍을 사용하지만
   TLS와 QUIC의 통합은 다음에서 더 자세히 설명됩니다.
   [QUIC-TLS]. 핸드셰이크는 교환을 허용하도록 구성됩니다.
   가능한 한 빨리 애플리케이션 데이터를 보내주세요. 여기에는 다음 옵션이 포함됩니다.
   클라이언트가 데이터를 즉시 보내려면(0-RTT) 어떤 형태의 데이터가 필요합니다.
   사전 통신이나 구성을 통해 활성화합니다.

   엔드포인트는 QUIC 패킷을 교환하여 QUIC에서 통신합니다. 대부분의
   패킷에는 제어 정보를 전달하는 프레임이 포함되어 있습니다.
   엔드포인트 간 애플리케이션 데이터. QUIC은 전체를 인증합니다.
   각 패킷의 암호화를 실행하고, 실행 가능한 만큼 각 패킷을 암호화합니다.
   QUIC 패킷은 보다 나은 작업을 위해 UDP 데이터그램[UDP]으로 전송됩니다.
   기존 시스템 및 네트워크에 배포.

   응용 프로그램 프로토콜은 QUIC 연결을 통해 정보를 교환합니다.
   스트림은 바이트의 순서화된 시퀀스입니다. 두 가지 유형의 스트림
   생성 가능: 양방향 스트림을 통해 두 엔드포인트 모두 허용
   데이터 전송 및 단일 엔드포인트를 허용하는 단방향 스트림
   데이터를 전송합니다. 크레딧 기반 방식은 스트림 생성을 제한하는 데 사용됩니다.
   그리고 전송할 수 있는 데이터 양을 제한합니다.

   QUIC은 안정적인 배송을 구현하는 데 필요한 피드백을 제공합니다.
   및 혼잡 제어. 감지 및 복구 알고리즘
   데이터 손실에 대한 내용은 [QUIC-RECOVERY]의 섹션 6에 설명되어 있습니다. QUIC
   네트워크 혼잡을 피하기 위해 혼잡 제어에 의존합니다.
   예시적인 혼잡 제어 알고리즘은 섹션 7에 설명되어 있습니다.
   [빠른 복구]

   QUIC 연결은 단일 네트워크 경로에 엄격하게 구속되지 않습니다.
   연결 마이그레이션은 연결 식별자를 사용하여 연결을 허용합니다.
   새 네트워크 경로로 전송합니다. 클라이언트만 마이그레이션할 수 있습니다.
   이 QUIC 버전에서는 이 설계를 통해 다음 연결도 가능합니다.
   네트워크 토폴로지나 주소 매핑이 변경된 후에도 계속됩니다.
   NAT 리바인딩으로 인해 발생할 수 있습니다.

   일단 설정되면 연결을 위한 여러 옵션이 제공됩니다.
   종료. 애플리케이션은 정상적인 종료, 엔드포인트를 관리할 수 있습니다.
   시간 초과 기간을 협상할 수 있으며 오류로 인해 즉시 연결이 발생할 수 있습니다.
   해체 및 상태 비저장 메커니즘은 종료를 제공합니다.
   한 엔드포인트가 상태를 잃은 후의 연결입니다.

1.1. 문서 구조

이 문서는 핵심 QUIC 프로토콜을 설명하며 다음과 같이 구성됩니다.
다음과 같습니다.

* 스트림은 QUIC이 제공하는 기본적인 서비스 추상화입니다.

    - 섹션 2에서는 스트림과 관련된 핵심 개념을 설명합니다.

    - 섹션 3에서는 스트림 상태에 대한 참조 모델을 제공합니다.

    - 섹션 4에서는 흐름 제어의 작동을 간략하게 설명합니다.

* 연결은 QUIC 엔드포인트가 통신하는 컨텍스트입니다.

    - 섹션 5에서는 연결과 관련된 핵심 개념을 설명합니다.

    - 섹션 6에서는 버전 협상에 대해 설명합니다.

    - 섹션 7에서는 연결을 설정하는 프로세스를 자세히 설명합니다.

    - 섹션 8에서는 주소 검증 및 중요 거부에 대해 설명합니다.
      서비스 완화,

    - 섹션 9에서는 엔드포인트가 연결을 새 엔드포인트로 마이그레이션하는 방법을 설명합니다.
      네트워크 경로,

    - 섹션 10에는 열려 있는 것을 종료하기 위한 옵션이 나열되어 있습니다.
      연결 및

    - 섹션 11에서는 스트림 및 연결 오류에 대한 지침을 제공합니다.
      손질.

* 패킷과 프레임은 QUIC이 통신하는 데 사용하는 기본 단위입니다.

    - 섹션 12에서는 패킷 및 프레임과 관련된 개념을 설명합니다.

    - 섹션 13은 전송, 재전송에 대한 모델을 정의합니다.
      및 데이터 확인 및

    - 섹션 14에서는 데이터그램의 크기를 관리하기 위한 규칙을 지정합니다.
      QUIC 패킷을 전달합니다.

* 마지막으로 QUIC 프로토콜 요소의 인코딩 세부 사항을 설명합니다.
  안에:

    - 제15조(버전)

    - 섹션 16(정수 인코딩)

    - 섹션 17(패킷 헤더)

    - 제18조(운송 매개변수)

    - 제19조(프레임) 및

    - 섹션 20(오류).

첨부 문서에는 QUIC의 손실 감지 및 혼잡에 대한 설명이 나와 있습니다.
제어 [QUIC-RECOVERY] 및 TLS 및 기타 암호화 사용
메커니즘[QUIC-TLS].

이 문서는 프로토콜을 준수하는 QUIC 버전 1을 정의합니다.
[QUIC-INVARIANTS]의 불변성.

QUIC 버전 1을 참조하려면 이 문서를 인용하세요.
QUIC의 버전 독립적 속성의 제한된 집합은 인용할 수 있습니다.
[빠른 불변성].

1.2. 용어 및 정의

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NO RECOMMENDED", "MAY" 및
이 문서의 "선택 사항"은 BCP에 설명된 대로 해석되어야 합니다.
14 [RFC2119] [RFC8174] 모든 경우에 나타나는 경우에만 나타납니다.
여기에 표시된 대로 대문자로 작성합니다.

이 문서에서 일반적으로 사용되는 용어는 아래와 같습니다.

QUIC: 이 문서에서 설명하는 전송 프로토콜입니다. QUIC는
이름이지 약어가 아닙니다.

Endpoint: QUIC 연결에 참여할 수 있는 엔터티
QUIC 패킷을 생성, 수신 및 처리합니다.
QUIC에는 클라이언트와 서버의 두 가지 유형의 엔드포인트만 있습니다.

클라이언트: QUIC 연결을 시작하는 엔드포인트.

서버: QUIC 연결을 허용하는 엔드포인트입니다.

QUIC 패킷: 처리 가능한 완전한 QUIC 단위
UDP 데이터그램에 캡슐화됩니다. 하나 이상의 QUIC 패킷이 가능합니다.
단일 UDP 데이터그램에 캡슐화됨.

Ack-eliciting 패킷: 프레임이 아닌 다른 프레임을 포함하는 QUIC 패킷
ACK, PADDING 및 CONNECTION_CLOSE. 이는 수신자가
확인서를 보내세요. 섹션 13.2.1을 참조하세요.

프레임: 구조화된 프로토콜 정보의 단위입니다.
여러 가지 프레임 유형이 있으며, 각각 다른 정보를 전달합니다.
프레임은 QUIC 패킷에 포함되어 있습니다.

주소: 자격 없이 사용될 경우 IP 버전의 튜플,
IP 주소 및 UDP 포트 번호는 한쪽 끝을 나타냅니다.
네트워크 경로.

연결 ID: QUIC를 식별하는 데 사용되는 식별자
엔드포인트에서 연결. 각 엔드포인트는 하나 이상을 선택합니다.
패킷에 포함할 피어의 연결 ID
엔드포인트. 이 값은 피어에게는 불투명합니다.

스트림: 정렬된 바이트의 단방향 또는 양방향 채널
QUIC 연결 내에서. QUIC 연결은 여러 개의
동시 스트림.

애플리케이션: QUIC를 사용하여 데이터를 보내고 받는 엔터티입니다.

이 문서에서는 "QUIC 패킷", "UDP 데이터그램" 및 "IP"라는 용어를 사용합니다.
"패킷"은 각 프로토콜의 단위를 나타냅니다. 즉,
하나 이상의 QUIC 패킷을 UDP 데이터그램에 캡슐화할 수 있습니다.
이는 IP 패킷으로 캡슐화됩니다.

1.3. 표기 규칙

이 문서의 패킷 및 프레임 다이어그램은 사용자 지정 형식을 사용합니다.
이 형식의 목적은 프로토콜을 정의하는 것이 아니라 요약하는 것입니다.
요소. 산문은 완전한 의미론과 세부 사항을 정의합니다.
구조물.

복잡한 필드는 이름이 지정되고 그 뒤에 필드 목록이 옵니다.
한 쌍의 일치하는 중괄호로 둘러싸여 있습니다. 이 목록의 각 필드는
쉼표로 구분합니다.

개별 필드에는 길이 정보와 다음 표시가 포함됩니다.
고정 값, 선택성 또는 반복. 개별 필드는 다음을 사용합니다.
모든 길이는 비트 단위로 표시되며, 표기 규칙은 다음과 같습니다.

x (A): x가 A비트 길이임을 나타냅니다.

x (i): 변수를 사용하여 x가 정수 값을 보유함을 나타냅니다.
섹션 16에 설명된 길이 인코딩

x (A..B): x가 A에서 B까지 어떤 길이든 될 수 있음을 나타냅니다. A는
최소 0비트를 나타내기 위해 생략되고 B는 생략될 수 있습니다.
상한이 설정되지 않았음을 나타냅니다. 이 형식의 값은 항상 다음으로 끝납니다.
바이트 경계에서

x (L) = C: x가 C의 고정된 값을 가지고 있음을 나타냅니다. x의 길이
L로 설명되며 위의 길이 형식을 사용할 수 있습니다.

x (L) = C..D: x가 C에서 D까지의 범위에 있는 값을 갖는다는 것을 나타냅니다.
L로 설명된 길이를 포함하여 위와 같음

[x (L)]: x가 선택 사항이며 길이가 L임을 나타냅니다.

x (L) ...: x가 0번 이상 반복되고 있음을 나타냅니다.
각 인스턴스의 길이는 L입니다.

이 문서에서는 네트워크 바이트 순서(즉, 빅 엔디언) 값을 사용합니다.
필드는 각 바이트의 상위 비트부터 배치됩니다.

관례에 따라 개별 필드는 다음을 사용하여 복잡한 필드를 참조합니다.
복잡한 필드의 이름.

그림 1은 예를 보여줍니다.

예제 구조 {
1비트 필드(1),
고정 값(7) = 61을 갖는 7비트 필드
가변 길이 정수(i)를 갖는 필드,
임의 길이 필드(..),
가변 길이 필드(8..24),
최소 길이의 필드(16..),
최대 길이(..128)의 필드
[선택 필드(64)],
반복 필드(8) ...,
}

                          그림 1: 예시 형식

산문에서 단일 비트 필드가 참조되는 경우 해당 위치
필드는 바이트 값을 사용하여 명확하게 할 수 있습니다.
필드 값이 설정된 필드입니다. 예를 들어, 값 0x80
가장 많은 단일 비트 필드를 참조하는 데 사용될 수 있습니다.
그림 1의 1비트 필드와 같이 바이트의 중요 비트입니다.

2. 스트림

   QUIC의 스트림은 가볍고 정렬된 바이트 스트림을 제공합니다.
   애플리케이션에 대한 추상화. 스트림은 단방향이거나
   양방향.

   스트림은 데이터를 전송하여 생성될 수 있습니다. 관련 프로세스
   스트림 관리 - 흐름 종료, 취소 및 관리
   제어 -- 모두 최소한의 오버헤드를 부과하도록 설계되었습니다.
   예를 들어, 단일 STREAM 프레임(섹션 19.8)을 열고 데이터를 전송할 수 있습니다.
   스트림을 닫고 닫을 수 있습니다. 스트림은 수명이 길어질 수도 있고 지속될 수도 있습니다.
   연결의 전체 기간.

   스트림은 두 엔드포인트 모두에서 생성될 수 있으며 동시에 데이터를 보낼 수 있습니다.
   다른 스트림과 인터리브되어 취소될 수 있습니다. QUIC는 그렇지 않습니다.
   다른 바이트 간의 순서를 보장하는 수단을 제공합니다.
   개울.

   QUIC에서는 임의의 수의 스트림이 작동할 수 있습니다.
   동시에 임의의 양의 데이터를 전송할 수 있습니다.
   흐름 제어 제약 및 스트림 제한에 따른 스트림 참조
   섹션 4.

2.1. 스트림 유형 및 식별자

스트림은 단방향 또는 양방향일 수 있습니다. 단방향
스트림은 데이터를 한 방향으로 전송합니다. 스트림의 시작자로부터
피어에게. 양방향 스트림을 사용하면 데이터를 양쪽으로 전송할 수 있습니다.
지도.

스트림은 연결 내에서 숫자 값으로 식별됩니다.
스트림 ID라고 합니다. 스트림 ID는 62비트 정수(0~
연결의 모든 스트림에 대해 고유한 2^62-1)입니다. 스트림 ID
가변 길이 정수로 인코딩됩니다. 섹션 16을 참조하세요. QUIC
엔드포인트는 연결 내에서 스트림 ID를 재사용해서는 안 됩니다.

스트림 ID의 최하위 비트(0x01)는 다음을 식별합니다.
스트림의 시작자입니다. 클라이언트가 시작한 스트림에는 짝수 번호가 있습니다.
스트림 ID(비트가 0으로 설정됨) 및 서버에서 시작한 스트림이 있습니다.
홀수 스트림 ID(비트가 1로 설정됨).

스트림 ID의 두 번째로 낮은 비트(0x02)
양방향 스트림(비트가 0으로 설정됨)을 구별합니다.
단방향 스트림(비트가 1로 설정됨).

따라서 스트림 ID의 최하위 두 비트는 다음을 식별합니다.
표 1에 요약된 대로 스트림은 네 가지 유형 중 하나입니다.

                +======+==================================+
                | 비트 | 스트림 유형 |
                +======+==================================+
                | 0x00 | 클라이언트 시작, 양방향 |
                +-----+----------------------------------+
                | 0x01 | 서버 시작, 양방향 |
                +-----+----------------------------------+
                | 0x02 | 클라이언트 시작, 단방향 |
                +-----+----------------------------------+
                | 0x03 | 서버 시작, 단방향 |
                +-----+----------------------------------+

                          표 1: 스트림 ID 유형

각 유형의 스트림 공간은 최소값(0x00)에서 시작합니다.
각각 0x03까지); 각 유형의 연속 스트림은 다음과 같습니다.
숫자로 증가하는 스트림 ID로 생성됩니다. 스트림 ID는
순서 없이 사용하면 해당 유형의 모든 스트림이 더 낮은 결과를 얻습니다.
번호가 매겨진 스트림 ID도 공개됩니다.

2.2. 데이터 송수신

STREAM 프레임(섹션 19.8)은 애플리케이션에서 보낸 데이터를 캡슐화합니다.
엔드포인트는 STREAM 프레임의 스트림 ID 및 오프셋 필드를 사용합니다.
데이터를 순서대로 정리합니다.

엔드포인트는 애플리케이션에 스트림 데이터를 전달할 수 있어야 합니다.
정렬된 바이트 스트림. 정렬된 바이트 스트림을 전달하려면 다음이 필요합니다.
순서 없이 수신된 모든 데이터를 끝점 버퍼에 저장합니다.
광고된 유량 제어 한계.

QUIC는 스트림 데이터 전달에 대해 특정 허용 사항을 제공하지 않습니다.
주문. 그러나 구현에서는 다음 기능을 제공하기로 선택할 수 있습니다.
수신 애플리케이션에 순서 없이 데이터를 전달합니다.

엔드포인트는 동일한 스트림 오프셋에서 스트림에 대한 데이터를 수신할 수 있습니다.
여러 번. 이미 수신된 데이터는
삭제됨. 지정된 오프셋의 데이터는 전송되는 경우 변경되어서는 안 됩니다.
여러 번; 엔드포인트는 서로 다른 데이터 수신을 처리할 수 있습니다.
연결 오류 유형으로 스트림 내의 동일한 오프셋
프로토콜 위반.

스트림은 다른 것이 없는 정렬된 바이트 스트림 추상화입니다.
QUIC에서 볼 수 있는 구조입니다. STREAM 프레임 경계는 예상되지 않습니다.
데이터 전송 시 보존, 패킷 전송 후 재전송
분실 또는 수신자에게 신청서가 전달됨.

엔드포인트는 다음을 보장하지 않고는 어떠한 스트림에서도 데이터를 보내서는 안 됩니다.
피어가 설정한 흐름 제어 한계 내에 있습니다. 흐름 제어는
4절에서 자세히 설명합니다.

2.3. 스트림 우선 순위 지정

스트림 멀티플렉싱은 애플리케이션에 상당한 영향을 미칠 수 있습니다.
스트림에 할당된 리소스가 올바르게 수행되면 성능이 향상됩니다.
우선순위가 지정됨.

QUIC는 우선순위 교환을 위한 메커니즘을 제공하지 않습니다.
정보. 대신 우선 순위 정보를 수신하는 데 의존합니다.
신청서에서.

QUIC 구현은 애플리케이션이 다음을 수행할 수 있는 방법을 제공해야 합니다.
스트림의 상대적 우선순위를 나타냅니다. 구현에서는 다음을 사용합니다.
할당 방법을 결정하기 위해 애플리케이션에서 제공하는 정보
리소스를 활성 스트림으로 전환합니다.

2.4. 스트림 작업

이 문서는 QUIC에 대한 API를 정의하지 않습니다. 대신 다음을 정의합니다.
애플리케이션 프로토콜이 의존할 수 있는 스트림의 함수 집합입니다.
애플리케이션 프로토콜은 QUIC 구현을 가정할 수 있습니다.
여기에 설명된 작업을 포함하는 인터페이스를 제공합니다.
섹션. 특정 용도로 설계된 구현
응용 프로그램 프로토콜은 다음과 같은 작업만 제공할 수 있습니다.
해당 프로토콜에서 사용됩니다.

스트림을 전송하는 부분에서 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

* 데이터 쓰기, 스트림 흐름 제어 크레딧이 언제 발생하는지 이해
  (섹션 4.1)이 서면을 보내기 위해 성공적으로 예약되었습니다.
  데이터;

* 스트림을 종료(클린 종료)하여 STREAM 프레임을 생성합니다.
  (섹션 19.8) FIN 비트가 설정된 경우

* 스트림을 재설정(갑작스러운 종료)하여 RESET_STREAM이 발생합니다.
  스트림이 터미널에 이미 존재하지 않는 경우 프레임(섹션 19.4)
  상태.

스트림 수신 부분에서 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

* 데이터 읽기; 그리고

* 스트림 읽기를 중단하고 닫힘을 요청합니다.
  STOP_SENDING 프레임이 생성됩니다(섹션 19.5).

응용 프로그램 프로토콜은 또한 상태에 대한 정보를 요청할 수 있습니다.
피어가 스트림을 열거나 재설정한 경우를 포함하여 스트림의 변경 사항
스트림, 피어가 스트림에서 읽기를 중단할 때, 새 데이터가 있을 때
사용 가능 여부 및 데이터가 스트림에 기록될 수 있거나 기록될 수 없는 경우
흐름 제어를 위해.

3. 스트림 상태

   이 섹션에서는 스트림을 전송 또는 수신 측면에서 설명합니다.
   구성 요소. 두 개의 상태 머신이 설명되어 있습니다. 하나는 스트림용입니다.
   엔드포인트가 데이터를 전송하는 경우(섹션 3.1)와 다른 엔드포인트가 데이터를 전송하는 경우
   엔드포인트가 데이터를 수신하는 스트림(섹션 3.2).

   단방향 스트림은 전송 상태 또는 수신 상태를 사용합니다.
   스트림 유형과 엔드포인트 역할에 따라 머신이 달라집니다.
   양방향 스트림은 두 엔드포인트에서 두 상태 머신을 모두 사용합니다.
   대부분의 경우 이러한 상태 머신의 사용은 동일합니다.
   스트림은 단방향 또는 양방향입니다. 조건은 다음과 같습니다.
   양방향 스트림의 경우 스트림을 여는 것이 약간 더 복잡합니다.
   송신측 또는 수신측 중 하나를 열면 다음과 같은 문제가 발생합니다.
   양방향으로 개울이 열립니다.

   이 섹션에 표시된 상태 머신은 대부분 유익한 정보를 제공합니다.
   이 문서에서는 스트림 상태를 사용하여 언제, 어떻게 규칙을 설명해야 하는지에 대한 규칙을 설명합니다.
   다양한 유형의 프레임을 보낼 수 있으며 이에 대한 반응은 다음과 같습니다.
   다양한 유형의 프레임이 수신될 때 예상됩니다. 이러한
   상태 머신은 QUIC 구현에 유용하도록 설계되었습니다.
   상태는 구현을 제한하기 위한 것이 아닙니다.
   구현은 다른 상태 머신을 정의할 수 있습니다.
   동작은 이러한 것을 구현하는 구현과 일관성이 있습니다.
   주.

   | 참고: 어떤 경우에는 단일 이벤트 또는 작업으로 인해
   | 여러 상태를 거쳐 전환합니다. 예를 들어, 전송
   | FIN 비트가 설정된 STREAM은 두 가지 상태 전환을 일으킬 수 있습니다.
   | 스트림 전송: "준비" 상태에서 "전송" 상태로,
   | "전송" 상태에서 "데이터 전송" 상태로 전환합니다.

3.1. 스트림 상태 전송

그림 2는 데이터를 전송하는 스트림 부분의 상태를 보여줍니다.
동료.

          영형
          | 스트림 생성(전송)
          | 피어가 양방향 스트림을 생성합니다.
          다섯
      +-------+
      | 준비 | RESET_STREAM 전송
      | |-----------------------.
      +-------+ |
          | |
          | 스트림 보내기 / |
          | 스트림 데이터 차단됨 |
          브이 |
      +-------+ |
      | 보내기 | RESET_STREAM 보내기 |
      | |---------------------->|
      +-------+ |
          | |
          | STREAM + FIN 보내기 |
          브이
      +-------+ +-------+
      | 데이터 | RESET_STREAM 전송 | 재설정 |
      | 전송됨 |------------------>| 전송됨 |
      +-------+ +-------+
          | |
          | 모든 ACK 수신 | ACK 수신
          브이
      +-------+ +-------+
      | 데이터 | | 재설정 |
      | 수신됨 | | 수신됨 |
      +-------+ +-------+

               그림 2: 스트림의 일부를 전송하기 위한 상태

엔드포인트가 시작하는 스트림의 전송 부분(유형 0 및
(클라이언트의 경우 2개, 서버의 경우 1개와 3개)는 애플리케이션에 의해 열립니다.
"준비" 상태는 새로 생성된 스트림을 나타냅니다.
애플리케이션에서 데이터를 수신합니다. 스트림 데이터는 버퍼링될 수 있습니다.
이 상태는 전송을 준비 중입니다.

첫 번째 STREAM 또는 STREAM_DATA_BLOCKED 프레임을 보내면
스트림의 일부를 보내 "전송" 상태로 전환합니다.
구현은 스트림 ID를 할당하는 것을 연기하도록 선택할 수 있습니다.
첫 번째 STREAM 프레임을 보내고 이 상태에 들어갈 때까지 스트림을 유지합니다.
이를 통해 더 나은 스트림 우선순위 지정이 가능합니다.

피어(유형)가 시작한 양방향 스트림의 전송 부분
서버의 경우 0, 클라이언트의 경우 1을 입력하면 "준비" 상태로 시작됩니다.
수신 부분이 생성됩니다.

"전송" 상태에서 엔드포인트는 전송하고 다시 전송합니다.
필수 -- STREAM 프레임의 스트림 데이터. 엔드포인트는 다음을 준수합니다.
피어가 설정한 흐름 제어 한계를 계속 수용하고
MAX_STREAM_DATA 프레임을 처리합니다. "전송" 상태의 엔드포인트
전송이 차단된 경우 STREAM_DATA_BLOCKED 프레임을 생성합니다.
스트림 흐름 제어 한계(섹션 4.1).

응용 프로그램이 모든 스트림 데이터가 전송되었음을 표시한 후
그리고 FIN 비트를 포함하는 STREAM 프레임이 전송되면 전송 부분은
스트림의 "데이터 전송됨" 상태가 됩니다. 이 상태에서
엔드포인트는 필요에 따라서만 스트림 데이터를 재전송합니다. 엔드포인트
흐름 제어 한계를 확인하거나 보낼 필요가 없습니다.
이 상태의 스트림에 대한 STREAM_DATA_BLOCKED 프레임입니다.
피어가 MAX_STREAM_DATA 프레임을 수신할 때까지 프레임이 수신될 수 있습니다.
최종 스트림 오프셋. 엔드포인트는 모든 것을 안전하게 무시할 수 있습니다.
이 스트림에 대해 피어로부터 수신한 MAX_STREAM_DATA 프레임
상태.

모든 스트림 데이터가 성공적으로 확인되면 전송이 시작됩니다.
스트림의 일부는 "데이터 수신" 상태로 들어갑니다. 이는 터미널입니다.
상태.

"준비", "전송" 또는 "데이터 전송" 중 하나인 모든 상태에서
응용 프로그램은 전송을 중단하고자 한다는 신호를 보낼 수 있습니다.
스트림 데이터. 또는 엔드포인트가 STOP_SENDING을 수신할 수 있습니다.
피어에서 프레임을 보냅니다. 어느 경우든 엔드포인트는 다음을 보냅니다.
스트림이 "Reset Sent"로 들어가게 하는 RESET_STREAM 프레임
상태.

엔드포인트는 다음을 언급하는 첫 번째 프레임으로 RESET_STREAM을 보낼 수 있습니다.
스트림; 이로 인해 해당 스트림의 전송 부분이 열리고
그런 다음 즉시 "재설정 전송" 상태로 전환됩니다.

RESET_STREAM을 포함하는 패킷이 확인되면
스트림의 일부를 전송하면 "Reset Recvd" 상태가 됩니다.
말기 상태.

3.2. 스트림 상태 수신

그림 3은 데이터를 수신하는 스트림 부분의 상태를 보여줍니다.
피어에서. 스트림 미러의 수신 부분에 대한 상태만
피어에서 스트림을 전송하는 부분의 일부 상태입니다.
스트림의 수신 부분은 전송 부분의 상태를 추적하지 않습니다.
"준비" 상태와 같이 관찰할 수 없는 부분 대신,
스트림의 수신 부분은 데이터 전달을 추적합니다.
일부 애플리케이션은 발신자가 관찰할 수 없습니다.

          영형
          | 수신 스트림 / 스트림 데이터 차단됨 / 스트림 재설정
          | 양방향 스트림 생성(전송)
          | Recv MAX_STREAM_DATA / STOP_SENDING (양방향)
          | 더 높은 번호의 스트림 만들기
          다섯
      +-------+
      | 수신 | 수신 RESET_STREAM
      | |-----------------------.
      +-------+ |
          | |
          | 수신 스트림 + FIN |
          브이 |
      +-------+ |
      | 크기 | 수신 RESET_STREAM |
      | 알려진 |---------------------->|
      +-------+ |
          | |
          | 모든 데이터 수신 |
          브이
      +-------+ RESET_STREAM 수신 +-------+
      | 데이터 |--- (선택 사항) --->| 재설정 |
      | 수신 | 모든 데이터 수신 | 수신 |
      +-------+<-- (선택 사항) ----+-------+
          | |
          | 앱 전체 데이터 읽기 | 앱 읽기 재설정
          브이
      +-------+ +-------+
      | 데이터 | | 재설정 |
      | 읽기 | | 읽기 |
      +-------+ +-------+

              그림 3: 스트림의 일부를 수신하는 상태

피어가 시작한 스트림의 수신 부분(유형 1 및 3)
클라이언트 또는 서버의 경우 0과 2가 첫 번째 STREAM이 생성될 때 생성됩니다.
STREAM_DATA_BLOCKED 또는 RESET_STREAM 프레임이 해당 항목에 대해 수신되었습니다.
스트림. 피어가 시작한 양방향 스트림의 경우 수신
전송 부분에 대한 MAX_STREAM_DATA 또는 STOP_SENDING 프레임
스트림은 수신 부분도 생성합니다. 초기 상태는
스트림의 일부를 수신하는 것을 "Recv"라고 합니다.

양방향 스트림의 경우 수신 부분은 "Recv"로 들어갑니다.
엔드포인트에서 전송 부분이 시작될 때의 상태(0을 입력)
클라이언트(서버의 경우 1번 유형)가 "준비" 상태로 들어갑니다.

MAX_STREAM_DATA 또는
해당 스트림에 대한 피어로부터 STOP_SENDING 프레임을 수신했습니다.
열리지 않은 스트림에 대한 MAX_STREAM_DATA 프레임을 수신하는 것은 다음을 나타냅니다.
원격 피어가 스트림을 열었고 흐름을 제공하고 있습니다.
제어 크레딧. 열리지 않은 STOP_SENDING 프레임 수신
스트림은 원격 피어가 더 이상 수신을 원하지 않음을 나타냅니다.
이 스트림의 데이터입니다. 두 프레임 모두 STREAM 또는
패킷이 손실되거나 순서가 변경된 경우 STREAM_DATA_BLOCKED 프레임이 생성됩니다.

스트림이 생성되기 전에 동일한 유형의 모든 스트림이 더 낮은
번호가 매겨진 스트림 ID를 반드시 생성해야 합니다. 이렇게 하면 생성이 보장됩니다.
스트림 순서는 두 엔드포인트에서 모두 일관됩니다.

"Recv" 상태에서 엔드포인트는 STREAM을 수신합니다.
STREAM_DATA_BLOCKED 프레임. 들어오는 데이터는 버퍼링되며
애플리케이션에 전달하기 위해 올바른 순서로 다시 조립되었습니다.
데이터가 애플리케이션에 의해 소모되고 버퍼 공간이 늘어나면
사용 가능한 경우 엔드포인트는 MAX_STREAM_DATA 프레임을 전송하여 허용합니다.
피어에게 더 많은 데이터를 보내세요.

FIN 비트가 있는 STREAM 프레임을 수신하면 최종 크기는
스트림이 알려져 있습니다. 섹션 4.5를 참조하세요. 스트림의 수신 부분
그런 다음 "크기 확인됨" 상태로 전환됩니다. 이 상태에서는 끝점이 없습니다.
더 이상 MAX_STREAM_DATA 프레임을 보낼 필요가 없습니다.
스트림 데이터의 재전송.

스트림에 대한 모든 데이터가 수신되면 수신 부분은
"데이터 수신" 상태로 전환됩니다. 이는 다음과 같은 이유로 발생할 수 있습니다.
"크기"로의 전환을 일으키는 동일한 STREAM 프레임을 수신합니다.
알려진". 모든 데이터를 수신한 후 모든 STREAM 또는
스트림에 대한 STREAM_DATA_BLOCKED 프레임은 삭제될 수 있습니다.

"데이터 수신" 상태는 스트림 데이터가 전달될 때까지 지속됩니다.
애플리케이션에. 스트림 데이터가 전달되면 스트림
"데이터 읽기" 상태로 진입하는데, 이는 최종 상태입니다.

"Recv" 또는 "Size Known" 상태에서 RESET_STREAM 프레임 수신
스트림이 "Reset Recvd" 상태로 전환됩니다. 이로 인해
애플리케이션에 대한 스트림 데이터 전달이 중단됩니다.

모든 스트림 데이터가 이미 수신되었을 수 있습니다.
RESET_STREAM이 수신되었습니다(즉, "데이터 수신" 상태).
마찬가지로, 남은 스트림 데이터가 도착하는 것도 가능합니다.
RESET_STREAM 프레임("Reset Recvd" 상태)을 수신합니다.
구현은 원하는 대로 이 상황을 관리할 수 있습니다.

RESET_STREAM을 전송한다는 것은 엔드포인트가 다음을 보장할 수 없음을 의미합니다.
스트림 데이터 전달; 그러나 스트림이 필요하다는 요구 사항은 없습니다.
RESET_STREAM을 수신하면 데이터가 전달되지 않습니다.
구현은 스트림 데이터 전달을 중단하고 모든 것을 삭제할 수 있습니다.
소비되지 않은 데이터 및 수신 신호를 보냅니다.
RESET_STREAM. RESET_STREAM 신호가 억제되거나 보류될 수 있습니다.
스트림 데이터가 완전히 수신되어 읽을 수 있도록 버퍼링된 경우
응용 프로그램. RESET_STREAM이 억제되면 수신
스트림의 일부는 "데이터 수신"에 남아 있습니다.

응용 프로그램이 스트림을 나타내는 신호를 수신하면
재설정되었습니다. 스트림의 수신 부분이 "재설정"으로 전환됩니다.
"읽기" 상태는 최종 상태입니다.

3.3. 허용되는 프레임 유형

스트림을 보내는 사람은 영향을 미치는 세 가지 프레임 유형만 보냅니다.
송신자 또는 수신자의 스트림 상태: STREAM
(섹션 19.8), STREAM_DATA_BLOCKED(섹션 19.13) 및 RESET_STREAM
(섹션 19.4).

발신자는 터미널 상태에서 이러한 프레임을 보내서는 안 됩니다.
("데이터 수신" 또는 "재설정 수신"). 발신자는 스트림을 보내서는 안 됩니다.
"재설정 전송" 상태의 스트림에 대한 STREAM_DATA_BLOCKED 프레임 또는
모든 터미널 상태(즉, RESET_STREAM 프레임을 보낸 후)
수신기는 이 세 프레임 중 하나를 어떤 상태에서든 수신할 수 있습니다.
이를 담고 있는 패킷의 배달이 지연될 가능성이 있습니다.

스트림 수신기는 MAX_STREAM_DATA 프레임을 보냅니다(섹션 19.10)
및 STOP_SENDING 프레임(섹션 19.5).

수신기는 "Recv" 상태에서만 MAX_STREAM_DATA 프레임을 전송합니다.
수신기는 STOP_SENDING 프레임을 어떤 상태에서든 보낼 수 있습니다.
RESET_STREAM 프레임을 수신하지 못했습니다. 즉, 다음과 같은 상태입니다.
"Reset Recvd" 또는 "Reset Read". 그러나
모든 스트림이 "데이터 수신" 상태에서 STOP_SENDING 프레임을 전송합니다.
데이터가 수신되었습니다. 발신자는 이 두 가지 중 하나를 수신할 수 있습니다.
배송 지연으로 인해 모든 상태의 프레임 유형
패킷.

3.4. 양방향 스트림 상태

양방향 스트림은 전송 부분과 수신 부분으로 구성됩니다.
구현은 양방향 스트림의 상태를 다음과 같이 표현할 수 있습니다.
전송 및 수신 스트림 상태의 합성. 가장 간단한
모델은 스트림을 보내거나 받을 때 "열려 있음"으로 표시합니다.
부품은 전송 및 전송 시 모두 비터미널 상태이며 "닫힘" 상태입니다.
수신 스트림은 터미널 상태에 있습니다.

표 2는 양방향 스트림 상태의 보다 복잡한 매핑을 보여줍니다.
HTTP/2에 정의된 스트림 상태와 대략적으로 일치합니다.
[HTTP2]. 이는 전송 또는 수신 시 여러 상태가 있음을 보여줍니다.
스트림의 일부는 동일한 복합 상태에 매핑됩니다.
이것은 그러한 매핑에 대한 한 가지 가능성일 뿐입니다. 이 매핑은
전환하기 전에 데이터를 확인해야 합니다.
"닫힌" 또는 "반쯤 닫힌" 상태.

      +===================+=======================+=================+
      | 전송 부분 | 수신 부분 | 복합 상태 |
      +===================+=======================+=================+
      | 스트림 없음 / 준비 완료 | 스트림 없음 / 수신 (*1) | 유휴 |
      +-------------------+-----------------------+-----------------+
      | 준비 / 보내기 / | 수신 / 크기 알려짐 | 열기 |
      | 전송된 데이터 | | |
      +-------------------+-----------------------+-----------------+
      | 준비 / 전송 / | 데이터 수신 / 데이터 | 반쯤 닫힘 |
      | 전송된 데이터 | 읽기 | (원격) |
      +-------------------+-----------------------+-----------------+
      | 준비 / 전송 / | 재설정 수신 / 재설정 | 반쯤 닫힘 |
      | 전송된 데이터 | 읽기 | (원격) |
      +-------------------+-----------------------+-----------------+
      | 데이터 수신 | 수신 / 크기 확인 | 반쯤 닫힘 |
      | | | (지역) |
      +-------------------+-----------------------+-----------------+
      | 재설정 전송됨 / | 수신됨 / 알려진 크기 | 반쯤 닫힘 |
      | 수신 재설정 | | (로컬) |
      +-------------------+-----------------------+-----------------+
      | 재설정 전송됨 / | 데이터 수신됨 / 데이터 | 닫힘 |
      | 수신 재설정 | 읽기 | |
      +-------------------+-----------------------+-----------------+
      | 전송 재설정 / | 수신 재설정 / 재설정 | 닫힘 |
      | 수신 재설정 | 읽기 | |
      +-------------------+-----------------------+-----------------+
      | 데이터 수신 | 데이터 수신 / 데이터 | 닫힘 |
      | | 읽기 | |
      +-------------------+-----------------------+-----------------+
      | 데이터 수신 | 재설정 수신 / 재설정 | 닫힘 |
      | | 읽기 | |
      +-------------------+-----------------------+-----------------+

            표 2: HTTP/2에 대한 스트림 상태의 가능한 매핑

      | 참고 (*1): 스트림은 아직 대기 상태가 아닌 경우 "유휴"로 간주됩니다.
      | 생성되었거나 스트림의 수신 부분이 "Recv"에 있는 경우
      | 아직 프레임을 받지 못한 상태입니다.

3.5. 요청된 상태 전환

애플리케이션이 더 이상 수신 중인 데이터에 관심이 없는 경우
스트림에서 스트림 읽기를 중단하고 다음을 지정할 수 있습니다.
애플리케이션 오류 코드.

스트림이 "수신" 또는 "크기 확인" 상태인 경우 전송
STOP_SENDING 프레임을 보내 종료를 촉구함으로써 이를 신호해야 합니다.
반대 방향의 흐름입니다. 이는 일반적으로 다음을 나타냅니다.
수신 애플리케이션이 더 이상 수신한 데이터를 읽지 않는다는 것입니다.
스트림에서 발생하지만 들어오는 데이터가 보장되지는 않습니다.
무시됨.

STOP_SENDING 프레임을 보낸 후 수신된 STREAM 프레임은 여전히
연결 및 스트림 흐름 제어에 포함되었지만
프레임은 수령 후 폐기할 수 있습니다.

STOP_SENDING 프레임은 수신 엔드포인트가 다음을 보내도록 요청합니다.
RESET_STREAM 프레임. STOP_SENDING 프레임을 수신하는 엔드포인트
스트림이 "준비" 상태이거나 RESET_STREAM 프레임을 보내야 합니다.
"전송" 상태. 스트림이 "데이터 전송" 상태인 경우
엔드포인트는 패킷이 전송될 때까지 RESET_STREAM 프레임 전송을 연기할 수 있습니다.
미처리 데이터가 포함된 경우 확인되거나 손실된 것으로 선언됩니다.
미처리된 데이터가 손실되었다고 선언되면 엔드포인트는 다음을 보내야 합니다.
데이터를 재전송하는 대신 RESET_STREAM 프레임을 사용합니다.

엔드포인트는 STOP_SENDING 프레임에서 오류 코드를 복사해야 합니다.
RESET_STREAM 프레임을 보내지만 모든 애플리케이션 오류를 사용할 수 있습니다.
코드. STOP_SENDING 프레임을 보내는 엔드포인트는 다음을 무시할 수 있습니다.
그 후에 수신된 모든 RESET_STREAM 프레임의 오류 코드
개울.

STOP_SENDING은 재설정되지 않은 스트림에 대해서만 전송되어야 합니다.
피어에 의해. STOP_SENDING은 "Recv"의 스트림에 가장 유용합니다.
또는 "크기 알려짐" 상태.

엔드포인트는 다음과 같은 경우 다른 STOP_SENDING 프레임을 보내야 합니다.
이전 STOP_SENDING을 포함하는 패킷은 손실됩니다. 그러나
모든 스트림 데이터 또는 RESET_STREAM 프레임이 수신되었습니다.
스트림 -- 즉, 스트림이 "Recv"가 아닌 다른 상태에 있는 경우
또는 "크기가 알려져 있음" -- STOP_SENDING 프레임을 보내는 것은 불필요합니다.

양방향을 종료하려는 엔드포인트
양방향 스트림은 다음을 보내어 한 방향을 종료할 수 있습니다.
RESET_STREAM 프레임을 사용하면 즉각적인 종료를 촉진할 수 있습니다.
STOP_SENDING 프레임을 보내 반대 방향으로 전송합니다.

4. 흐름 제어

   수신기는 필요한 데이터 양을 제한해야 합니다.
   버퍼는 빠른 발신자가 그들을 압도하거나
   악의적인 발신자가 대량의 메모리를 소비하는 것을 방지합니다.
   연결에 대한 메모리 커밋을 제한하는 수신기, 스트림은 다음과 같습니다.
   흐름은 개별적으로 그리고 연결 전체에서 제어됩니다.
   QUIC 수신기는 송신자가 전송할 수 있는 최대 데이터 양을 제어합니다.
   언제든지 스트림뿐만 아니라 모든 스트림에 전송 가능
   4.1절과 4.2절에 설명되어 있습니다.

   마찬가지로 연결 내 동시성을 제한하려면 QUIC 엔드포인트가 필요합니다.
   피어가 사용할 수 있는 최대 누적 스트림 수를 제어합니다.
   섹션 4.6에 설명된 대로 시작합니다.

   CRYPTO 프레임으로 전송된 데이터는 다음과 같은 방식으로 흐름 제어되지 않습니다.
   스트림 데이터. QUIC은 암호화 프로토콜을 사용합니다.
   과도한 데이터 버퍼링을 방지하기 위한 구현; [QUIC-TLS]를 참조하세요.
   여러 계층에서 과도한 버퍼링을 방지하기 위해 QUIC 구현
   암호화 프로토콜에 대한 인터페이스를 제공해야 합니다.
   버퍼링 한계를 전달하기 위한 구현입니다.

4.1. 데이터 흐름 제어

QUIC는 수신기가 제한 기반 흐름 제어 방식을 사용합니다.
수신할 준비가 된 총 바이트 수의 제한을 광고합니다.
주어진 스트림 또는 전체 연결에 대해. 이는 두 가지 수준으로 이어집니다.
QUIC의 데이터 흐름 제어:

* 단일 스트림이 소비되는 것을 방지하는 스트림 흐름 제어
  연결에 대한 전체 수신 버퍼를 제한하여 양을 제한합니다.
  각 스트림으로 전송할 수 있는 데이터의 양.

* 발신자가 허용량을 초과하지 못하도록 하는 연결 흐름 제어
  연결을 위한 수신기의 버퍼 용량을 제한하여
  모든 스트림의 STREAM 프레임에서 전송된 스트림 데이터의 총 바이트입니다.

발신자는 두 가지 제한을 초과하는 데이터를 보내서는 안 됩니다.

수신기는 전송을 통해 모든 스트림에 대한 초기 제한을 설정합니다.
핸드셰이크 중 매개변수(섹션 7.4). 그 후,
수신기는 MAX_STREAM_DATA 프레임(섹션 19.10) 또는 MAX_DATA를 보냅니다.
프레임(섹션 19.9)을 발신자에게 보내 더 큰 제한을 알립니다.

수신기는 다음을 보내어 스트림에 대한 더 큰 제한을 광고할 수 있습니다.
해당 스트림 ID가 있는 MAX_STREAM_DATA 프레임. A
MAX_STREAM_DATA 프레임은 최대 절대 바이트 오프셋을 나타냅니다.
스트림. 수신기는 흐름 제어 오프셋을 결정할 수 있습니다.
해당 지역에서 소비된 데이터의 현재 오프셋을 기준으로 광고됨
개울.

수신기는 다음을 보내어 연결에 대한 더 큰 제한을 광고할 수 있습니다.
MAX_DATA 프레임은 합의 최대값을 나타냅니다.
모든 스트림의 절대 바이트 오프셋. 수신기는 다음을 유지합니다.
모든 스트림에서 수신된 바이트의 누적 합계는 다음에 사용됩니다.
광고된 연결 또는 스트림 데이터 위반 사항을 확인하세요.
제한. 수신기는 최대 데이터 제한을 결정할 수 있습니다.
모든 스트림에서 소비된 바이트의 합계를 기준으로 광고됩니다.

수신기가 연결 또는 스트림에 대한 제한을 광고하면
더 작은 한도를 광고하는 것은 오류가 아니지만 더 작은 한도는
효과가 없습니다.

수신기는 다음 유형의 오류로 연결을 닫아야 합니다.
발신자가 광고된 연결을 위반하는 경우 FLOW_CONTROL_ERROR
또는 스트림 데이터 제한; 오류 처리에 대한 자세한 내용은 섹션 11을 참조하세요.

발신자는 MAX_STREAM_DATA 또는 MAX_DATA 프레임을 무시해야 합니다.
유량 제어 한계를 증가시키지 마십시오.

발신자가 한도까지 데이터를 전송한 경우 더 이상 데이터를 전송할 수 없습니다.
새 데이터이며 차단된 것으로 간주됩니다. 발신자는 다음을 보내야 합니다.
수신기에 STREAM_DATA_BLOCKED 또는 DATA_BLOCKED 프레임을 표시합니다.
쓸 데이터가 있지만 흐름 제어 제한으로 인해 차단되었습니다.
발신자가 유휴 시간 초과보다 더 긴 기간 동안 차단됨
(섹션 10.1) 수신기는 다음과 같은 경우에도 연결을 닫을 수 있습니다.
발신자는 전송할 수 있는 데이터를 가지고 있습니다.
연결이 닫히지 않도록 흐름 제어가 제한된 송신자가 필요합니다.
주기적으로 STREAM_DATA_BLOCKED 또는 DATA_BLOCKED 프레임을 보냅니다.
전송 중에 ACK를 유도하는 패킷이 없습니다.

4.2. 유량 제어 한계 증가

구현은 언제, 얼마나 많은 크레딧을 광고할지 결정합니다.
MAX_STREAM_DATA 및 MAX_DATA 프레임이 있지만 이 섹션에서는 몇 가지를 제공합니다.
고려사항.

발신자 차단을 방지하기 위해 수신자는 MAX_STREAM_DATA를 보낼 수 있습니다.
왕복 여행 내에서 MAX_DATA 프레임을 여러 번 보내거나 일찍 보내세요.
프레임 손실과 이후 복구에 필요한 시간을 충분히 확보할 수 있습니다.

제어 프레임은 연결 오버헤드에 영향을 미칩니다. 따라서
MAX_STREAM_DATA 및 MAX_DATA 프레임을 자주 작은 크기로 전송합니다.
변경 사항은 바람직하지 않습니다. 반면에 업데이트가 적으면
차단을 방지하려면 한도에 대한 빈번하고 큰 증가가 필요합니다.
보내는 사람이 수신자에게 더 많은 리소스 투입을 요구합니다.
리소스 약정과 오버헤드 사이에는 상충 관계가 있습니다.
광고되는 한도가 얼마나 큰지 결정합니다.

수신기는 자동 튜닝 메커니즘을 사용하여 주파수를 조정할 수 있습니다.
왕복 시간을 기준으로 광고된 추가 크레딧 금액
추정치와 수신 애플리케이션이 소비하는 속도
일반적인 TCP 구현과 유사한 데이터입니다. 최적화로서
엔드포인트는 흐름 제어와 관련된 프레임만 보낼 수 있습니다.
다른 프레임을 보내서 흐름 제어가 발생하지 않도록 보장합니다.
보낼 추가 패킷이 있습니다.

차단된 발신자는 STREAM_DATA_BLOCKED를 보낼 필요가 없습니다.
DATA_BLOCKED 프레임. 따라서 수신기는 다음을 기다려서는 안 됩니다.
STREAM_DATA_BLOCKED 또는 DATA_BLOCKED 프레임을 보내기 전에
MAX_STREAM_DATA 또는 MAX_DATA 프레임; 그렇게 하면 다음과 같은 결과가 발생할 수 있습니다.
발신자가 연결의 나머지 기간 동안 차단됩니다.
발신자가 이 프레임을 보내고 이를 기다리면 발신자가 다음과 같은 결과를 낳습니다.
적어도 왕복 여행 전체가 막혀 있는 경우.

발신자가 차단된 후 크레딧을 받으면 다음과 같은 일이 발생할 수 있습니다.
대량의 데이터를 응답으로 보내서 단기간에 결과를 낳습니다.
혼잡; [QUIC-RECOVERY]의 섹션 7.7에서 논의를 참조하세요.
발신자가 이러한 혼잡을 피할 수 있는 방법.

4.3. 흐름 제어 성능

엔드포인트가 피어가 항상 사용 가능한 흐름을 가지고 있는지 확인할 수 없는 경우
피어의 대역폭 지연보다 큰 제어 크레딧
이 연결의 제품에서는 수신 처리량이 다음에 의해 제한됩니다.
흐름 제어.

패킷 손실로 인해 수신 버퍼에 간격이 생겨 다음을 방해할 수 있습니다.
애플리케이션이 데이터를 소모하지 않도록 하고 수신 버퍼 공간을 확보합니다.

흐름 제어 한계에 대한 적시 업데이트를 보내면 개선될 수 있습니다.
성능. 흐름 제어 업데이트를 제공하기 위해서만 패킷을 전송합니다.
네트워크 부하를 증가시키고 성능에 부정적인 영향을 미칠 수 있습니다. 전송 중
ACK 프레임과 같은 다른 프레임과 함께 흐름 제어 업데이트
업데이트 비용이 절감됩니다.

4.4. 스트림 취소 처리

엔드포인트는 결국 흐름 제어의 양에 대해 동의해야 합니다.
모든 스트림에서 소비된 크레딧을 설명할 수 있습니다.
연결 수준 흐름 제어를 위한 모든 바이트에 대해.

RESET_STREAM 프레임을 수신하면 엔드포인트는 상태를 해제합니다.
일치하는 스트림에 대해 해당 스트림에 도착하는 추가 데이터를 무시합니다.
개울.

RESET_STREAM은 스트림의 한 방향을 갑자기 종료합니다.
양방향 스트림인 RESET_STREAM은 데이터 흐름에 영향을 미치지 않습니다.
반대 방향입니다. 두 엔드포인트 모두 흐름 제어 상태를 유지해야 합니다.
끝나지 않는 방향의 스트림을 위해 그 방향까지
말기 상태에 들어간다.

4.5. 스트림 최종 크기

최종 크기는 소모되는 흐름 제어 크레딧의 양입니다.
스트림에 의해. 스트림의 모든 연속 바이트가
한 번 전송하면 최종 크기는 전송된 바이트 수입니다. 더 보기
일반적으로 이것은 바이트의 오프셋보다 하나 더 높습니다.
스트림에 전송된 가장 큰 오프셋이거나, 바이트가 전송되지 않은 경우 0입니다.

발신자는 항상 스트림의 최종 크기를 다음에게 전달합니다.
스트림이 어떻게 종료되든 수신기는 안정적으로 작동합니다. 최종
크기는 STREAM 프레임의 오프셋과 길이 필드의 합입니다.
FIN 플래그를 사용하여 이러한 필드가 암시적일 수 있음을 유의하세요.
또는 RESET_STREAM 프레임의 최종 크기 필드는 다음을 포함합니다.
이 값입니다. 이는 두 엔드포인트가 얼마나 많은 것에 동의하는지 보장합니다.
해당 스트림에서 송신자가 흐름 제어 크레딧을 소모했습니다.

수신 시 엔드포인트는 스트림의 최종 크기를 알게 됩니다.
스트림의 일부가 "알려진 크기" 또는 "수신 재설정" 상태로 전환됩니다.
(섹션 3). 수신기는 스트림의 최종 크기를 사용해야 합니다.
연결 수준 흐름에서 스트림으로 전송된 모든 바이트를 설명합니다.
제어 장치.

엔드포인트는 최종 시점 또는 그 이후의 스트림에서 데이터를 보내서는 안 됩니다.
크기.

스트림의 최종 크기가 알려지면 변경할 수 없습니다.
RESET_STREAM 또는 STREAM 프레임이 수신되어 변경 사항을 나타냅니다.
스트림의 최종 크기, 엔드포인트는 오류로 응답해야 합니다.
FINAL_SIZE_ERROR 유형의 오류입니다. 오류에 대한 자세한 내용은 섹션 11을 참조하세요.
처리. 수신기는 데이터 수신을 처리해야 합니다.
스트림 후에도 FINAL_SIZE_ERROR 유형의 오류로 최종 크기가 표시됩니다.
닫혔습니다. 이러한 오류를 생성하는 것은 필수가 아닙니다.
엔드포인트가 이러한 오류를 생성하도록 요구하는 것은 또한 다음을 의미합니다.
엔드포인트는 닫힌 스트림에 대한 최종 크기 상태를 유지해야 합니다.
이는 국가적 차원의 상당한 헌신을 의미할 수 있습니다.

4.6. 동시성 제어

엔드포인트는 피어가 수신하는 스트림의 누적 수를 제한합니다.
열 수 있습니다. 스트림 ID가 "(max_streams * 4"보다 작은 스트림만
+ first_stream_id_of_type)"을 열 수 있습니다. 표 1을 참조하세요. 초기
  제한 사항은 운송 매개변수에 설정되어 있습니다. 섹션 18.2를 참조하세요.
  이후 제한은 MAX_STREAMS 프레임을 사용하여 광고됩니다.
  섹션 19.11. 단방향 및 단방향에 별도의 제한이 적용됩니다.
  양방향 스트림.

max_streams 전송 매개변수 또는 MAX_STREAMS 프레임이 있는 경우
2^60보다 큰 값을 수신하면 최대값을 허용합니다.
가변 길이 정수로 표현할 수 없는 스트림 ID를 참조하세요.
섹션 16. 둘 중 하나가 수신되면 연결을 닫아야 합니다.
TRANSPORT_PARAMETER_ERROR 유형의 연결 오류와 함께 즉시
문제가 있는 값이 전송 매개변수 또는
프레임에서 수신된 경우 FRAME_ENCODING_ERROR를 입력합니다.
섹션 10.2.

엔드포인트는 피어가 설정한 제한을 초과해서는 안 됩니다. 엔드포인트
제한을 초과하는 스트림 ID가 있는 프레임을 수신합니다.
보낸 것은 이것을 유형의 연결 오류로 처리해야 합니다.
STREAM_LIMIT_ERROR; 오류 처리에 대한 자세한 내용은 섹션 11을 참조하세요.

수신기가 MAX_STREAMS를 사용하여 스트림 제한을 광고하면
프레임, 더 작은 제한을 광고하는 것은 효과가 없습니다. MAX_STREAMS 프레임
스트림 제한을 늘리지 않는 항목은 무시해야 합니다.

스트림 및 연결 흐름 제어와 마찬가지로 이 문서는 다음과 같습니다.
스트림을 언제, 얼마나 많이 생성해야 하는지 결정하는 구현
MAX_STREAMS를 통해 피어에게 광고됩니다. 구현은 다음을 선택할 수 있습니다.
스트림이 닫히면서 제한을 늘리고 수를 유지하려면
피어가 이용할 수 있는 스트림은 거의 일관적입니다.

피어의 문제로 인해 새로운 스트림을 열 수 없는 엔드포인트
limits는 STREAMS_BLOCKED 프레임(섹션 19.14)을 보내야 합니다.
신호는 디버깅에 유용한 것으로 간주됩니다. 엔드포인트는 대기해서는 안 됩니다.
추가 크레딧을 광고하기 전에 이 신호를 수신하려면
그렇게 하면 피어가 최소한 차단된다는 것을 의미합니다.
전체 왕복 여행, 그리고 피어가 선택하는 경우 무기한으로 여행할 수 있습니다.
STREAMS_BLOCKED 프레임을 보내지 마세요.

5. 연결

   QUIC 연결은 클라이언트와 서버 간에 공유되는 상태입니다.

   각 연결은 두 사람이 핸드셰이크 단계로 시작합니다.
   엔드포인트는 암호화 핸드셰이크를 사용하여 공유 비밀을 설정합니다.
   프로토콜 [QUIC-TLS] 및 애플리케이션 프로토콜을 협상합니다.
   핸드셰이크(섹션 7)는 두 엔드포인트가 모두 동의함을 확인합니다.
   통신(섹션 8.1) 및 매개변수 설정
   연결(섹션 7.4).

   애플리케이션 프로토콜은 핸드셰이크 중에 연결을 사용할 수 있습니다.
   일부 제한 사항이 있는 단계입니다. 0-RTT를 사용하면 애플리케이션 데이터를
   서버로부터 응답을 받기 전에 클라이언트가 보낸 메시지입니다.
   그러나 0-RTT는 재생 공격에 대한 보호 기능을 제공하지 않습니다.
   [QUIC-TLS]의 섹션 9.2. 서버는 애플리케이션 데이터를 전송할 수도 있습니다.
   최종 암호화 핸드셰이크를 받기 전에 클라이언트에게
   신원과 활성 상태를 확인할 수 있는 메시지
   클라이언트. 이러한 기능을 통해 애플리케이션 프로토콜은 다음을 제공할 수 있습니다.
   지연 시간을 줄이기 위해 보안 보장을 일부 포기하는 옵션입니다.

   연결 ID(섹션 5.1)를 사용하면 연결을 마이그레이션할 수 있습니다.
   새로운 네트워크 경로로, 엔드포인트의 직접 선택과
   중간 상자의 변경으로 인해 강제로 발생하는 경우. 섹션 9에서는 설명합니다.
   보안 및 개인 정보 보호 문제에 대한 완화책
   이주.

   더 이상 필요하지 않거나 원하지 않는 연결의 경우
   클라이언트와 서버가 연결을 종료하는 방법은 여러 가지가 있습니다.
   섹션 10에 설명되어 있습니다.

5.1. 연결 ID

각 연결에는 연결 식별자 세트가 있습니다.
연결 ID는 연결을 식별할 수 있습니다.
연결 ID는 엔드포인트에 의해 독립적으로 선택됩니다. 각 엔드포인트
피어가 사용하는 연결 ID를 선택합니다.

연결 ID의 주요 기능은 변경 사항을 보장하는 것입니다.
하위 프로토콜 계층(UDP, IP)에서의 주소 지정은 패킷을 발생시키지 않습니다.
QUIC 연결이 잘못된 엔드포인트로 전달될 수 있습니다. 각
엔드포인트는 구현별(및
아마도 배포별) 패킷을 허용하는 방법
엔드포인트로 다시 라우팅되고 식별될 연결 ID
수신 시 종점에서.

여러 연결 ID가 사용되어 엔드포인트가 패킷을 보낼 수 있습니다.
관찰자가 동일한 것으로 식별할 수 없는 것
엔드포인트의 협력 없이 연결됨; 섹션 9.5 참조.

연결 ID에는 사용할 수 있는 정보가 포함되어서는 안 됩니다.
외부 관찰자(즉, 협력하지 않는 관찰자)
발급자)를 사용하여 동일한 다른 연결 ID와 연관시킵니다.
연결. 간단한 예로, 이는 동일한 연결 ID를 의미합니다.
동일한 연결에 대해 두 번 이상 발행되어서는 안 됩니다.

긴 헤더가 있는 패킷에는 소스 연결 ID가 포함됩니다.
대상 연결 ID 필드. 이 필드는 다음을 설정하는 데 사용됩니다.
새로운 연결에 대한 연결 ID입니다. 자세한 내용은 섹션 7.2를 참조하세요.

짧은 헤더가 있는 패킷(섹션 17.3)에는 다음만 포함됩니다.
대상 연결 ID를 지정하고 명시적 길이를 생략합니다. 길이
대상 연결 ID 필드는 알려져 있어야 합니다.
엔드포인트. 로드 밸런서를 사용하는 엔드포인트는 다음을 기반으로 라우팅합니다.
연결 ID는 고정 길이로 로드 밸런서와 일치할 수 있습니다.
연결 ID에 대해 또는 인코딩 체계에 대해 동의합니다. 고정된 부분
전체 연결을 허용하는 명시적 길이를 인코딩할 수 있습니다.
ID의 길이는 다양하며 로드 밸런서에서도 사용할 수 있습니다.

버전 협상(섹션 17.2.1) 패킷은 연결을 반영합니다.
클라이언트가 선택한 ID는 올바른 라우팅을 보장하기 위해 사용됩니다.
클라이언트 및 패킷이 패킷에 대한 응답임을 입증합니다.
클라이언트가 보냈습니다.

연결 ID가 없는 경우 길이가 0인 연결 ID를 사용할 수 있습니다.
올바른 엔드포인트로 라우팅하는 데 필요합니다. 그러나 멀티플렉싱
0을 사용하는 동안 동일한 로컬 IP 주소 및 포트에 연결
연결 ID 길이가 길면 피어가 있는 경우 실패가 발생합니다.
연결 마이그레이션, NAT 리바인딩 및 클라이언트 포트 재사용.
엔드포인트는 여러 개의 동일한 IP 주소와 포트를 사용해서는 안 됩니다.
0 길이의 연결 ID를 사용하는 동시 연결은 다음과 같은 경우를 제외합니다.
해당 프로토콜 기능이 사용되지 않는지 확인하세요.

엔드포인트가 0이 아닌 길이의 연결 ID를 사용하는 경우 다음을 수행해야 합니다.
피어가 연결 ID를 공급받고 있는지 확인하십시오.
엔드포인트로 전송되는 패킷을 선택합니다. 이러한 연결 ID는 다음과 같습니다.
NEW_CONNECTION_ID 프레임을 사용하여 엔드포인트에서 제공됨
(섹션 19.15).

5.1.1. 연결 ID 발급

각 연결 ID에는 다음을 지원하기 위한 연관된 ​​시퀀스 번호가 있습니다.
NEW_CONNECTION_ID 또는 RETIRE_CONNECTION_ID 프레임이 참조하는 시점을 감지합니다.
동일한 값으로. 엔드포인트에서 발급한 초기 연결 ID
긴 패킷 헤더의 소스 연결 ID 필드로 전송됩니다.
(섹션 17.2) 핸드셰이크 동안. 시퀀스 번호
초기 연결 ID는 0입니다. 선호하는 주소 전송인 경우
매개변수가 전송되면 제공된 연결 ID의 시퀀스 번호
1입니다.

추가 연결 ID는 다음을 사용하여 피어에게 전달됩니다.
NEW_CONNECTION_ID 프레임(섹션 19.15). 시퀀스 번호
새로 발급된 각 연결 ID는 1씩 증가해야 합니다. 연결
클라이언트가 첫 번째 대상 연결 ID에 대해 선택한 ID
전송하는 필드와 재시도 패킷에서 제공하는 모든 연결 ID는 다음과 같습니다.
일련번호가 지정되지 않았습니다.

엔드포인트가 연결 ID를 발급하면 패킷을 수락해야 합니다.
연결 기간 동안 또는 연결 종료 시까지 이 연결 ID를 유지합니다.
해당 피어는 RETIRE_CONNECTION_ID를 통해 연결 ID를 무효화합니다.
프레임(섹션 19.16). 발급되고 발급되지 않은 연결 ID
은퇴한 연결은 활성 연결로 간주됩니다. 모든 활성 연결 ID는 유효합니다.
언제든지, 어떤 패킷 유형에서든 현재 연결과 함께 사용할 수 있습니다.
여기에는 서버가 발급한 연결 ID가 포함됩니다.
preferred_address 전송 매개변수.

엔드포인트는 피어가 충분한 수의
사용 가능한 연결 ID와 사용되지 않는 연결 ID. 엔드포인트는 해당 번호를 광고합니다.
유지하려는 활성 연결 ID의 경우
active_connection_id_limit 전송 매개변수. 엔드포인트는 다음을 수행해서는 안 됩니다.
피어의 제한보다 더 많은 연결 ID를 제공합니다. 엔드포인트는
피어의 제한을 일시적으로 초과하는 연결 ID를 보냅니다.
NEW_CONNECTION_ID 프레임은 또한 초과분의 폐기를 요구합니다.
Retire Prior To 필드에 충분히 큰 값을 포함시킵니다.

NEW_CONNECTION_ID 프레임은 엔드포인트가 일부 활성 항목을 추가하도록 할 수 있습니다.
연결 ID 및 Retire 값에 따라 다른 연결 ID를 은퇴시킵니다.
이전 필드. NEW_CONNECTION_ID 프레임을 처리한 후
활성 연결 ID 추가 및 사용 중지(활성 연결 ID 수가 있는 경우)
연결 ID가 광고된 값을 초과합니다.
active_connection_id_limit 전송 매개변수, 엔드포인트는 반드시
CONNECTION_ID_LIMIT_ERROR 유형의 오류로 연결을 닫습니다.

피어가 연결을 종료하면 엔드포인트는 새 연결 ID를 제공해야 합니다.
연결 ID. 엔드포인트가 연결 ID보다 적은 연결 ID를 제공한 경우
peer의 active_connection_id_limit, 새로운 연결 ID를 제공할 수 있습니다.
이전에 사용되지 않은 연결 ID가 있는 패킷을 수신하는 경우.
엔드포인트는 각각에 대해 발급된 연결 ID의 총 수를 제한할 수 있습니다.
연결 ID가 부족해질 위험을 피하기 위해 연결을 참조하세요.
섹션 10.3.2. 엔드포인트는 또한 발급을 제한할 수 있습니다.
경로당 유지되는 상태의 양을 줄이기 위해 연결 ID를 사용합니다.
경로 검증 상태와 같이 피어가 상호 작용할 수 있는 경우
발급된 연결 ID만큼 많은 경로를 통해.

마이그레이션을 시작하고 0이 아닌 길이가 필요한 엔드포인트
연결 ID는 연결 ID 풀을 보장해야 합니다.
피어가 사용할 수 있는 연결 ID를 피어가 사용할 수 있도록 합니다.
풀이 있는 경우 피어가 응답할 수 없으므로 마이그레이션이 발생합니다.
탈진한.

연결 ID가 0인 엔드포인트를 선택하는 동안
핸드셰이크는 새 연결 ID를 발급할 수 없습니다. 길이가 0인 연결 ID
대상 연결 ID 필드는 전송된 모든 패킷에 사용됩니다.
이러한 엔드포인트는 모든 네트워크 경로를 통해 존재합니다.

5.1.2. 연결 ID 사용 및 폐기

엔드포인트는 피어에 사용하는 연결 ID를 변경할 수 있습니다.
연결 중 언제든지 사용 가능한 또 다른 엔드포인트.
마이그레이션하는 피어에 대한 응답으로 연결 ID를 사용합니다. 참조
자세한 내용은 섹션 9.5를 참조하세요.

엔드포인트는 피어로부터 수신한 연결 ID 세트를 유지 관리합니다.
패킷을 보낼 때 사용할 수 있는 모든 것. 엔드포인트가
연결 ID를 사용에서 제거하려면 다음을 보냅니다.
RETIRE_CONNECTION_ID 프레임을 피어에게 전송합니다.
RETIRE_CONNECTION_ID 프레임은 연결 ID가 적용되지 않음을 나타냅니다.
다시 사용할 수 있으며 피어에게 새 것으로 교체해 달라고 요청합니다.
NEW_CONNECTION_ID 프레임을 사용하여 연결 ID를 지정합니다.

섹션 9.5에서 논의한 대로 엔드포인트는 연결 사용을 제한합니다.
단일 로컬 주소에서 단일 주소로 전송된 패킷에 대한 ID
대상 주소. 엔드포인트는 연결 ID를 폐기해야 합니다.
그들은 더 이상 로컬 또는 목적지를 적극적으로 사용하지 않습니다.
연결 ID가 사용된 주소입니다.

엔드포인트는 이전에 발급된 연결 수락을 중지해야 할 수도 있습니다.
특정 상황에서 ID. 이러한 엔드포인트는 피어가
NEW_CONNECTION_ID 프레임을 보내어 연결 ID를 폐기합니다.
Retire Prior To 필드가 증가했습니다. 엔드포인트는 계속되어야 합니다.
이전에 발급된 연결 ID를 폐기할 때까지 수락합니다.
피어. 엔드포인트가 더 이상 표시된 것을 처리할 수 없는 경우
연결 ID가 없으면 연결이 닫힐 수 있습니다.

증가된 Retire Prior To 필드를 수신하면 피어는 다음을 수행해야 합니다.
해당 연결 ID 사용을 중지하고 폐기합니다.
새로 제공된 프레임을 추가하기 전에 RETIRE_CONNECTION_ID 프레임을 추가합니다.
활성 연결 ID 집합에 대한 연결 ID입니다. 이 순서는
엔드포인트가 모든 활성 연결 ID를 교체할 수 있도록 허용합니다.
피어가 사용 가능한 연결 ID를 갖지 않고 연결되지 않을 가능성이 있습니다.
active_connection_id_limit에서 피어가 설정한 제한을 초과함
전송 매개변수; 섹션 18.2 참조. 사용 중단 실패
요청 시 연결 ID가 연결 실패로 이어질 수 있습니다.
발급 엔드포인트가 연결을 계속 사용할 수 없을 수 있습니다.
활성 연결이 있는 ID입니다.

엔드포인트는 폐기한 연결 ID의 수를 제한해야 합니다.
로컬로 RETIRE_CONNECTION_ID 프레임이 아직 생성되지 않은 경우
확인됨. 엔드포인트는 다음을 보내고 추적할 수 있어야 합니다.
RETIRE_CONNECTION_ID 프레임 수는 최소 2배 이상입니다.
active_connection_id_limit 전송 매개변수. 엔드포인트는 반드시
연결 ID를 폐기하지 않고 잊어버리지 마십시오. 그러나 선택할 수 있습니다.
이것을 초과하는 은퇴가 필요한 연결 ID를 처리하려면
CONNECTION_ID_LIMIT_ERROR 유형의 연결 오류로 제한합니다.

엔드포인트는 Retire Prior To 필드의 업데이트를 발행해서는 안 됩니다.
모든 RETIRE_CONNECTION_ID 프레임을 수신하기 전에이전 Retire Prior To 값으로 표시된
연결 ID입니다 .

5.2. 패킷을 연결에 일치시키기

수신 패킷은 수신 시 분류됩니다. 패킷은
기존 연결과 연관되어 있거나 -- 서버의 경우 --
잠재적으로 새로운 연결을 생성합니다.

엔드포인트는 패킷을 기존 연결과 연결하려고 시도합니다.
패킷에 0이 아닌 길이의 대상 연결 ID가 있습니다.
기존 연결에 해당하는 QUIC는 해당 패킷을 처리합니다.
따라서 두 개 이상의 연결 ID를 연결할 수 있습니다.
연결이 있는 경우 섹션 5.1을 참조하세요.

대상 연결 ID의 길이가 0이고 주소 지정이
패킷의 정보가 주소 정보와 일치합니다.
엔드포인트는 길이가 0인 연결을 식별하는 데 사용됩니다.
ID, QUIC는 해당 연결의 일부로 패킷을 처리합니다.
엔드포인트는 대상 IP와 포트만 사용하거나 소스와 포트를 모두 사용할 수 있습니다.
식별을 위한 목적지 주소이지만 이렇게 하면
섹션 5.1에 설명된 대로 연결이 취약합니다.

엔드포인트는 모든 패킷에 대해 Stateless Reset(섹션 10.3)을 보낼 수 있습니다.
기존 연결에 기인할 수 없는 상태 비저장
재설정을 통해 피어는 연결이 끊어졌을 때 더 빠르게 식별할 수 있습니다.
사용할 수 없게 됩니다.

기존 연결과 일치하는 패킷은 다음과 같은 경우 삭제됩니다.
패킷이 해당 연결 상태와 일치하지 않습니다.
예를 들어, 패킷이 다른 프로토콜을 나타내는 경우 해당 패킷은 삭제됩니다.
연결 버전보다 더 높거나 패킷 제거 시
예상한 키가 사용 가능해지면 보호가 실패합니다.

강력한 무결성 보호가 부족한 잘못된 패킷(예:
초기, 재시도 또는 버전 협상은 무시될 수 있습니다.
콘텐츠를 처리하는 경우 엔드포인트는 연결 오류를 생성해야 합니다.
오류를 발견하기 전에 이러한 패킷을 모두 되돌리거나
해당 처리 중에 변경된 사항.

5.2.1. 클라이언트 패킷 처리

클라이언트에 전송된 유효한 패킷에는 항상 대상 연결이 포함됩니다.
클라이언트가 선택한 값과 일치하는 ID입니다. 선택한 클라이언트
길이가 0인 연결 ID를 수신하면 로컬 주소와 포트를 사용할 수 있습니다.
연결을 식별합니다. 기존 연결과 일치하지 않는 패킷
연결 -- 대상 연결 ID를 기준으로 하거나 이 값이
길이가 0인 로컬 IP 주소와 포트는 삭제됩니다.

패킷 재정렬 또는 손실로 인해 클라이언트는 패킷을 수신할 수 있습니다.
아직 계산되지 않은 키로 암호화된 연결입니다.
클라이언트는 이러한 패킷을 삭제하거나 버퍼링할 수 있습니다.
키를 계산할 수 있는 후속 패킷을 예상합니다.

클라이언트가 다른 버전을 사용하는 패킷을 수신하는 경우
처음에 선택된 패킷은 반드시 삭제해야 합니다.

5.2.2. 서버 패킷 처리

서버가 지원되지 않는 버전을 나타내는 패킷을 수신하는 경우
그리고 패킷이 새로운 연결을 시작하기에 충분히 큰 경우
지원되는 모든 버전에서 서버는 버전 협상을 보내야 합니다.
6.1절에 설명된 대로 패킷. 서버는 패킷 수를 제한할 수 있습니다.
버전 협상 패킷으로 응답하는 패킷입니다.
서버는 지원되지 않는 버전을 지정하는 더 작은 패킷을 삭제해야 합니다.

지원되지 않는 버전의 첫 번째 패킷은 다른 것을 사용할 수 있습니다.
모든 버전별 필드에 대한 의미론 및 인코딩.
특히, 다른 패킷 보호 키가 사용될 수 있습니다.
다른 버전. 특정 버전을 지원하지 않는 서버
패킷의 페이로드를 해독할 수 없을 가능성이 높습니다.
결과를 올바르게 해석해야 합니다. 서버는 버전 정보를 사용하여 응답해야 합니다.
데이터그램이 충분히 긴 경우 협상 패킷입니다.

지원되는 버전이 있거나 버전 필드가 없는 패킷은 다음과 일치합니다.
연결 ID를 사용하는 연결 또는 -- 0이 있는 패킷의 경우
길이 연결 ID -- 로컬 주소 및 포트. 이러한 패킷은
선택된 연결을 사용하여 처리됩니다. 그렇지 않으면 서버
아래에 설명된 대로 계속됩니다.

패킷이 다음 사항을 완전히 준수하는 초기 패킷인 경우
사양에 따라 서버는 핸드셰이크(섹션 7)를 진행합니다.
이렇게 하면 서버가 클라이언트가 선택한 버전으로 커밋됩니다.

서버가 새로운 연결을 수락하지 않으면 다음을 보내야 합니다.
오류 코드가 포함된 CONNECTION_CLOSE 프레임을 포함하는 초기 패킷
연결이 거부되었습니다.

패킷이 0-RTT 패킷인 경우 서버는 제한된 버퍼링을 수행할 수 있습니다.
늦게 도착하는 초기 패킷을 예상하여 이러한 패킷의 수를 지정합니다.
패킷. 클라이언트는 핸드셰이크 패킷을 전송할 수 없습니다.
서버 응답을 수신하므로 서버는 이러한 응답을 무시해야 합니다.
패킷.

서버는 다른 모든 상황에서도 반드시 들어오는 패킷을 삭제해야 합니다.

5.2.3. 단순 로드 밸런서 고려 사항

서버 배포는 다음을 사용하여 서버 간 부하 분산을 수행할 수 있습니다.
소스 및 대상 IP 주소와 포트. 변경 사항
클라이언트의 IP 주소 또는 포트로 인해 패킷이 전달될 수 있습니다.
잘못된 서버로. 이러한 서버 배포에는 다음 중 하나가 사용될 수 있습니다.
클라이언트 주소가 연결 연속성을 유지하는 데 다음 방법이 사용됩니다.
변화.

* 서버는 패킷을 전달하기 위해 대역 외 메커니즘을 사용할 수 있습니다.
  연결 ID를 기반으로 올바른 서버입니다.

* 서버가 전용 서버 IP 주소 또는 포트를 사용할 수 있는 경우 기타
  클라이언트가 처음 연결한 것보다 더 많은 것을 사용할 수 있습니다.
  클라이언트에게 요청하기 위한 preferred_address 전송 매개변수
  해당 전용 주소로 연결을 이동합니다. 클라이언트는
  선호하는 주소를 사용하지 않기로 선택할 수 있습니다.

솔루션을 구현하지 않는 배포의 서버
클라이언트 주소가 변경되면 연결 연속성을 유지해야 합니다.
다음을 사용하여 마이그레이션이 지원되지 않음을 나타냅니다.
disable_active_migration 전송 매개변수.
disable_active_migration 전송 매개변수는 금지하지 않습니다.
클라이언트가 선호하는 주소에서 작업한 후 연결 마이그레이션
전송 매개변수.

이 간단한 형태의 부하 분산을 사용하는 서버 배포는 다음을 수행해야 합니다.
상태 비저장 재설정 오라클 생성을 방지합니다. 섹션 21.11을 참조하세요.

5.3. 연결 작업

이 문서는 QUIC에 대한 API를 정의하지 않습니다. 대신 다음을 정의합니다.
애플리케이션 프로토콜이 사용할 수 있는 QUIC 연결에 대한 기능 세트
의존합니다. 애플리케이션 프로토콜은 구현이
QUIC는 설명된 작업을 포함하는 인터페이스를 제공합니다.
이 섹션에서. 특정 용도로 설계된 구현
응용 프로그램 프로토콜은 다음과 같은 작업만 제공할 수 있습니다.
해당 프로토콜에서 사용됩니다.

클라이언트 역할을 구현할 때 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

* 교환을 시작하는 연결을 엽니다.
  제7조;

* 사용 가능한 경우 Early Data를 활성화합니다.

* Early Data가 승인되거나 거부되었을 때 알림을 받습니다.
  섬기는 사람.

서버 역할을 구현할 때 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

* 들어오는 연결을 수신하여 교환을 준비합니다.
  섹션 7에 설명되어 있습니다.

* Early Data가 지원되는 경우 애플리케이션 제어 데이터를 내장합니다.
  클라이언트에게 전송된 TLS 재개 티켓 및

* Early Data가 지원되는 경우 애플리케이션 제어 데이터를 검색합니다.
  클라이언트의 재개 티켓에서 조기 수락 또는 거부
  해당 정보를 기반으로 한 데이터입니다.

두 역할 모두에서 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

* 허용된 초기 수에 대한 최소값을 구성합니다.
  각 유형의 스트림은 전송 매개변수에서 전달됩니다.
  (섹션 7.4)

* 흐름 설정을 통해 수신 버퍼에 대한 리소스 할당을 제어합니다.
  스트림과 연결 모두에 대한 제어 한계

* 핸드셰이크가 성공적으로 완료되었는지 또는
  아직 진행 중;

* PING을 생성하여 연결이 자동으로 닫히지 않도록 합니다.
  프레임(섹션 19.2) 또는 전송 요청
  유휴 시간 초과가 만료되기 전 추가 프레임(섹션 10.1)
  그리고

* 연결을 즉시 닫습니다(섹션 10.2).

6. 버전 협상

   버전 협상을 통해 서버는 다음을 표시할 수 있습니다.
   클라이언트가 사용한 버전을 지원합니다. 서버는 버전을 보냅니다.
   각 패킷에 대한 응답으로 협상 패킷을 시작할 수 있습니다.
   새로운 연결입니다. 자세한 내용은 섹션 5.2를 참조하세요.

   클라이언트가 보낸 첫 번째 패킷의 크기는 다음을 결정합니다.
   서버는 버전 협상 패킷을 보냅니다. 지원하는 클라이언트
   여러 QUIC 버전은 첫 번째 UDP 데이터그램이 다음과 같은지 확인해야 합니다.
   전송은 모든 최소 데이터그램 크기 중 가장 큰 크기로 조정됩니다.
   PADDING 프레임(섹션 19.1)을 사용하여 지원하는 버전
   필요합니다. 이렇게 하면 서버가 응답합니다.
   상호 지원되는 버전입니다. 서버가 버전을 보내지 않을 수도 있습니다.
   수신한 데이터그램이 협상 패킷보다 작은 경우
   다른 버전에서 지정된 최소 크기입니다. 섹션 14.1을 참조하세요.

6.1. 버전 협상 패킷 전송

클라이언트가 선택한 버전이 적합하지 않은 경우
서버, 서버는 버전 협상 패킷으로 응답합니다.
섹션 17.2.1. 여기에는 서버의 버전 목록이 포함됩니다.
수락합니다. 엔드포인트는 버전 협상 패킷을 보내서는 안 됩니다.
버전 협상 패킷을 수신한 것에 대한 응답으로.

이 시스템을 사용하면 서버가 지원되지 않는 패킷을 처리할 수 있습니다.
상태를 유지하지 않는 버전. 초기 패킷이
또는 응답으로 전송되는 버전 협상 패킷은 다음과 같습니다.
패킷이 손실되면 클라이언트는 성공적으로 수신할 때까지 새 패킷을 보냅니다.
응답이 없거나 연결 시도가 중단됩니다.

서버는 버전 협상 패킷의 수를 제한할 수 있습니다.
전송합니다. 예를 들어, 패킷을 다음과 같이 인식할 수 있는 서버
0-RTT는 버전 협상 패킷을 보내지 않기로 선택할 수 있습니다.
0-RTT 패킷에 대한 응답은 다음과 같습니다.
결국 초기 패킷을 받게 됩니다.

6.2. 버전 협상 패킷 처리

버전 협상 패킷은 기능을 허용하도록 설계되었습니다.
QUIC가 버전을 협상할 수 있도록 향후에 정의될 예정입니다.
연결에 사용할 QUIC. 미래 표준 트랙
사양은 여러 가지를 지원하는 구현 방법을 변경할 수 있습니다.
QUIC 버전은 수신된 버전 협상 패킷에 반응합니다.
이 버전을 사용하여 연결을 설정하려는 시도에 대한 응답입니다.

이 버전의 QUIC만 지원하는 클라이언트는 다음을 포기해야 합니다.
버전 협상을 수신하는 경우 현재 연결 시도
패킷에는 다음 두 가지 예외가 있습니다. 클라이언트는 모든 패킷을 삭제해야 합니다.
버전 협상 패킷이 수신되고 성공적으로 완료된 경우
이전 버전 협상을 포함한 다른 패킷을 처리했습니다.
패킷. 클라이언트는 버전 협상 패킷을 삭제해야 합니다.
클라이언트가 선택한 QUIC 버전을 나열합니다.

버전 협상을 수행하는 방법은 향후 작업으로 정의됩니다.
향후 표준 트랙 사양. 특히, 향후
이 작업은 버전 다운그레이드 공격에 대한 견고성을 보장합니다.
섹션 21.12.

6.3. 예약된 버전 사용

서버가 향후 새 버전을 사용하려면 클라이언트가 다음을 수행해야 합니다.
지원되지 않는 버전을 올바르게 처리합니다. 일부 버전 번호는
(섹션 15에 정의된 0x?a?a?a?a)는 포함을 위해 예약되어 있습니다.
버전 번호가 포함된 필드입니다.

엔드포인트는 알 수 없거나
지원되지 않는 버전은 피어가 올바르게 테스트되었는지 무시됩니다.
값을 무시합니다. 예를 들어, 엔드포인트에는 다음이 포함될 수 있습니다.
버전 협상 패킷의 예약된 버전입니다. 섹션 17.2.1을 참조하세요.
엔드포인트는 테스트하기 위해 예약된 버전으로 패킷을 보낼 수 있습니다.
피어가 패킷을 올바르게 삭제합니다.

7. 암호화 및 전송 핸드셰이크

   QUIC는 결합된 암호화 및 전송 핸드셰이크를 사용합니다.
   연결 설정 지연 시간을 최소화합니다. QUIC은 CRYPTO를 사용합니다.
   암호화 핸드셰이크를 전송하기 위한 프레임(섹션 19.6)입니다.
   이 문서에 정의된 QUIC 버전은 0x00000001로 식별됩니다.
   [QUIC-TLS]에 설명된 대로 TLS를 사용합니다. 다른 QUIC 버전
   다른 암호화 핸드셰이크 프로토콜이 있음을 나타낼 수 있습니다.
   사용 중.

   QUIC는 암호화의 안정적이고 순서화된 전달을 제공합니다.
   핸드셰이크 데이터. QUIC 패킷 보호는 최대한 많은 데이터를 암호화하는 데 사용됩니다.
   가능한 한 핸드셰이크 프로토콜을 사용합니다. 암호화 핸드셰이크는 반드시
   다음과 같은 속성을 제공합니다.

    * 인증된 키 교환, 여기서

        - 서버는 항상 인증됩니다.

        - 클라이언트는 선택적으로 인증됩니다.

        - 모든 연결은 서로 관련 없는 별개의 키를 생성합니다.

        - 키잉 자료는 0-RTT 모두에 대한 패킷 보호에 사용 가능합니다.
          및 1-RTT 패킷.

    * 두 전송 매개변수에 대한 값의 인증된 교환
      엔드포인트 및 서버 전송을 위한 기밀 보호
      매개변수(섹션 7.4 참조).

    * 애플리케이션 프로토콜의 인증된 협상(TLS 사용)
      이를 위한 애플리케이션 계층 프로토콜 협상(ALPN) [ALPN]
      목적).

   CRYPTO 프레임은 다양한 패킷 번호 공간에서 전송될 수 있습니다.
   (섹션 12.3). CRYPTO 프레임이 순서를 보장하기 위해 사용하는 오프셋
   암호화 핸드셰이크 데이터의 전달은 각각 0부터 시작됩니다.
   패킷 번호 공간.

   그림 4는 단순화된 핸드셰이크와 패킷 교환을 보여줍니다.
   핸드셰이크를 진행하는 데 사용되는 프레임. 교환
   가능한 경우 핸드셰이크 중에 애플리케이션 데이터가 활성화됩니다.
   별표("*")로 표시됩니다. 핸드셰이크가 완료되면
   엔드포인트는 애플리케이션 데이터를 자유롭게 교환할 수 있습니다.

   클라이언트 서버

   초기 (CRYPTO)
   0-RTT (*) ---------->
   초기 (CRYPTO)
   핸드셰이크(암호화폐)
   <---------- 1-RTT (*)
   핸드셰이크(암호화폐)
   1-RTT (*) ---------->
   <---------- 1-RTT (악수_완료)

   1-RTT <=========> 1-RTT

                    그림 4: 단순화된 QUIC 핸드셰이크

   엔드포인트는 핸드셰이크 중에 전송된 패킷을 사용하여 테스트할 수 있습니다.
   명시적 혼잡 알림(ECN) 지원; 섹션 13.4 참조.
   엔드포인트는 ACK를 관찰하여 ECN에 대한 지원을 검증합니다.
   첫 번째 패킷을 보내는 것을 확인하는 프레임에는 ECN 카운트가 포함됩니다.
   섹션 13.4.2에 설명되어 있습니다.

   엔드포인트는 애플리케이션 프로토콜을 명시적으로 협상해야 합니다.
   프로토콜에 대한 의견 불일치가 있는 상황을 피합니다.
   사용 중입니다.

7.1. 핸드셰이크 흐름 예시

TLS가 QUIC와 통합되는 방법에 대한 세부 사항은 다음에서 제공됩니다.
[QUIC-TLS], 그러나 여기에 몇 가지 예가 제공됩니다. 확장
클라이언트 주소 검증을 지원하기 위한 이 교환은 다음에 표시됩니다.
섹션 8.1.2.

주소 검증 교환이 완료되면 암호화
핸드셰이크는 암호화 키에 대한 합의에 사용됩니다. 암호화
핸드셰이크는 Initial(섹션 17.2.2) 및 Handshake에서 수행됩니다.
(섹션 17.2.4) 패킷.

그림 5는 1-RTT 핸드셰이크의 개요를 제공합니다. 각 라인은
패킷 유형과 패킷 번호가 표시된 QUIC 패킷을 보여줍니다.
먼저, 일반적으로 해당 프레임에 포함된 프레임이 뒤따릅니다.
패킷. 예를 들어, 첫 번째 패킷은 Initial 유형입니다.
패킷 번호 0이며 다음을 전달하는 CRYPTO 프레임이 포함되어 있습니다.
고객 안녕하세요.

여러 QUIC 패킷(다른 패킷 유형 포함)을 사용할 수 있습니다.
단일 UDP 데이터그램으로 통합됨. 섹션 12.2 참조. 결과적으로,
이 핸드셰이크는 최소 4개의 UDP 데이터그램으로 구성될 수도 있고
더 많은 수(예: 프로토콜에 내재된 제한 사항에 따라)
혼잡 제어 및 반증폭). 예를 들어,
서버의 첫 번째 비행에는 초기 패킷, 핸드셰이크 패킷이 포함됩니다.
그리고 1-RTT 패킷의 "0.5-RTT 데이터".

클라이언트 서버

초기[0]: CRYPTO[CH] ->

                                    초기[0]: CRYPTO[SH] ACK[0]
                          핸드셰이크[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: 스트림[1, "..."]

초기[1]: ACK[0]
핸드셰이크[0]: CRYPTO[FIN], ACK[0]
1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                                             핸드셰이크[1]: ACK[0]
            <- 1-RTT[1]: 핸드셰이크 완료, 스트림[3, "..."], ACK[0]

                     그림 5: 예제 1-RTT 핸드셰이크

그림 6은 0-RTT 핸드셰이크를 사용한 연결의 예를 보여줍니다.
0-RTT 데이터의 단일 패킷. 다음에서 설명한 대로
섹션 12.3, 서버는 1-RTT 패킷에서 0-RTT 데이터를 확인합니다.
그리고 클라이언트는 동일한 패킷 번호 공간에서 1-RTT 패킷을 보냅니다.

클라이언트 서버

초기[0]: CRYPTO[CH]
0-RTT[0]: 스트림[0, "..."] ->

                                    초기[0]: CRYPTO[SH] ACK[0]
                                     악수[0] CRYPTO[EE, FIN]
                             <- 1-RTT[0]: STREAM[1, "..."] ACK[0]

초기[1]: ACK[0]
핸드셰이크[0]: CRYPTO[FIN], ACK[0]
1-RTT[1]: STREAM[0, "..."] ACK[0] ->

                                             핸드셰이크[1]: ACK[0]
            <- 1-RTT[1]: 핸드셰이크 완료, 스트림[3, "..."], ACK[1]

                     그림 6: 0-RTT 핸드셰이크 예시

7.2. 연결 ID 협상

패킷의 일관된 라우팅을 보장하기 위해 연결 ID가 사용됩니다.
섹션 5.1에 설명되어 있습니다. 긴 헤더에는 두 개의 연결이 포함되어 있습니다.
ID: 대상 연결 ID는 수신자가 선택합니다.
패킷이며 일관된 라우팅을 제공하는 데 사용됩니다. 소스
연결 ID는 대상 연결 ID를 설정하는 데 사용됩니다.
동료.

핸드셰이크 동안 긴 헤더(섹션 17.2)가 있는 패킷은
두 엔드포인트에서 사용되는 연결 ID를 설정하는 데 사용됩니다. 각각
엔드포인트는 소스 연결 ID 필드를 사용하여 지정합니다.
대상 연결 ID 필드에 사용되는 연결 ID
패킷이 전송됩니다. 첫 번째 초기 처리 후
패킷의 각 엔드포인트는 대상 연결 ID 필드를 설정합니다.
이후 패킷은 소스 연결 ID 값으로 전송됩니다.
수신한 필드입니다.

이전에 전송되지 않은 클라이언트가 초기 패킷을 전송하는 경우
서버로부터 초기 또는 재시도 패킷을 수신한 클라이언트
예측할 수 없는 대상 연결 ID 필드를 채웁니다.
값. 이 대상 연결 ID는 최소 8바이트여야 합니다.
길이. 서버로부터 패킷을 수신할 때까지 클라이언트는 반드시
이 패킷의 모든 패킷에 동일한 대상 연결 ID 값을 사용합니다.
연결.

첫 번째 초기 패킷의 대상 연결 ID 필드
클라이언트가 보낸 패킷 보호 키를 결정하는 데 사용됩니다.
초기 패킷. 이 키는 재시도 패킷을 수신한 후 변경됩니다.
[QUIC-TLS]의 섹션 5.2를 참조하세요.

클라이언트는 소스 연결 ID 필드에 값을 채웁니다.
선택하고 소스 연결 ID 길이 필드를 설정합니다.
길이를 나타냅니다.

첫 번째 비행의 0-RTT 패킷은 동일한 대상 연결을 사용합니다.
ID 및 소스 연결 ID 값은 클라이언트의 첫 번째 초기값입니다.
패킷.

서버로부터 초기 또는 재시도 패킷을 처음 수신하면
클라이언트는 서버에서 제공한 소스 연결 ID를 사용합니다.
0-RTT를 포함한 후속 패킷의 대상 연결 ID
패킷. 이는 클라이언트가 다음을 변경해야 할 수 있음을 의미합니다.
연결 ID는 대상 연결 ID 필드에 두 번 설정됩니다.
연결 설정 중: 재시도 패킷에 대한 응답으로 한 번
그리고 한 번은 서버의 초기 패킷에 대한 응답으로. 한 번은
클라이언트가 서버로부터 유효한 초기 패킷을 수신한 경우 다음을 수행해야 합니다.
해당 연결에서 수신한 후속 패킷을 모두 삭제합니다.
다른 소스 연결 ID.

클라이언트는 사용하는 대상 연결 ID를 변경해야 합니다.
첫 번째로 수신된 초기 또는
재시도 패킷. 서버는 대상 연결 ID를 설정해야 합니다.
첫 번째로 수신된 초기 패킷을 기반으로 패킷을 보내는 데 사용됩니다.
대상 연결 ID에 대한 추가 변경 사항은 다음과 같습니다.
값이 NEW_CONNECTION_ID 프레임에서 가져온 경우 허용됩니다.
이후 초기 패킷에는 다른 소스 연결 ID가 포함됩니다.
반드시 폐기해야 합니다. 이렇게 하면 예측할 수 없는 결과가 발생하지 않습니다.
그렇지 않으면 여러 초기 상태의 비상태 처리로 인해 발생할 수 있습니다.
서로 다른 소스 연결 ID를 가진 패킷.

엔드포인트가 보내는 대상 연결 ID는 변경될 수 있습니다.
연결의 수명, 특히 연결에 대한 응답
마이그레이션(섹션 9); 자세한 내용은 섹션 5.1.1을 참조하세요.

7.3. 연결 ID 인증

연결 ID에 대한 각 엔드포인트의 선택
핸드셰이크는 전송에 모든 값을 포함하여 인증됩니다.
매개변수; 섹션 7.4를 참조하세요. 이렇게 하면 모든 연결 ID가
핸드셰이크에 사용되는 것은 암호화에 의해서도 인증됩니다.
악수.

각 엔드포인트에는 소스 연결 ID 필드 값이 포함됩니다.
첫 번째 초기 패킷에서 전송된 것부터
initial_source_connection_id 전송 매개변수; 섹션 18.2를 참조하세요.
서버에는 첫 번째 대상 연결 ID 필드가 포함됩니다.
클라이언트로부터 수신한 초기 패킷
original_destination_connection_id 전송 매개변수; 서버가
재시도 패킷을 보냈습니다. 이는 수신된 첫 번째 초기 패킷을 의미합니다.
재시도 패킷을 보내기 전에. 재시도 패킷을 보내는 경우
서버에는 재시도의 소스 연결 ID 필드도 포함됩니다.
retry_source_connection_id 전송 매개변수의 패킷.

이러한 전송 매개변수에 대해 피어가 제공한 값은 다음과 같아야 합니다.
목적지와 소스에서 사용된 엔드포인트 값과 일치합니다.
전송(및 수신)된 초기 패킷의 연결 ID 필드
서버의 경우). 엔드포인트는 수신된 전송을 검증해야 합니다.
매개변수가 수신된 연결 ID 값과 일치합니다. 연결 포함
운송 매개변수의 ID 값을 확인하고 이를 검증하면
공격자는 연결 ID 선택에 영향을 미칠 수 없습니다.
공격자가 선택한 패킷을 주입하여 성공적인 연결
핸드셰이크 중의 연결 ID.

엔드포인트는 부재를 처리해야 합니다.
두 엔드포인트의 initial_source_connection_id 전송 매개변수
또는 original_destination_connection_id 전송이 없는 경우
연결 오류 유형으로 서버의 매개변수
운송 매개변수 오류.

엔드포인트는 다음을 유형의 연결 오류로 처리해야 합니다.
TRANSPORT_PARAMETER_ERROR 또는 PROTOCOL_VIOLATION:

* retry_source_connection_id 전송 매개변수가 없습니다.
  Retry 패킷을 수신한 후 서버,

* retry_source_connection_id 전송 매개변수의 존재
  재시도 패킷이 수신되지 않은 경우 또는

* 이러한 전송에서 피어로부터 수신된 값 간의 불일치
  매개변수와 해당 목적지에서 전송된 값 또는
  초기 패킷의 소스 연결 ID 필드.

길이가 0인 연결 ID가 선택된 경우 해당
전송 매개변수가 길이가 0인 값으로 포함되었습니다.

그림 7은 연결 ID(DCID=대상 연결)를 보여줍니다.
완전한 핸드셰이크에 사용되는 ID, SCID=소스 연결 ID)
초기 패킷 교환과 이후 패킷 교환이 표시됩니다.
1-RTT 패킷에는 연결 ID가 포함되어 있습니다.
악수.

클라이언트 서버

초기값: DCID=S1, SCID=C1 ->
<- 초기값: DCID=C1, SCID=S3
...
1-RTT: DCID=S3 ->
<- 1-RTT: DCID=C1

               그림 7: 핸드셰이크에서 연결 ID 사용

그림 8은 재시도 패킷을 포함하는 유사한 핸드셰이크를 보여줍니다.

클라이언트 서버

초기값: DCID=S1, SCID=C1 ->
<- 재시도: DCID=C1, SCID=S2
초기값: DCID=S2, SCID=C1 ->
<- 초기값: DCID=C1, SCID=S3
...
1-RTT: DCID=S3 ->
<- 1-RTT: DCID=C1

         그림 8: 재시도가 포함된 핸드셰이크에서 연결 ID 사용

두 경우 모두(그림 7 및 8) 클라이언트는 값을 설정합니다.
initial_source_connection_id 전송 매개변수를 "C1"로 설정합니다.

핸드셰이크에 재시도가 포함되지 않은 경우(그림 7) 서버는
original_destination_connection_id를 "S1"로 설정합니다(이 값은
(클라이언트가 선택함) 및 initial_source_connection_id를 "S3"로 설정합니다.
이 경우 서버에는 다음이 포함되지 않습니다.
retry_source_connection_id 전송 매개변수.

핸드셰이크에 재시도가 포함된 경우(그림 8) 서버는 다음을 설정합니다.
original_destination_connection_id를 "S1"로,
retry_source_connection_id를 "S2"로, initial_source_connection_id를 "S2"로
"S3"로.

7.4. 전송 매개변수

연결 설정 중에 두 엔드포인트 모두 인증을 수행합니다.
전송 매개변수 선언. 엔드포인트가 필요합니다.
각 매개변수가 정의하는 제한 사항을 준수합니다.
각 매개변수에 대한 설명에는 처리 규칙이 포함되어 있습니다.

운송 매개변수는 일방적으로 선언된 것입니다.
각 엔드포인트. 각 엔드포인트는 전송에 대한 값을 선택할 수 있습니다.
동료가 선택한 값과 무관한 매개변수입니다.

전송 매개변수의 인코딩은 섹션 18에 자세히 설명되어 있습니다.

QUIC에는 암호화된 전송 매개변수가 포함됩니다.
핸드셰이크. 핸드셰이크가 완료되면 전송 매개변수
피어가 선언한 모든 항목을 사용할 수 있습니다. 각 엔드포인트는 다음을 검증합니다.
동종업체가 제공한 가치.

정의된 각 전송 매개변수에 대한 정의가 포함됩니다.
섹션 18.2에서.

엔드포인트는 전송 매개변수 수신을 다음과 같이 처리해야 합니다.
연결 오류 유형으로 잘못된 값입니다.
운송 매개변수 오류.

엔드포인트는 주어진 매개변수를 두 번 이상 보내서는 안 됩니다.
전송 매개변수 확장. 엔드포인트는 수신을 처리해야 합니다.
연결 오류 유형으로 중복된 전송 매개변수
운송 매개변수 오류.

엔드포인트는 협상을 인증하기 위해 전송 매개변수를 사용합니다.
핸드셰이크 중의 연결 ID; 섹션 7.3을 참조하세요.

ALPN([ALPN] 참조)을 사용하면 클라이언트가 여러 애플리케이션을 제공할 수 있습니다.
연결 설정 중 프로토콜. 전송 매개변수
클라이언트가 핸드셰이크 중에 포함하는 내용은 모든 애플리케이션에 적용됩니다.
클라이언트가 제공하는 프로토콜. 애플리케이션 프로토콜은 다음과 같습니다.
초기 흐름과 같은 운송 매개변수에 대한 권장 값
제어 한계. 그러나 제약 조건을 설정하는 응용 프로그램 프로토콜
운송 매개변수 값에 대한 경우 불가능할 수 있습니다.
이러한 제약이 있는 경우 클라이언트는 여러 애플리케이션 프로토콜을 제공해야 합니다.
갈등.

7.4.1. 0-RTT에 대한 전송 매개변수 값

0-RTT 사용은 클라이언트와 서버 모두 프로토콜을 사용하는 데 따라 달라집니다.
이전 연결에서 협상된 매개변수입니다.
0-RTT를 활성화하면 엔드포인트는 서버 전송 값을 저장합니다.
연결 시 수신한 세션 티켓과 매개변수를 연결합니다.
엔드포인트는 또한 애플리케이션에 필요한 모든 정보를 저장합니다.
프로토콜 또는 암호화 핸드셰이크; [QUIC-TLS]의 섹션 4.6을 참조하세요.
저장된 전송 매개변수의 값은 시도할 때 사용됩니다.
세션 티켓을 사용한 0-RTT.

기억된 전송 매개변수는 새 연결에 적용됩니다.
핸드셰이크가 완료되고 클라이언트가 1-RTT 패킷을 보내기 시작합니다.
핸드셰이크가 완료되면 클라이언트는 전송을 사용합니다.
핸드셰이크에서 설정된 매개변수입니다. 모든 전송이
일부 매개변수는 향후 연결에 적용되지 않으므로 기억됩니다.
또는 0-RTT 사용에 아무런 영향을 미치지 않습니다.

새로운 전송 매개변수의 정의(섹션 7.4.2)는 반드시 다음과 같아야 합니다.
0-RTT에 대한 전송 매개변수를 저장할지 여부를 지정합니다.
필수, 선택 또는 금지. 클라이언트는 저장할 필요가 없습니다.
처리할 수 없는 전송 매개변수입니다.

클라이언트는 다음 매개변수에 대해 기억된 값을 사용해서는 안 됩니다.
ack_delay_exponent, max_ack_delay, initial_source_connection_id,
원래_목적지_연결_ID, 선호_주소,
retry_source_connection_id 및 stateless_reset_token. 클라이언트
대신 핸드셰이크에서 서버의 새 값을 사용해야 합니다.
서버가 새로운 값을 제공하지 않으므로 기본값이 사용됩니다.

0-RTT 데이터를 보내려고 시도하는 클라이언트는 다른 모든 것을 기억해야 합니다.
서버가 처리할 수 있는 전송 매개변수입니다.
서버는 이러한 전송 매개변수를 기억하거나 저장할 수 있습니다.
티켓의 값에 대한 무결성 보호된 사본을 복구합니다.
0-RTT 데이터를 수신할 때 정보를 사용합니다. 서버는 전송을 사용합니다.
0-RTT 데이터를 허용할지 여부를 결정하는 매개변수입니다.

서버가 0-RTT 데이터를 수락하면 서버는 다음을 줄여서는 안 됩니다.
클라이언트가 위반할 수 있는 제한이나 값을 변경합니다.
0-RTT 데이터를 사용하는 서버입니다. 특히, 0-RTT 데이터를 수신하는 서버
다음 매개변수(섹션 18.2)에 대한 값을 설정해서는 안 됩니다.
매개변수의 기억된 값보다 작습니다.

* 활성_연결_ID_제한

* 초기_최대_데이터

* 초기_최대_스트림_데이터_비디_로컬

* 초기_최대_스트림_데이터_비디_리모트

* 초기_최대_스트림_데이터_유니트

* 초기_최대_스트림_비디

* 초기_최대_스트림_유니

특정 전송 매개변수에 대해 0 값을 생략하거나 설정하면
0-RTT 데이터가 활성화되지만 사용할 수 없게 됩니다. 해당
애플리케이션 전송을 허용하는 전송 매개변수의 하위 집합
0-RTT의 경우 데이터는 0이 아닌 값으로 설정되어야 합니다. 여기에는 다음이 포함됩니다.
initial_max_data 및 (1) initial_max_streams_bidi 및
initial_max_stream_data_bidi_remote 또는 (2) initial_max_streams_uni
및 initial_max_stream_data_uni.

서버는 더 큰 초기 스트림 흐름 제어 한도를 제공할 수 있습니다.
클라이언트가 전송할 때 적용하는 기억된 값보다 더 많은 스트림
0-RTT. 핸드셰이크가 완료되면 클라이언트가 흐름을 업데이트합니다.
업데이트된 값을 사용하여 모든 전송 스트림에 대한 제어 한계를 설정합니다.
initial_max_stream_data_bidi_remote 및 initial_max_stream_data_uni.

서버는 이전에 전송된 값을 저장하고 복구할 수 있습니다.
max_idle_timeout, max_udp_payload_size 및 disable_active_migration
매개변수를 변경하고 더 작은 값을 선택하면 0-RTT를 거부합니다.
이러한 매개변수의 값을 0-RTT 데이터도 수용할 수 있습니다.
연결 성능이 저하됩니다. 특히,
max_udp_payload_size로 인해 패킷이 삭제되어 다음과 같은 문제가 발생할 수 있습니다.
0-RTT 데이터를 완전히 거부하는 것에 비해 성능이 떨어집니다.

전송을 위해 복원된 값이 있는 경우 서버는 0-RTT 데이터를 거부해야 합니다.
매개변수를 지원할 수 없습니다.

0-RTT 패킷으로 프레임을 보낼 때 클라이언트는 다음만 사용해야 합니다.
기억된 전송 매개변수; 중요한 것은 업데이트된 것을 사용해서는 안 된다는 것입니다.
서버의 업데이트된 전송 매개변수에서 학습한 값
또는 1-RTT 패킷으로 수신된 프레임에서. 업데이트된 값
핸드셰이크의 전송 매개변수는 1-RTT 패킷에만 적용됩니다.
예를 들어, 기억된 운송의 흐름 제어 한계
해당 값이 0-RTT 패킷에 적용되더라도 매개변수는 모든 0-RTT 패킷에 적용됩니다.
핸드셰이크 또는 1-RTT 패킷으로 전송된 프레임에 의해 증가합니다.
서버는 0-RTT에서 업데이트된 전송 매개변수 사용을 다음과 같이 처리할 수 있습니다.
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

7.4.2. 새로운 전송 매개변수

새로운 전송 매개변수를 사용하여 새로운 프로토콜을 협상할 수 있습니다.
동작. 엔드포인트는 자신이 수행하는 전송 매개변수를 무시해야 합니다.
지원하지 않습니다. 따라서 전송 매개변수가 없으면 비활성화됩니다.
매개변수를 사용하여 협상되는 모든 선택적 프로토콜 기능입니다.
섹션 18.1에 설명된 대로 일부 식별자는 예약되어 있습니다.
이 요구 사항을 행사하려면.

전송 매개변수를 이해하지 못하는 클라이언트는 다음을 삭제할 수 있습니다.
이를 시도하고 후속 연결에서 0-RTT를 시도합니다. 그러나
클라이언트가 삭제된 전송 매개변수에 대한 지원을 추가하면 위험이 발생합니다.
전송 매개변수가 설정한 제약 조건을 위반하는 경우
0-RTT를 시도합니다. 새로운 전송 매개변수를 사용하면 이 문제를 피할 수 있습니다.
가장 보수적인 값을 기본값으로 설정하여 클라이언트가
모든 매개변수를 기억함으로써 이 문제를 방지하십시오.
현재 지원됨.

새로운 운송 매개변수는 규칙에 따라 등록될 수 있습니다.
섹션 22.3.

7.5. 암호화 메시지 버퍼링

구현에서는 수신된 CRYPTO 데이터의 버퍼를 유지해야 합니다.
순서. CRYPTO 프레임의 흐름 제어가 없기 때문에
엔드포인트는 잠재적으로 피어가 무제한 버퍼링을 하도록 강제할 수 있습니다.
데이터의 양.

구현은 최소 4096바이트의 데이터 버퍼링을 지원해야 합니다.
순서가 잘못된 CRYPTO 프레임으로 수신되었습니다. 엔드포인트는 다음을 선택할 수 있습니다.
핸드셰이크 중에 더 많은 데이터를 버퍼링할 수 있도록 허용합니다. 더 큰 제한
핸드셰이크 중에 더 큰 키나 자격 증명을 허용할 수 있습니다.
교환되었습니다. 엔드포인트의 버퍼 크기는 유지될 필요가 없습니다.
연결 수명 동안 일정하게 유지됩니다.

핸드셰이크 중에 CRYPTO 프레임을 버퍼링할 수 없으면 다음과 같은 문제가 발생할 수 있습니다.
연결 실패. 엔드포인트의 버퍼가 초과되면
핸드셰이크를 통해 버퍼를 일시적으로 확장하여 완료할 수 있습니다.
핸드셰이크. 엔드포인트가 버퍼를 확장하지 않으면 반드시 닫아야 합니다.
CRYPTO_BUFFER_EXCEEDED 오류 코드가 있는 연결입니다.

핸드셰이크가 완료되면 엔드포인트가 모든 것을 버퍼링할 수 없는 경우
CRYPTO 프레임의 데이터가 있는 경우 해당 CRYPTO 프레임과 모든 데이터를 삭제할 수 있습니다.
미래에 수신된 CRYPTO 프레임이거나 연결을 닫을 수 있습니다.
CRYPTO_BUFFER_EXCEEDED 오류 코드가 포함된 패킷
패킷이 삭제되었기 때문에 삭제된 CRYPTO 프레임은 반드시 확인되어야 합니다.
CRYPTO가 운송 중 수신 및 처리되었음에도 불구하고
프레임이 삭제되었습니다.

8. 주소 확인

   주소 검증은 엔드포인트가 다음에 사용될 수 없음을 보장합니다.
   트래픽 증폭 공격. 이러한 공격에서는 패킷이
   위조된 소스 주소 정보가 있는 서버
   피해자. 서버가 이에 대한 응답으로 더 많거나 더 큰 패킷을 생성하는 경우
   해당 패킷을 통해 공격자는 서버를 사용하여 더 많은 데이터를 보낼 수 있습니다.
   스스로 보낼 수 있는 것보다 피해자에게 더 많은 것을 보낼 수 있습니다.

   증폭 공격에 대한 주요 방어 수단은 다음을 확인하는 것입니다.
   피어는 자신이 전송하는 주소에서 패킷을 수신할 수 있습니다.
   청구합니다. 따라서 주소에서 패킷을 수신한 후
   아직 검증되지 않은 경우 엔드포인트는 전송하는 데이터 양을 제한해야 합니다.
   검증되지 않은 주소로 수신된 데이터 양의 3배까지
   해당 주소에서. 응답 크기에 대한 이 제한은 다음과 같이 알려져 있습니다.
   반증폭 한계.

   주소 검증은 연결 설정 중에 수행됩니다.
   (8.1절 참조) 및 연결 마이그레이션 중(8.2절 참조).

8.1. 연결 설정 중 주소 유효성 검사

연결 설정은 암시적으로 주소 검증을 제공합니다.
두 엔드포인트 모두. 특히, 보호된 패킷 수신
핸드셰이크 키는 피어가 성공적으로 처리했음을 확인합니다.
초기 패킷. 엔드포인트가 성공적으로 처리되면
피어로부터의 핸드셰이크 패킷은 피어 주소를 고려할 수 있습니다.
검증되었습니다.

또한 엔드포인트는 피어 주소가 검증된 것으로 간주할 수 있습니다.
피어는 엔드포인트에서 선택한 연결 ID를 사용합니다.
연결 ID에는 최소 64비트의 엔트로피가 포함되어 있습니다.

클라이언트의 경우 대상 연결 ID 필드의 값은
첫 번째 초기 패킷을 통해 서버 주소를 검증할 수 있습니다.
모든 패킷을 성공적으로 처리하는 데 필요한 부분입니다. 초기 패킷은
서버는 이 값에서 파생된 키로 보호됩니다.
([QUIC-TLS]의 섹션 5.2 참조). 또는 값이 에코됩니다.
버전 협상 패킷(섹션 6)의 서버에 의해 또는 포함됨
재시도 패킷의 무결성 태그([QUIC-TLS]의 섹션 5.8).

클라이언트 주소를 검증하기 전에 서버는 더 이상 보내서는 안 됩니다.
그들이 가지고 있는 바이트 수보다 3배 이상 많은 바이트
수신됨. 이는 증폭 공격의 규모를 제한합니다.
스푸핑된 소스 주소를 사용하여 마운트될 수 있습니다.
주소 검증 전에 증폭을 피하려면 서버는 다음을 수행해야 합니다.
데이터그램에서 수신된 모든 페이로드 바이트를 계산합니다.
단일 연결에만 고유하게 적용됩니다. 여기에는 데이터그램이 포함됩니다.
성공적으로 처리된 패킷과 데이터그램을 포함하는
모두 삭제된 패킷이 포함되어 있습니다.

클라이언트는 초기 패킷을 포함하는 UDP 데이터그램을 보장해야 합니다.
최소 1200바이트의 UDP 페이로드를 갖고 PADDING 프레임을 추가합니다.
필요합니다. 패딩된 데이터그램을 보내는 클라이언트는 서버가 다음을 수행할 수 있도록 합니다.
주소 검증을 완료하기 전에 더 많은 데이터를 보내세요.

서버에서 초기 패킷이나 핸드셰이크 패킷이 손실되면 다음과 같은 문제가 발생할 수 있습니다.
클라이언트가 추가 초기 또는 핸드셰이크를 보내지 않으면 교착 상태가 발생합니다.
패킷. 서버가 해당 패킷에 도달하면 교착 상태가 발생할 수 있습니다.
증폭 한계 및 클라이언트가 확인을 받았습니다.
보낸 모든 데이터입니다. 이 경우 클라이언트에 데이터가 없는 경우
추가 패킷을 보내야 하는 이유가 있으면 서버는 패킷을 보낼 수 없습니다.
클라이언트의 주소가 검증되지 않았기 때문에 더 많은 데이터가 있습니다.
이 교착 상태를 방지하려면 클라이언트가 Probe Timeout에 패킷을 보내야 합니다.
(PTO); [QUIC-RECOVERY]의 섹션 6.2를 참조하세요. 특히 클라이언트
최소한 다음을 포함하는 UDP 데이터그램에서 초기 패킷을 보내야 합니다.
핸드셰이크 키가 없으면 1200바이트를 보내고, 그렇지 않으면 다음을 보냅니다.
악수 패킷.

서버는 시작하기 전에 클라이언트 주소를 검증하려고 할 수 있습니다.
암호화 핸드셰이크. QUIC은 초기 패킷에서 토큰을 사용합니다.
핸드셰이크를 완료하기 전에 주소 검증을 제공합니다.
이 토큰은 연결 설정 중에 클라이언트에게 전달됩니다.
재시도 패킷(섹션 8.1.2 참조) 또는 이전 연결에서
NEW_TOKEN 프레임을 사용합니다(섹션 8.1.3 참조).

주소 검증 전에 부과된 전송 제한 외에도,
서버는 또한 설정된 제한에 따라 보낼 수 있는 내용에 제한을 받습니다.
혼잡 컨트롤러에 의해. 클라이언트는 다음에 의해서만 제한됩니다.
혼잡 제어 장치.

8.1.1. 토큰 구성

NEW_TOKEN 프레임이나 Retry 패킷에서 전송된 토큰은 반드시
서버가 어떻게 식별되었는지 확인할 수 있는 방식으로 구성됨
클라이언트에게 제공됩니다. 이러한 토큰은 동일한 필드에 전달되지만
서버에서는 다른 처리가 필요합니다.

8.1.2. 재시도 패킷을 사용한 주소 검증

클라이언트의 초기 패킷을 수신하면 서버는 다음을 요청할 수 있습니다.
재시도 패킷을 보내어 주소 검증(섹션 17.2.5)
토큰을 포함합니다. 이 토큰은 클라이언트가 모든
수신 후 해당 연결에 대해 보내는 초기 패킷
패킷을 다시 시도합니다.

토큰을 포함하는 초기 패킷을 처리하는 것에 대한 응답으로
Retry 패킷에 제공되었으므로 서버는 다른 Retry를 보낼 수 없습니다.
패킷은 연결을 거부하거나 계속 진행하도록 허용할 수만 있습니다.

공격자가 유효한 것을 생성할 수 없는 한
자체 주소에 대한 토큰(섹션 8.1.4 참조) 및 클라이언트가 가능합니다.
해당 토큰을 반환하면 서버에 해당 토큰을 수신했다는 것이 증명됩니다.
토큰.

서버는 또한 재시도 패킷을 사용하여 상태를 연기할 수 있습니다.
연결 설정 처리 비용. 서버 요구 사항
다른 연결 ID를 제공하려면
original_destination_connection_id 전송 매개변수는 다음에 정의되어 있습니다.
섹션 18.2에서는 서버가 자신 또는 엔터티를 입증하도록 요구합니다.
협력하고 원래의 초기 패킷을 수신했습니다.
클라이언트. 다른 연결 ID를 제공하면 서버에도 권한이 부여됩니다.
이후 패킷이 라우팅되는 방식을 어느 정도 제어할 수 있습니다.
다른 서버 인스턴스에 직접 연결하는 데 사용됩니다.

서버가 잘못된 재시도를 포함하는 클라이언트 초기값을 수신하는 경우
토큰이지만 다른 면에서는 유효하지 않은 경우 클라이언트가 수락하지 않을 것임을 알고 있습니다.
또 다른 재시도 토큰. 서버는 이러한 패킷을 삭제하고 허용할 수 있습니다.
클라이언트가 핸드셰이크 실패를 감지하기 위해 시간 초과를 발생시킬 수 있지만
클라이언트에 상당한 지연 시간 페널티를 부과합니다. 대신,
서버는 연결을 즉시 닫아야 합니다(섹션 10.2)
INVALID_TOKEN 오류입니다. 서버가 토큰을 설정하지 않았습니다.
이 시점에서 연결에 대한 상태이므로 입력되지 않습니다.
마감 기간.

재시도 패킷의 사용을 보여주는 흐름은 그림 9에 나와 있습니다.

클라이언트 서버

초기[0]: CRYPTO[CH] ->

                                                   <- 재시도+토큰

초기+토큰[1]: CRYPTO[CH] ->

                                    초기[0]: CRYPTO[SH] ACK[1]
                          핸드셰이크[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: 스트림[1, "..."]

                   그림 9: 재시도가 포함된 핸드셰이크 예

8.1.3. 향후 연결을 위한 주소 유효성 검사

서버는 클라이언트에게 주소 검증 토큰을 제공할 수 있습니다.
후속 연결에서 사용할 수 있는 하나의 연결입니다. 주소
특히 0-RTT의 경우 검증이 중요합니다.
잠재적으로 클라이언트에게 상당한 양의 데이터를 전송합니다.
0-RTT 데이터에 대한 응답.

서버는 NEW_TOKEN 프레임(섹션 19.7)을 사용하여 다음을 제공합니다.
주소 검증 토큰을 사용하여 검증할 수 있는 클라이언트
미래 연결. 미래 연결에서 클라이언트는 이것을 포함합니다.
주소 유효성 검사를 제공하기 위해 초기 패킷에 토큰을 포함합니다. 클라이언트
모든 초기 패킷에 토큰을 포함해야 합니다.
재시도는 토큰을 새 토큰으로 교체합니다. 클라이언트는 다음을 사용해서는 안 됩니다.
향후 연결을 위해 재시도 시 제공된 토큰입니다. 서버는 다음을 수행할 수 있습니다.
예상 토큰을 포함하지 않는 초기 패킷을 삭제합니다.

Retry 패킷에 대해 생성된 토큰과 달리
즉시 NEW_TOKEN 프레임에서 전송된 토큰은 다음에 사용될 수 있습니다.
일정 시간이 지났습니다. 따라서 토큰에는 다음이 있어야 합니다.
만료 시간은 명시적인 만료 시간일 수도 있고
동적으로 계산하는 데 사용할 수 있는 발급된 타임스탬프
만료 시간. 서버는 만료 시간을 저장하거나 포함할 수 있습니다.
토큰에 암호화된 형태로 저장됩니다.

NEW_TOKEN으로 발행된 토큰에는 다음 정보가 포함되어서는 안 됩니다.
관찰자가 연결에 값을 연결할 수 있도록 허용합니다.
발행되었습니다. 예를 들어, 이전 내용을 포함할 수 없습니다.
값이 아닌 경우 연결 ID 또는 주소 정보
암호화됨. 서버는 전송하는 모든 NEW_TOKEN 프레임이 암호화되었는지 확인해야 합니다.
모든 클라이언트에서 고유하며 전송된 클라이언트는 제외됩니다.
이전에 전송된 NEW_TOKEN 프레임의 손실을 복구합니다. 정보
서버가 Retry와 토큰을 구별할 수 있도록 합니다.
NEW_TOKEN은 서버 이외의 엔터티에서도 접근할 수 있습니다.

클라이언트 포트 번호가 두 개 모두 동일할 가능성은 없습니다.
다른 연결이므로 포트를 검증하는 것은 불가능합니다.
성공하다.

NEW_TOKEN 프레임에서 수신된 토큰은 모든 서버에 적용 가능합니다.
연결이 (예: 서버)에 대해 권한이 있는 것으로 간주됨
인증서에 포함된 이름). 서버에 연결할 때
클라이언트가 적용 가능하고 사용되지 않는 토큰을 보관하는 경우 다음을 수행해야 합니다.
해당 토큰을 초기 패킷의 토큰 필드에 포함합니다.
토큰을 포함하면 서버가 클라이언트를 검증할 수 있습니다.
추가 왕복 여행 없이 주소를 입력하세요. 클라이언트는 다음을 포함해서는 안 됩니다.
연결 중인 서버에 적용할 수 없는 토큰
클라이언트가 발행한 서버에 대한 지식이 없는 한
토큰과 클라이언트가 연결하는 서버는 공동입니다.
토큰 관리. 클라이언트는 이전 토큰을 사용할 수 있습니다.
해당 서버에 연결됨.

토큰을 사용하면 서버가 연결 간의 활동을 상관시킬 수 있습니다.
토큰이 발행된 위치와 토큰이 사용된 모든 연결입니다.
서버와의 신원 연속성을 끊고자 하는 클라이언트는 다음을 수행할 수 있습니다.
NEW_TOKEN 프레임을 사용하여 제공된 토큰을 삭제합니다. 비교해 보면,
재시도 패킷에서 얻은 토큰은 즉시 사용해야 합니다.
연결 시도가 실패하여 후속 연결에 사용할 수 없습니다.
시도.

클라이언트는 NEW_TOKEN 프레임에서 토큰을 재사용해서는 안 됩니다.
다른 연결 시도. 토큰을 재사용하면 연결이 가능합니다.
네트워크 경로에 있는 엔터티에 의해 연결됩니다. 섹션 9.5를 참조하세요.

클라이언트는 단일 연결에서 여러 토큰을 수신할 수 있습니다.
연결 가능성을 방해하지 않으므로 모든 토큰은 모든 연결에서 사용할 수 있습니다.
시도. 서버는 주소를 활성화하기 위해 추가 토큰을 보낼 수 있습니다.
여러 연결 시도에 대한 검증 또는 이전 토큰 교체
무효화될 수 있습니다. 클라이언트의 경우 이러한 모호성은 다음을 의미합니다.
가장 최근에 사용되지 않은 토큰을 보내는 것이 가장 효과적일 가능성이 높습니다.
오래된 토큰을 저장하고 사용하는 것이 부정적인 결과를 초래하지는 않지만,
클라이언트는 이전 토큰이 유용할 가능성이 낮다고 생각할 수 있습니다.
주소 검증을 위한 서버.

서버가 주소 검증을 포함하는 초기 패킷을 수신하는 경우
토큰의 경우 이미 토큰을 검증한 경우가 아니면 토큰의 검증을 시도해야 합니다.
주소 유효성 검사가 완료되었습니다. 토큰이 유효하지 않으면
서버는 클라이언트가 검증되지 않은 것처럼 진행해야 합니다.
주소, 잠재적으로 재시도 패킷 전송 포함. 토큰
NEW_TOKEN 프레임과 Retry 패킷이 제공되어 구별될 수 있습니다.
서버에 의해(섹션 8.1.1 참조) 후자는 더 많이 검증될 수 있습니다.
엄격하게. 검증이 성공하면 서버는 다음을 허용해야 합니다.
악수를 통해 계속 진행합니다.

      | 참고: 클라이언트를 검증되지 않은 것으로 처리하는 근거
      | 패킷을 삭제하는 것보다 클라이언트가
      | NEW_TOKEN을 사용하여 이전 연결에서 토큰을 받았습니다.
      | 프레임이며 서버가 상태를 잃은 경우 다음을 수행할 수 없습니다.
      | 토큰을 전혀 검증하지 않으면 연결이 실패합니다.
      | 패킷이 삭제됩니다.

무상태 설계에서 서버는 암호화되고 인증된 것을 사용할 수 있습니다.
서버가 나중에 사용할 수 있는 클라이언트에게 정보를 전달하는 토큰
클라이언트 주소를 복구하고 검증하는 데 사용합니다. 토큰은
암호화 핸드셰이크에 통합되어 있으므로
인증됨. 예를 들어, 클라이언트는 다음을 재사용할 수 있습니다.
토큰. 이 속성을 악용하는 공격을 방지하기 위해 서버는
토큰 사용을 검증에 필요한 정보로만 제한합니다.
클라이언트 주소.

클라이언트는 하나의 연결에서 얻은 토큰을 다른 연결에도 사용할 수 있습니다.
동일한 버전을 사용해 보세요. 사용할 토큰을 선택할 때
클라이언트는 연결의 다른 속성을 고려할 필요가 없습니다.
가능한 응용 프로그램 선택을 포함하여 시도되고 있는 것
프로토콜, 세션 티켓 또는 기타 연결 속성.

8.1.4. 주소 검증 토큰 무결성

주소 검증 토큰은 추측하기 어려워야 합니다.
토큰에 최소 128비트의 엔트로피가 있는 난수 값은 다음과 같습니다.
충분하지만 이는 서버가 값을 기억하는 데 달려 있습니다.
클라이언트에게 전송합니다.

토큰 기반 방식을 사용하면 서버가 모든 상태를 오프로드할 수 있습니다.
클라이언트에 대한 검증과 관련이 있습니다. 이 디자인이 작동하려면
토큰은 무결성 보호로 보호되어야 합니다.
고객에 의한 수정 또는 위조. 무결성 없음
보호, 악의적인 클라이언트는 값을 생성하거나 추측할 수 있습니다.
서버에서 허용하는 토큰입니다. 서버만
토큰의 무결성 보호 키에 대한 액세스가 필요합니다.

토큰에 대해 명확하게 정의된 단일 형식이 필요하지 않습니다.
토큰을 생성하는 서버도 토큰을 사용하기 때문입니다. 토큰
재시도 패킷에 전송된 내용에는 다음을 허용하는 정보가 포함되어야 합니다.
클라이언트의 소스 IP 주소와 포트를 확인하기 위한 서버
패킷은 일정하게 유지됩니다.

NEW_TOKEN 프레임에서 전송된 토큰에는 다음을 허용하는 정보가 포함되어야 합니다.
클라이언트 IP 주소가 변경되지 않았는지 확인하기 위해 서버
토큰이 발급된 시점입니다. 서버는 NEW_TOKEN의 토큰을 사용할 수 있습니다.
클라이언트가 재시도 패킷을 보내지 않기로 결정하더라도 프레임은
주소가 변경되었습니다. 클라이언트 IP 주소가 변경된 경우
서버는 반증폭 제한을 준수해야 합니다. 섹션 8을 참조하세요.
NAT가 있는 경우 이 요구 사항이 적용될 수 있습니다.
NAT를 공유하는 다른 호스트를 보호하기에는 부족합니다.
증폭 공격.

공격자는 DDoS에서 서버를 증폭기로 사용하기 위해 토큰을 재생할 수 있습니다.
공격. 이러한 공격으로부터 보호하려면 서버는 다음을 보장해야 합니다.
토큰 재생이 방지되거나 제한됩니다. 서버는 다음을 보장해야 합니다.
재시도 패킷에서 전송된 토큰은 짧은 시간 동안만 허용됩니다.
클라이언트가 즉시 반환합니다. 제공되는 토큰
NEW_TOKEN 프레임(섹션 19.7)에서는 더 오랫동안 유효해야 하지만
여러 번 수락해서는 안 됩니다. 서버는 다음을 권장합니다.
가능하다면 토큰을 한 번만 사용하도록 허용합니다. 토큰에는 다음이 포함될 수 있습니다.
적용 범위를 더욱 좁히기 위한 클라이언트에 대한 추가 정보
또는 재사용.

8.2. 경로 검증

연결 마이그레이션 중 두 피어 모두 경로 검증을 사용합니다.
(섹션 9 참조) 주소 변경 후 도달 가능성을 확인하려면
경로 검증, 특정 로컬 간의 엔드포인트 도달성 테스트
주소와 특정 피어 주소, 여기서 주소는 2-튜플입니다.
IP 주소와 포트.

피어로의 경로에 전송된 패킷이 경로 검증 테스트에 의해 검증됩니다.
해당 피어가 수신했습니다. 경로 검증은 다음을 보장하는 데 사용됩니다.
마이그레이션하는 피어로부터 수신된 패킷은 스푸핑된 소스를 전달하지 않습니다.
주소.

경로 검증은 피어가 반환을 보낼 수 있는지 검증하지 않습니다.
방향. 확인은 반환 경로 검증에 사용할 수 없습니다.
엔트로피가 부족하고 위조될 가능성이 있기 때문입니다.
엔드포인트는 각 방향의 도달 가능성을 독립적으로 결정합니다.
경로이므로 반환 도달 가능성은 다음에 의해서만 설정될 수 있습니다.
동료.

경로 검증은 어느 엔드포인트에서든 언제든지 사용할 수 있습니다.
예를 들어, 엔드포인트는 피어가 여전히 소유권을 가지고 있는지 확인할 수 있습니다.
일정 기간의 휴면 후 주소.

경로 검증은 NAT 통과 메커니즘으로 설계되지 않았습니다.
여기에 설명된 메커니즘은 다음을 생성하는 데 효과적일 수 있습니다.
NAT 트래버설을 지원하는 NAT 바인딩의 경우 다음이 예상됩니다.
엔드포인트는 먼저 패킷을 보내지 않고도 패킷을 수신할 수 있습니다.
해당 경로의 패킷입니다. 효과적인 NAT 통과에는 추가가 필요합니다.
여기에 제공되지 않는 동기화 메커니즘.

엔드포인트에는 PATH_CHALLENGE가 포함된 다른 프레임이 포함될 수 있습니다.
경로 유효성 검사에 사용되는 PATH_RESPONSE 프레임입니다. 특히,
엔드포인트에는 PATH_CHALLENGE 프레임이 포함된 PADDING 프레임이 포함될 수 있습니다.
경로 최대 전송 단위 검색(PMTUD); 섹션 14.2.1을 참조하세요.
엔드포인트는 또한 자체 PATH_CHALLENGE 프레임을 포함할 수 있습니다.
PATH_RESPONSE 프레임을 보냅니다.

엔드포인트는 새 로컬에서 보낸 프로브에 대해 새 연결 ID를 사용합니다.
주소; 섹션 9.5를 참조하세요. 새 경로를 탐색할 때 엔드포인트는
피어가 사용할 수 있는 사용되지 않은 연결 ID를 가지고 있는지 확인하십시오.
응답. NEW_CONNECTION_ID 및 PATH_CHALLENGE 프레임을 보냅니다.
동일한 패킷, 피어의 active_connection_id_limit이 허용하는 경우
사용되지 않은 연결 ID가 피어에서 사용 가능하도록 보장합니다.
응답을 보낼 때.

엔드포인트는 여러 경로를 동시에 탐색하도록 선택할 수 있습니다.
프로브에 사용되는 동시 경로 수는 다음 수로 제한됩니다.
이전에 피어가 제공한 추가 연결 ID의 경우 각각
프로브에 사용되는 새 로컬 주소에는 이전에 사용되지 않은 주소가 필요합니다.
연결 ID.

8.2.1. 경로 검증 시작

경로 검증을 시작하려면 엔드포인트가 PATH_CHALLENGE 프레임을 보냅니다.
검증할 경로에 예측할 수 없는 페이로드가 포함되어 있습니다.

엔드포인트는 다음을 방지하기 위해 여러 PATH_CHALLENGE 프레임을 보낼 수 있습니다.
패킷 손실. 그러나 엔드포인트는 여러 개를 보내서는 안 됩니다.
단일 패킷의 PATH_CHALLENGE 프레임.

엔드포인트는 패킷이 포함된 새 경로를 조사해서는 안 됩니다.
PATH_CHALLENGE 프레임을 초기값보다 더 자주 보냅니다.
패킷. 이렇게 하면 연결 마이그레이션이 더 이상 부하를 주지 않습니다.
새로운 연결을 구축하는 것보다 새로운 경로를 만드는 것이 더 중요합니다.

엔드포인트는 모든 PATH_CHALLENGE에서 예측할 수 없는 데이터를 사용해야 합니다.
프레임을 사용하여 피어의 응답을 연결할 수 있습니다.
해당 PATH_CHALLENGE.

엔드포인트는 PATH_CHALLENGE 프레임을 포함하는 데이터그램을 확장해야 합니다.
최소한 허용되는 최소 최대 데이터그램 크기인 1200바이트까지
경로에 대한 반증폭 한계가 허용하지 않는 한
이 크기의 데이터그램을 전송합니다. 이 크기의 UDP 데이터그램을 전송합니다.
엔드포인트에서 피어까지의 네트워크 경로를 보장합니다.
QUIC에 사용됩니다. 섹션 14를 참조하세요.

엔드포인트가 데이터그램 크기를 1200바이트로 확장할 수 없는 경우
반증폭 제한으로 인해 경로 MTU가 되지 않습니다.
검증됨. 경로 MTU가 충분히 큰지 확인하려면 엔드포인트
PATH_CHALLENGE를 보내어 두 번째 경로 검증을 수행해야 합니다.
최소 1200바이트의 데이터그램에 있는 프레임입니다. 이 추가
PATH_RESPONSE가 성공적으로 수행된 후 검증을 수행할 수 있습니다.
수신되었거나 경로에서 충분한 바이트가 수신되었을 때
더 큰 데이터그램을 보내도 안티-를 초과하지 않습니다.
증폭 한계.

데이터그램이 확장되는 다른 경우와 달리 엔드포인트는 다음과 같아야 합니다.
너무 작아 보이는 데이터그램을 삭제합니다.
PATH_CHALLENGE 또는 PATH_RESPONSE.

8.2.2. 경로 검증 응답

PATH_CHALLENGE 프레임을 수신하면 엔드포인트는 다음과 같이 응답해야 합니다.
PATH_CHALLENGE 프레임에 포함된 데이터를 에코합니다.
PATH_RESPONSE 프레임. 엔드포인트는 전송을 지연해서는 안 됩니다.
PATH_RESPONSE 프레임을 포함하는 패킷은 다음에 의해 제한되지 않는 한
혼잡 통제.

PATH_RESPONSE 프레임은 네트워크 경로에 전송되어야 합니다.
PATH_CHALLENGE 프레임이 수신되었습니다. 이를 통해 경로 검증이 보장됩니다.
피어에 의한 연결은 경로가 양방향으로 기능하는 경우에만 성공합니다.
이 요구 사항은 시작하는 엔드포인트에서 적용되어서는 안 됩니다.
경로 검증은 마이그레이션에 대한 공격을 가능하게 하므로 참조하세요.
섹션 9.3.3.

엔드포인트는 PATH_RESPONSE 프레임을 포함하는 데이터그램을 확장해야 합니다.
최소한 허용되는 최대 데이터그램 크기인 1200바이트까지.
이는 경로가 이 크기의 데이터그램을 전송할 수 있음을 확인합니다.
양방향으로. 그러나 엔드포인트는 확장되어서는 안 됩니다.
결과 데이터가 초과하는 경우 PATH_RESPONSE를 포함하는 데이터그램
반증폭 한계. 이는 다음과 같은 경우에만 발생할 것으로 예상됩니다.
수신된 PATH_CHALLENGE가 확장된 데이터그램으로 전송되지 않았습니다.

엔드포인트는 두 개 이상의 PATH_RESPONSE 프레임을 보내서는 안 됩니다.
한 PATH_CHALLENGE 프레임에 대한 응답; 섹션 13.3을 참조하세요. 피어는
필요에 따라 더 많은 PATH_CHALLENGE 프레임을 보내어 호출할 것으로 예상됩니다.
추가 PATH_RESPONSE 프레임.

8.2.3. 성공적인 경로 검증

PATH_RESPONSE 프레임이 수신되면 경로 검증이 성공합니다.
이전 PATH_CHALLENGE 프레임에서 전송된 데이터가 포함되어 있습니다.
모든 네트워크 경로에서 수신된 PATH_RESPONSE 프레임은 경로를 검증합니다.
PATH_CHALLENGE가 전송되었습니다.

엔드포인트가 PATH_CHALLENGE 프레임을 데이터그램으로 보내는 경우
최소 1200바이트로 확장되고 이에 대한 응답이 검증되면
피어 주소의 경우 경로는 검증되지만 경로 MTU는 검증되지 않습니다.
결과적으로 엔드포인트는 이제 3배 이상의 양을 보낼 수 있습니다.
수신된 데이터입니다. 그러나 엔드포인트는 다음을 시작해야 합니다.
확장된 데이터그램을 사용하여 다른 경로 검증을 수행하여 다음을 확인합니다.
경로가 필요한 MTU를 지원합니다.

PATH_CHALLENGE를 포함하는 패킷에 대한 확인 수신
프레임은 확인이 가능하기 때문에 적절한 검증이 아닙니다.
악의적인 피어에 의해 스푸핑됨.

8.2.4. 실패한 경로 검증

경로 검증은 엔드포인트가 검증을 시도할 때만 실패합니다.
경로는 경로를 검증하려는 시도를 포기합니다.

엔드포인트는 타이머를 기반으로 경로 유효성 검사를 중단해야 합니다.
이 타이머를 설정하면 구현 시 새 경로에 대한 경고가 표시됩니다.
원본보다 왕복 시간이 더 길어질 수 있습니다.
현재 PTO 또는 새로운 경로의 PTO보다 큰 PTO의 3배
([QUIC-RECOVERY]에 정의된 대로 kInitialRtt를 사용하는 것이 권장됩니다.)

이 시간 초과를 사용하면 경로가 실패하기 전에 여러 PTO가 만료될 수 있습니다.
유효성 검사를 통해 단일 PATH_CHALLENGE 또는 PATH_RESPONSE가 손실됩니다.
프레임은 경로 검증 실패를 일으키지 않습니다.

엔드포인트가 다른 프레임을 포함하는 패킷을 수신할 수 있음을 유의하세요.
새로운 경로에 있지만 적절한 데이터가 있는 PATH_RESPONSE 프레임이 있습니다.
경로 검증이 성공하려면 필요합니다.

엔드포인트가 경로 검증을 중단하면 다음을 결정합니다.
경로를 사용할 수 없습니다. 이는 반드시 실패를 의미하지는 않습니다.
연결 -- 엔드포인트는 다른 경로를 통해 패킷을 계속 보낼 수 있습니다.
적절한 경우. 사용 가능한 경로가 없으면 엔드포인트는 다음을 기다릴 수 있습니다.
연결을 사용할 수 있게 되거나 연결을 닫을 수 있는 새로운 경로입니다. 엔드포인트
피어에 대한 유효한 네트워크 경로가 없는 경우 다음을 사용하여 이를 신호할 수 있습니다.
NO_VIABLE_PATH 연결 오류, 이것이 가능한 경우에만 해당됨을 알려드립니다.
네트워크 경로는 존재하지만 필요한 MTU를 지원하지 않습니다.
(제14절).

경로 검증은 다음과 같은 이유로 중단될 수 있습니다.
실패. 주로 이는 새 연결로 마이그레이션하는 경우 발생합니다.
이전 경로에 대한 경로 검증이 진행되는 동안 경로가 시작됩니다.
진전.

9. 연결 마이그레이션

   연결 ID를 사용하면 연결이 변경 사항을 유지하도록 할 수 있습니다.
   IP 주소 및 포트와 같은 엔드포인트 주소
   새 네트워크로 마이그레이션하는 엔드포인트입니다. 이 섹션에서는
   엔드포인트가 새로운 주소로 마이그레이션되는 프로세스입니다.

   QUIC의 설계는 안정적인 주소를 유지하는 엔드포인트에 의존합니다.
   핸드셰이크의 지속 시간. 엔드포인트는 시작해서는 안 됩니다.
   핸드셰이크가 확인되기 전의 연결 마이그레이션은 다음과 같이 정의됩니다.
   [QUIC-TLS]의 섹션 4.1.2.

   피어가 disable_active_migration 전송 매개변수를 보낸 경우
   엔드포인트는 또한 패킷(프로빙 패킷 포함)을 보내서는 안 됩니다.
   섹션 9.1) 다른 로컬 주소에서 피어 주소로
   엔드포인트가 조치를 취하지 않는 한 핸드셰이크 중에 사용됩니다.
   피어의 preferred_address 전송 매개변수입니다. 피어가
   이 요구 사항을 위반하면 엔드포인트는 수신을 삭제해야 합니다.
   Stateless Reset을 생성하지 않고 해당 경로의 패킷을 계속 진행
   경로 검증을 통해 피어가 마이그레이션할 수 있도록 허용합니다.
   상태 비저장 재설정 또는 연결 종료를 통해 제3자가
   네트워크에서 스푸핑이나 기타 방법으로 연결을 닫는 경우
   관찰된 트래픽을 조작합니다.

   모든 피어 주소 변경이 의도적이거나 활성적인 것은 아닙니다.
   마이그레이션. 피어는 NAT 리바인딩을 경험할 수 있습니다.
   일반적으로 NAT인 중간 상자가 새로운 발신 주소를 할당하기 때문에 주소가 변경됩니다.
   포트 또는 흐름에 대한 새로운 발신 IP 주소. 엔드포인트는 반드시
   변경 사항이 감지되면 경로 검증(섹션 8.2)을 수행합니다.
   이전에 해당 주소의 유효성을 검사하지 않은 경우 피어의 주소입니다.

   엔드포인트에 패킷을 보낼 검증된 경로가 없는 경우
   연결 상태를 삭제할 수 있습니다. 연결이 가능한 엔드포인트
   마이그레이션은 새로운 경로가 사용 가능해질 때까지 기다릴 수 있습니다.
   연결 상태를 삭제합니다.

   이 문서는 새 클라이언트로의 연결 마이그레이션을 제한합니다.
   섹션 9.6에 설명된 경우를 제외하고 주소입니다. 클라이언트는
   모든 마이그레이션을 시작할 책임이 있습니다. 서버는 비
   클라이언트 주소에 대한 패킷을 프로빙합니다(섹션 9.1 참조)
   해당 주소에서 비프로빙 패킷을 확인합니다. 클라이언트가 수신하는 경우
   알 수 없는 서버 주소에서 패킷이 전송되면 클라이언트는 이를 삭제해야 합니다.
   패킷.

9.1. 새로운 경로 탐색

엔드포인트는 새 로컬 주소에서 피어 도달 가능성을 조사할 수 있습니다.
연결을 마이그레이션하기 전에 경로 검증(섹션 8.2) 사용
새 로컬 주소로. 경로 유효성 검사 실패는 단순히 다음을 의미합니다.
이 연결에는 새 경로를 사용할 수 없습니다. 실패
경로 검증은 연결이 종료되지 않도록 합니다.
유효한 대체 경로가 없습니다.

PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID 및 PADDING 프레임
는 "탐색 프레임"이고, 다른 모든 프레임은 "비탐색 프레임"입니다.
프로빙 프레임만 포함된 패킷은 "프로빙 패킷"이며
다른 프레임을 포함하는 패킷은 "비탐침 패킷"입니다.

9.2. 연결 마이그레이션 시작

엔드포인트는 다음을 통해 연결을 새 로컬 주소로 마이그레이션할 수 있습니다.
해당 주소에서 탐색하지 않는 프레임이 포함된 패킷을 보냅니다.

각 엔드포인트는 연결 중에 피어의 주소를 검증합니다.
따라서 마이그레이션하는 엔드포인트는 피어로 전송할 수 있습니다.
피어가 피어의 현재 수준에서 수신할 의향이 있다는 것을 알고 있음
주소. 따라서 엔드포인트는 새 로컬 주소로 마이그레이션할 수 있습니다.
먼저 피어의 주소를 검증하지 않고.

새로운 경로에 대한 도달성을 확립하기 위해 엔드포인트는 경로를 시작합니다.
새 경로에 대한 유효성 검사(섹션 8.2). 엔드포인트는 경로를 연기할 수 있습니다.
피어가 다음 비프로빙 프레임을 해당 피어에게 보낼 때까지 검증이 진행됩니다.
새로운 주소.

마이그레이션 시 새 경로가 엔드포인트의 현재 경로를 지원하지 않을 수 있습니다.
전송 속도. 따라서 엔드포인트는 혼잡을 재설정합니다.
섹션 9.4에 설명된 대로 컨트롤러와 RTT 추정.

새로운 경로에는 동일한 ECN 기능이 없을 수 있습니다. 따라서
엔드포인트는 섹션 13.4에 설명된 대로 ECN 기능을 검증합니다.

9.3. 연결 마이그레이션에 대한 응답

비프로빙을 포함하는 새로운 피어 주소에서 패킷 수신
프레임은 피어가 해당 주소로 마이그레이션되었음을 나타냅니다.

수신자가 마이그레이션을 허용하는 경우 후속을 보내야 합니다.
새로운 피어 주소로 패킷을 보내고 경로 검증을 시작해야 합니다.
(섹션 8.2) 피어가 주소를 소유하고 있는지 확인하려면
유효성 검사가 아직 진행 중이 아닙니다. 수신자에게 사용되지 않은
피어의 연결 ID가 없으면 아무것도 보낼 수 없습니다.
피어가 새로운 경로를 제공할 때까지 새로운 경로를 사용합니다. 섹션 9.5를 참조하세요.

엔드포인트는 패킷을 보내는 주소만 변경합니다.
가장 높은 번호의 비프로빙 패킷에 대한 응답입니다. 이를 통해
엔드포인트가 이전 피어 주소로 패킷을 보내지 않는다는 점
재정렬된 패킷을 수신하는 경우.

엔드포인트는 검증되지 않은 피어 주소로 데이터를 보낼 수 있지만 반드시 다음을 수행해야 합니다.
섹션 9.3.1에 설명된 잠재적 공격으로부터 보호합니다.
9.3.2. 엔드포인트는 피어 주소의 유효성 검사를 건너뛸 수 있습니다.
주소가 최근에 확인되었습니다. 특히, 엔드포인트가
어떤 형태의 감지 후 이전에 검증된 경로로 돌아갑니다.
잘못된 마이그레이션, 주소 검증 건너뛰기 및 손실 복구
감지 및 혼잡 상태는 성능에 미치는 영향을 줄일 수 있습니다.
공격.

비탐침 패킷을 보내는 주소를 변경한 후
엔드포인트는 다른 주소에 대한 모든 경로 검증을 포기할 수 있습니다.

새로운 피어 주소에서 패킷을 수신하는 것은 다음의 결과일 수 있습니다.
피어에서 NAT 리바인딩.

새로운 클라이언트 주소를 확인한 후 서버는 새 주소를 보내야 합니다.
클라이언트에게 주소 검증 토큰(섹션 8)을 제공합니다.

9.3.1. 피어 주소 스푸핑

피어가 소스 주소를 스푸핑하여 다음을 발생시킬 수 있습니다.
원하지 않는 호스트에 과도한 양의 데이터를 전송하는 엔드포인트.
엔드포인트는 스푸핑 피어보다 훨씬 더 많은 데이터를 전송합니다.
연결 마이그레이션은 데이터 볼륨을 증폭하는 데 사용될 수 있습니다.
공격자는 피해자를 향해 공격을 가할 수 있습니다.

섹션 9.3에 설명된 대로 엔드포인트는 다음을 검증하는 데 필요합니다.
피어의 새로운 주소를 확인하여 피어가 새로운 주소를 소유하고 있음을 확인합니다.
주소. 피어의 주소가 유효하다고 간주될 때까지 엔드포인트는 다음을 제한합니다.
해당 주소로 보내는 데이터 양; 섹션 8 참조.
이 제한이 없으면 엔드포인트가 거부에 사용될 위험이 있습니다.
아무것도 모르는 피해자에 대한 서비스 공격.

위에서 설명한 대로 엔드포인트가 피어 주소의 유효성 검사를 건너뛰는 경우
전송 속도를 제한할 필요가 없습니다.

9.3.2. 경로상 주소 스푸핑

경로상의 공격자 는 잘못된 연결 마이그레이션을 일으킬 수 있습니다.
위조된 주소로 패킷을 복사하여 전달합니다.
원래 패킷보다 먼저 도착합니다. 스푸핑된 패킷
주소는 마이그레이션 연결에서 온 것으로 표시되며
원본 패킷은 중복으로 간주되어 삭제됩니다.
잘못된 마이그레이션으로 인해 소스 주소 검증이 실패합니다.
소스 주소의 엔터티에 필요한 것이 없기 때문입니다.
PATH_CHALLENGE 프레임을 읽거나 응답하기 위한 암호화 키
원하더라도 전송되지 않습니다.

이러한 잘못된 연결로 인해 연결이 실패하지 않도록 보호하려면
마이그레이션 시 엔드포인트는 마지막으로 검증된 피어를 사용하도록 되돌려야 합니다.
새 피어 주소의 유효성 검사가 실패하면 주소가 변경됩니다. 또한,
합법적인 패킷 번호가 더 높은 패킷 수신
피어 주소는 또 다른 연결 마이그레이션을 트리거합니다.
가짜 마이그레이션 주소의 유효성 검사를 수행합니다.
버려졌으므로 공격자가 시작한 마이그레이션이 포함됩니다.
단일 패킷을 주입합니다.

엔드포인트에 마지막으로 검증된 피어 주소에 대한 상태가 없는 경우
모든 연결을 삭제하여 자동으로 연결을 닫아야 합니다.
상태. 이로 인해 연결에서 처리되는 새 패킷이 생성됩니다.
일반적으로. 예를 들어, 엔드포인트는 Stateless Reset을 보낼 수 있습니다.
추가로 들어오는 패킷에 대한 응답입니다.

9.3.3. 오프패스 패킷 전달

패킷을 관찰할 수 있는 경로 밖 공격자는 다음 사본을 전달할 수 있습니다.
엔드포인트에 대한 정품 패킷. 복사된 패킷이 이전에 도착한 경우
진짜 패킷이라면 NAT 리바인딩으로 보일 것입니다. 진짜 패킷이라면
패킷은 중복으로 삭제됩니다. 공격자가
패킷 전달을 계속하면 마이그레이션이 발생할 수 있습니다.
공격자를 통한 경로입니다. 이렇게 하면 공격자가 경로에 있게 되어
이후의 모든 패킷을 관찰하거나 삭제할 수 있는 기능.

이 공격 스타일은 공격자가 다음 경로를 사용하는 데 의존합니다.
직접 경로와 거의 동일한 특성
엔드포인트. 패킷이 비교적 적으면 공격이 더 안정적입니다.
패킷 손실이 공격 시도와 동시에 전송되거나 발생하는 경우.

원래 경로에서 수신된 비프로빙 패킷은 다음을 증가시킵니다.
수신된 패킷의 최대 개수로 인해 엔드포인트가 다시 이동합니다.
해당 경로로. 이 경로에서 패킷을 유도하면
공격이 실패할 가능성이 높습니다. 따라서 완화 조치는 다음과 같습니다.
이 공격은 패킷 교환을 유발하는 데 의존합니다.

명백한 마이그레이션에 대한 응답으로 엔드포인트는 다음을 검증해야 합니다.
PATH_CHALLENGE 프레임을 사용하여 이전에 활성화된 경로를 확인합니다. 이는
해당 경로에서 새 패킷을 전송합니다. 경로가 더 이상
실행 가능한 경우 검증 시도는 시간 초과되어 실패합니다. 경로가
실행 가능하지만 더 이상 원하지 않는 경우 검증은 성공하지만
경로에 패킷이 전송되는 것을 확인합니다.

활성 경로에서 PATH_CHALLENGE를 수신하는 엔드포인트는 다음을 수행해야 합니다.
응답으로 비프로빙 패킷을 보냅니다. 비프로빙 패킷이
공격자가 만든 사본보다 먼저 도착하면 다음과 같은 결과가 발생합니다.
연결이 원래 경로로 다시 마이그레이션됩니다. 이후의 모든
다른 경로로 마이그레이션하면 전체 프로세스가 다시 시작됩니다.

이 방어는 불완전하지만 심각한 것으로 간주되지 않습니다.
문제. 공격을 통한 경로가 안정적으로 더 빠른 경우
원래 경로를 사용하려고 여러 번 시도했음에도 불구하고 원래 경로가
공격과 개선을 구별하는 것은 불가능합니다.
라우팅에서.

엔드포인트는 또한 휴리스틱을 사용하여 이를 감지하는 것을 개선할 수 있습니다.
공격 스타일. 예를 들어, NAT 리바인딩은 다음과 같은 경우 불가능합니다.
패킷은 최근에 이전 경로에서 수신되었습니다. 마찬가지로 다시 바인딩합니다.
IPv6 경로에서는 드물게 발생합니다. 엔드포인트는 중복된 항목을 찾을 수도 있습니다.
패킷. 반대로 연결 ID가 변경되면 더 가능성이 높습니다.
공격이라기보다는 의도적인 이주를 나타냅니다.

9.4. 손실 감지 및 혼잡 제어

새로운 경로에서 사용 가능한 용량은 이전 경로와 동일하지 않을 수 있습니다.
이전 경로. 이전 경로로 전송된 패킷은 다음에 기여해서는 안 됩니다.
새로운 경로에 대한 혼잡 제어 또는 RTT 추정.

피어가 새 주소에 대한 소유권을 확인하면 엔드포인트는 다음을 수행해야 합니다.
혼잡 제어기와 왕복 시간을 즉시 재설정합니다.
초기값에 대한 새로운 경로에 대한 추정치(부록 A.3 및
[QUIC-RECOVERY]의 B.3) 피어 주소의 유일한 변경 사항이 아닌 경우
포트 번호입니다. 포트 전용 변경은 일반적으로
NAT 리바인딩 또는 기타 중간 상자 활동의 결과로 엔드포인트가 발생할 수 있습니다.
대신 혼잡 제어 상태와 왕복 추정치를 유지합니다.
이러한 경우에는 초기값으로 되돌리는 대신.
이전 경로에서 유지된 혼잡 제어 상태가 사용되는 경우
상당히 다른 특성을 가진 새로운 경로를 보내는 사람은
혼잡 제어기와 RTT가 발생할 때까지 너무 공격적으로 전송합니다.
추정기가 적응되었습니다. 일반적으로 구현은 다음과 같이 권장됩니다.
새로운 경로에서 이전 값을 사용할 때는 주의하세요.

엔드포인트가 있는 경우 수신기에서 명백한 재정렬이 발생할 수 있습니다.
마이그레이션 중에 여러 주소에서 데이터와 프로브를 보냅니다.
기간 동안 두 결과 경로는 서로 다른 왕복 경로를 가질 수 있습니다.
시간. 여러 경로에 있는 패킷의 수신자는 여전히 ACK를 보냅니다.
수신된 모든 패킷을 포함하는 프레임입니다.

연결 마이그레이션 중에 여러 경로가 사용될 수 있지만
단일 혼잡 제어 컨텍스트 및 단일 손실 복구 컨텍스트
([QUIC-RECOVERY]에 설명된 대로) 적절할 수 있습니다. 예를 들어,
엔드포인트가 새로운 혼잡 제어 컨텍스트로 전환하는 것을 지연할 수 있습니다.
이전 경로가 더 이상 필요하지 않다는 것이 확인될 때까지(예:
(9.3.3절에 설명된 사례).

발신자는 프로브 패킷에 대한 예외를 만들어 손실을 방지할 수 있습니다.
감지는 독립적이며 혼잡을 부당하게 유발하지 않습니다.
컨트롤러가 전송 속도를 줄이도록 합니다. 엔드포인트는 다음을 설정할 수 있습니다.
PATH_CHALLENGE가 전송되면 별도의 타이머가 취소됩니다.
해당 PATH_RESPONSE가 수신됩니다. 타이머가 실행되면
PATH_RESPONSE가 수신되기 전에 엔드포인트는 새 메시지를 보낼 수 있습니다.
PATH_CHALLENGE를 사용하여 타이머를 더 긴 시간 동안 다시 시작합니다.
이 타이머는 섹션 6.2.1에 설명된 대로 설정되어야 합니다.
[빠른 회복] 그리고 더 공격적이어서는 안 됩니다.

9.5. 연결 마이그레이션의 개인 정보 보호 영향

여러 네트워크 경로에서 안정적인 연결 ID를 사용하면
수동적 관찰자는 해당 경로 간의 활동을 상관시킵니다.
네트워크 간에 이동하는 엔드포인트는 다음을 원하지 않을 수 있습니다.
동료가 아닌 다른 엔터티와 관련된 활동이므로 매우 다릅니다.
연결 ID는 다른 로컬 주소에서 보낼 때 사용됩니다.
섹션 5.1에서 논의한 대로. 이것이 효과적이려면 엔드포인트가 필요합니다.
제공하는 연결 ID가 연결될 수 없도록 해야 합니다.
다른 모든 개체.

언제든지 엔드포인트는 대상 연결 ID를 변경할 수 있습니다.
다른 경로에서 사용되지 않은 값으로 전송합니다.

엔드포인트는 더 많은 곳에서 전송할 때 연결 ID를 재사용해서는 안 됩니다.
두 개 이상의 로컬 주소(예: 연결을 시작할 때)
섹션 9.2에 설명된 대로 마이그레이션하거나 새 네트워크를 탐색할 때
9.1절에 설명된 경로입니다.

마찬가지로 엔드포인트는 연결할 때 연결 ID를 재사용해서는 안 됩니다.
두 개 이상의 목적지 주소. 외부 네트워크 변경으로 인해
피어의 제어를 통해 엔드포인트는 새로운 엔드포인트로부터 패킷을 수신할 수 있습니다.
동일한 대상 연결 ID 필드 값을 갖는 소스 주소
이 경우 현재 연결 ID를 계속 사용할 수 있습니다.
동일한 로컬에서 보내는 동안 새로운 원격 주소
주소.

연결 ID 재사용에 관한 이러한 요구 사항은 다음에만 적용됩니다.
패킷 전송은 경로가 의도치 않게 변경되어 변경 사항이 없는 경우
연결 ID에서 가능합니다. 예를 들어, 일정 기간 후
네트워크 비활성, NAT 재바인딩으로 인해 패킷이 전송될 수 있습니다.
클라이언트가 전송을 재개할 때 새 경로가 생성됩니다. 엔드포인트가 응답합니다.
섹션 9.3에 설명된 것과 같은 이벤트.

양방향으로 전송되는 패킷에 대해 다른 연결 ID 사용
새로운 네트워크 경로가 생길 때마다 연결 ID 사용이 사라집니다.
다른 네트워크에서 동일한 연결의 패킷 연결
경로. 헤더 보호는 패킷 번호를 사용할 수 없도록 보장합니다.
활동을 상관시키기 위해. 이것은 다른 속성을 방해하지 않습니다.
타이밍 및 크기와 같은 패킷이 상관관계를 파악하는 데 사용되는 것을 방지합니다.
활동.

엔드포인트는 피어와 마이그레이션을 시작해서는 안 됩니다.
새로운 트래픽 때문에 길이가 0인 연결 ID를 요청했습니다.
경로는 이전 경로의 트래픽과 쉽게 연결될 수 있습니다.
서버는 패킷을 길이가 0인 연결 ID와 연결할 수 있습니다.
오른쪽 연결에 대해 서버가 다른 연결을 사용하고 있음을 의미합니다.
패킷을 다중화 해제하기 위한 정보입니다. 예를 들어, 서버는
모든 클라이언트에게 고유한 주소 제공(예: HTTP 사용)
대체 서비스[ALTSVC]. 올바른 정보를 제공할 수 있는 정보
여러 네트워크 경로를 통한 패킷 라우팅도 허용됩니다.
피어가 아닌 다른 엔터티가 연결할 경로에서의 활동.

클라이언트는 새로운 것으로 전환하여 연결성을 줄이고 싶어할 수 있습니다.
연결 ID, 소스 UDP 포트 또는 IP 주소(RFC8981 참조)
일정 시간 동안 활동이 없는 경우 트래픽을 전송합니다. 주소 변경
동시에 패킷을 보내는 경우 서버가 발생할 수 있습니다.
연결 마이그레이션을 감지합니다. 이를 통해 메커니즘이
마이그레이션을 지원하는 클라이언트에 대해서도 마이그레이션을 지원합니다.
NAT 리바인딩이나 실제 마이그레이션이 발생합니다. 주소 변경
피어가 혼잡 제어 상태를 재설정하도록 할 수 있습니다(참조
섹션 9.4)에 따르면 주소는 드물게만 변경되어야 합니다.

사용 가능한 연결 ID를 모두 소진한 엔드포인트는 새 연결을 프로브할 수 없습니다.
경로 또는 마이그레이션을 시작할 수 없으며 프로브 또는 시도에 응답할 수도 없습니다.
피어가 마이그레이션할 수 있도록 합니다. 마이그레이션이 가능한지 확인하고
다른 경로로 전송된 패킷은 상관관계를 맺을 수 없습니다.
피어가 마이그레이션되기 전에 새로운 연결 ID를 제공해야 합니다.
섹션 5.1.1. 피어가 사용 가능한 연결을 모두 소진했을 수 있는 경우
ID, 마이그레이션 엔드포인트에는 NEW_CONNECTION_ID 프레임이 포함될 수 있습니다.
모든 패킷은 새로운 네트워크 경로로 전송됩니다.

9.6. 서버의 기본 주소

QUIC를 사용하면 서버가 하나의 IP 주소에서 연결을 수락할 수 있습니다.
이러한 연결을 더 선호하는 주소로 전송하려고 시도합니다.
악수 직후. 이것은 특히 다음과 같은 경우에 유용합니다.
클라이언트는 처음에 여러 서버에서 공유하는 주소에 연결합니다.
하지만 연결을 보장하기 위해 유니캐스트 주소를 사용하는 것을 선호합니다.
안정성. 이 섹션에서는 마이그레이션 프로토콜을 설명합니다.
선호하는 서버 주소에 연결합니다.

연결 중에 새 서버 주소로 연결을 마이그레이션하는 것은 불가능합니다.
이 문서에 명시된 QUIC 버전에서 지원됩니다.
클라이언트가 새 서버 주소로부터 패킷을 수신할 때
해당 주소로 마이그레이션을 시작하지 않은 경우 클라이언트는 다음을 삭제해야 합니다.
이 패킷들.

9.6.1. 선호하는 주소 전달

서버는 다음을 포함하여 선호하는 주소를 전달합니다.
TLS 핸드셰이크의 preferred_address 전송 매개변수.

서버는 각 주소 패밀리의 기본 주소를 전달할 수 있습니다.
(IPv4 및 IPv6) 클라이언트가 자신에게 가장 적합한 것을 선택할 수 있도록 합니다.
네트워크 연결.

핸드셰이크가 확인되면 클라이언트는 다음 중 하나를 선택해야 합니다.
서버에서 제공하는 두 개의 주소로 경로 검증을 시작합니다.
(8.2절 참조). 클라이언트는 이전에 생성된 패킷을 사용하여 패킷을 구성합니다.
사용하지 않는 활성 연결 ID는 preferred_address에서 가져옵니다.
전송 매개변수 또는 NEW_CONNECTION_ID 프레임.

경로 검증이 성공하면 클라이언트는 전송을 시작해야 합니다.
새로운 연결을 사용하여 새 서버 주소로 전송되는 모든 향후 패킷
ID를 확인하고 이전 서버 주소 사용을 중단합니다. 경로 검증이 필요한 경우
실패하면 클라이언트는 모든 향후 패킷을 계속해서 보내야 합니다.
서버의 원래 IP 주소.

9.6.2. 기본 주소로 마이그레이션

선호하는 주소로 마이그레이션하는 클라이언트는 다음을 확인해야 합니다.
마이그레이션하기 전에 선택한 주소입니다. 섹션 21.5.3을 참조하세요.

서버는 선호하는 IP 주소로 주소 지정된 패킷을 수신할 수 있습니다.
연결을 수락한 후 언제든지. 이 패킷에 다음이 포함된 경우
PATH_CHALLENGE 프레임을 사용하면 서버는 다음을 포함하는 패킷을 보냅니다.
섹션 8.2에 따라 PATH_RESPONSE 프레임을 전송해야 합니다. 서버는 비-
원래 주소에서 패킷을 탐색하여 비주소를 수신할 때까지
클라이언트의 선호하는 주소에서 패킷을 탐색하고
서버가 새로운 경로를 검증했습니다.

서버는 클라이언트를 향한 경로를 탐색해야 합니다.
선호하는 주소입니다. 이는 잘못된 마이그레이션을 방지하는 데 도움이 됩니다.
공격자에 의해 시작됨.

서버가 경로 검증을 완료하고 다음을 수신하면
선호하는 새로운 가장 큰 패킷 번호가 있는 비탐사 패킷
주소, 서버는 클라이언트에 비탐침 패킷을 보내기 시작합니다.
선호하는 IP 주소에서만 해당됩니다. 서버는 다음을 삭제해야 합니다.
이전 IP에서 수신된 이 연결에 대한 최신 패킷
주소. 서버는 지연된 패킷을 계속 처리할 수 있습니다.
이전 IP 주소에서 수신되었습니다.

서버가 선호하는 주소에 제공하는 주소
전송 매개변수는 해당 연결에만 유효합니다.
제공됩니다. 클라이언트는 다른 연결에 이것을 사용해서는 안 됩니다.
현재 연결에서 재개된 연결을 포함합니다.

9.6.3. 클라이언트 마이그레이션과 기본 주소의 상호 작용

클라이언트는 연결 마이그레이션을 수행해야 할 수도 있습니다.
서버의 기본 주소로 마이그레이션되었습니다. 이 경우 클라이언트는
원본 및 기본 경로 모두에 대한 경로 검증을 수행해야 합니다.
클라이언트의 새 주소에서 서버 주소를 동시에 가져옵니다.

서버의 기본 주소에 대한 경로 검증이 성공하면
클라이언트는 원래 주소의 유효성 검사를 포기하고 이전해야 합니다.
서버의 기본 주소를 사용합니다. 경로 유효성 검사가 수행되는 경우
서버의 기본 주소가 실패하지만 서버의 유효성 검사가 실패합니다.
원래 주소가 성공하면 클라이언트는 새 주소로 마이그레이션할 수 있습니다.
그리고 서버의 원래 주소로 계속 전송합니다.

서버의 기본 주소에서 수신된 패킷에 다음이 있는 경우
클라이언트에서 관찰한 것과 다른 소스 주소
핸드셰이크를 통해 서버는 잠재적인 공격으로부터 보호해야 합니다.
섹션 9.3.1 및 9.3.2에 설명되어 있습니다. 의도적인 것 외에도
동시 마이그레이션은 클라이언트의 다음과 같은 이유로 발생할 수도 있습니다.
액세스 네트워크는 서버에 대해 다른 NAT 바인딩을 사용했습니다.
선호하는 주소.

서버는 클라이언트의 새 주소에 대한 경로 검증을 시작해야 합니다.
다른 주소에서 프로브 패킷을 수신할 때; 참조
섹션 8.

새 주소로 이전하는 클라이언트는 선호하는 것을 사용해야 합니다.
서버에 대해 동일한 주소 패밀리의 주소입니다.

preferred_address 전송에서 제공된 연결 ID
매개변수는 제공된 주소에만 국한되지 않습니다.
연결 ID는 클라이언트가 연결되어 있는지 확인하기 위해 제공됩니다.
마이그레이션에 사용할 수 있는 ID가 있지만 클라이언트는 이 연결 ID를 사용할 수 있습니다.
어떤 길에서든.

9.7. IPv6 흐름 레이블 및 마이그레이션 사용

IPv6를 사용하여 데이터를 전송하는 엔드포인트는 IPv6 흐름 레이블을 적용해야 합니다.
[RFC6437]을 준수하되 로컬 API가 허용하지 않는 경우
IPv6 흐름 레이블 설정.

흐름 레이블 생성은 다음과 같은 가능성을 최소화하도록 설계되어야 합니다.
이전에 사용된 흐름 레이블과의 연결성, 안정적인 흐름 레이블로서
여러 경로에서 활동을 연관시킬 수 있습니다. 섹션 9.5를 참조하세요.

[RFC6437]은 의사난수 함수를 사용하여 값을 도출하는 것을 제안합니다.
흐름 레이블을 생성합니다. 대상 연결 ID 필드 포함
흐름을 생성할 때 소스 및 대상 주소 외에
레이블은 변경 사항이 다른 변경 사항과 동기화되도록 보장합니다.
관찰 가능한 식별자. 다음을 결합하는 암호화 해시 함수
로컬 비밀을 포함하는 이러한 입력은 이것이 가능한 한 가지 방법입니다.
구현됨.

10. 연결 종료

설정된 QUIC 연결은 다음 세 가지 중 하나로 종료될 수 있습니다.
방법:

* 유휴 시간 초과(섹션 10.1)

* 즉시 종료(섹션 10.2)

* 상태 비저장 재설정(섹션 10.3)

엔드포인트는 연결 상태가 없는 경우 연결 상태를 삭제할 수 있습니다.
패킷을 보낼 수 있는 검증된 경로입니다. 섹션 8.2를 참조하세요.

10.1. 유휴 시간 초과

두 엔드포인트 중 하나에서 max_idle_timeout이 지정된 경우
전송 매개변수(섹션 18.2)의 경우 연결이 자동으로 수행됩니다.
닫히고 더 이상 유휴 상태를 유지하면 상태가 삭제됩니다.
둘 다에서 광고한 max_idle_timeout 값의 최소값보다
종료점.

각 엔드포인트는 max_idle_timeout을 광고하지만 효과적인 값은
종료 지점에서는 광고된 두 가지 중 최소값으로 계산됩니다.
값(또는 하나의 엔드포인트만 광고하는 경우 광고된 유일한 값)
0이 아닌 값). max_idle_timeout을 발표함으로써 엔드포인트
즉시 종료를 개시하기로 약속합니다(섹션 10.2)
유효 값 이전에 연결을 포기합니다.

패킷이 피어로부터 전송되면 엔드포인트는 유휴 타이머를 다시 시작합니다.
성공적으로 수신 및 처리되었습니다. 엔드포인트도 다시 시작합니다.
다른 ACK가 없는 경우 ACK 유도 패킷을 보낼 때 유휴 타이머
마지막 수신 및 처리 이후에 유도 패킷이 전송되었습니다.
패킷. 패킷을 보낼 때 이 타이머를 다시 시작하면
새로운 활동이 시작된 후에는 연결이 닫히지 않습니다.

유휴 시간 초과 기간이 너무 짧아지는 것을 방지하려면 엔드포인트가 반드시 있어야 합니다.
유휴 시간 초과 기간을 최소 3배 이상으로 늘리십시오.
현재 프로브 시간 초과(PTO). 이를 통해 여러 PTO를 사용할 수 있습니다.
만료되므로 여러 개의 프로브가 전송되어 손실됩니다.
유휴 시간 초과.

10.1.1. 활성 테스트

효과적인 타임아웃 위험에 가깝게 패킷을 보내는 엔드포인트
유휴 시간 초과 기간 이후로 피어에서 삭제되도록 함
패킷이 도착하기 전에 피어에서 만료되었을 수 있습니다.

엔드포인트는 PING 또는 다른 ACK 유도 프레임을 보내 테스트할 수 있습니다.
피어가 곧 시간 초과될 수 있는 경우 활성 상태를 위한 연결, 예:
PTO 내에서; [QUIC-RECOVERY]의 섹션 6.2를 참조하세요. 이는 특히
사용 가능한 애플리케이션 데이터를 안전하게 다시 시도할 수 없는 경우에 유용합니다.
어떤 데이터를 다시 시도해도 안전한지는 해당 애플리케이션에서 판단합니다.

10.1.2. 유휴 시간 초과 연기

엔드포인트는 유휴 상태를 방지하기 위해 ACK 유도 패킷을 보내야 할 수도 있습니다.
응답 데이터를 기대하고 있지만 데이터가 없거나 없는 경우 시간 초과가 발생합니다.
애플리케이션 데이터를 전송할 수 없습니다.

QUIC 구현은 애플리케이션에 옵션을 제공할 수 있습니다.
유휴 시간 초과를 연기합니다. 이 기능은 다음과 같은 경우에 사용할 수 있습니다.
응용 프로그램은 연관된 상태를 잃지 않으려고 합니다.
연결이 열려 있지만 응용 프로그램을 교환할 것으로 예상하지 않습니다.
일정 시간 동안 데이터를 저장합니다. 이 옵션을 사용하면 엔드포인트에서 PING을 보낼 수 있습니다.
프레임(섹션 19.2)을 주기적으로 실행하면 피어가
유휴 시간 초과 기간을 다시 시작합니다. PING이 포함된 패킷을 전송합니다.
프레임은 이것이 다음과 같은 경우에도 이 엔드포인트에 대한 유휴 시간 초과를 다시 시작합니다.
패킷을 수신한 후 전송된 첫 번째 ack-eliciting 패킷입니다.
PING 프레임은 피어가 확인으로 응답하도록 합니다.
또한 엔드포인트에 대한 유휴 시간 초과를 다시 시작합니다.

QUIC를 사용하는 애플리케이션 프로토콜은 다음에 대한 지침을 제공해야 합니다.
유휴 시간 초과를 연기하는 것이 적절합니다. 불필요한 전송
PING 프레임은 성능에 부정적인 영향을 미칠 수 있습니다.

패킷이 전송되거나 수신되지 않으면 연결 시간이 초과됩니다.
max_idle_timeout을 사용하여 협상된 시간보다 긴 기간
전송 매개변수; 섹션 10을 참조하세요. 그러나 중간 상자에 상태를 지정합니다.
그보다 더 일찍 시간이 초과될 수도 있습니다. [RFC4787]의 REQ-5는
2분의 시간 초과 간격을 권장합니다. 경험에 따르면 전송
대부분의 문제를 방지하려면 30초마다 패킷을 전송해야 합니다.
UDP 흐름[GATEWAY]에 대한 상태 손실을 방지하는 중간 상자.

10.2. 즉시 종결

엔드포인트는 CONNECTION_CLOSE 프레임(섹션 19.19)을 전송합니다.
연결을 즉시 종료합니다. CONNECTION_CLOSE 프레임
모든 스트림이 즉시 닫히게 됩니다. 열린 스트림은 다음과 같습니다.
암묵적으로 재설정된 것으로 가정합니다.

CONNECTION_CLOSE 프레임을 보낸 후 엔드포인트는 즉시
마감 상태로 들어갑니다. 섹션 10.2.1을 참조하세요. 수신 후
CONNECTION_CLOSE 프레임, 엔드포인트가 드레이닝 상태로 전환됩니다. 참조
섹션 10.2.2.

규정 위반 시 즉시 폐쇄됩니다.

애플리케이션 프로토콜이 완료된 후 즉시 종료를 사용할 수 있습니다.
연결을 끊도록 설정했습니다. 이는 응용 프로그램 종료 후일 수 있습니다.
프로토콜은 정상적인 종료를 협상합니다. 애플리케이션 프로토콜
두 애플리케이션 엔드포인트에 필요한 메시지를 교환할 수 있습니다.
연결이 닫힐 수 있다는 데 동의한 후
애플리케이션은 QUIC에 연결을 닫으라고 요청합니다. QUIC가
결과적으로 연결을 닫고 CONNECTION_CLOSE 프레임이 있습니다.
응용 프로그램에서 제공하는 오류 코드는 종료를 알리는 데 사용됩니다.
또래.

닫힘 및 배수 연결 상태는 다음을 보장하기 위해 존재합니다.
연결이 깨끗하게 닫히고 지연되거나 재정렬된 패킷이
적절하게 폐기됩니다. 이러한 상태는 최소 3년 동안 지속되어야 합니다.
[QUIC-RECOVERY]에 정의된 현재 PTO 간격의 시간입니다.

종료 전 연결 상태 삭제 또는
배수 상태로 인해 엔드포인트에서 Stateless가 생성될 수 있습니다.
늦게 도착한 패킷을 받으면 불필요하게 재설정됩니다.
늦은 시점을 보장하기 위한 대체 수단이 있는 엔드포인트
도착하는 패킷은 다음과 같은 응답을 유도하지 않습니다.
UDP 소켓을 닫을 수 있고 이러한 상태를 더 일찍 종료할 수 있습니다.
더 빠른 리소스 복구를 위해. 열린 소켓을 유지하는 서버
새로운 연결을 수락하는 것은 닫기 또는 배수를 종료해서는 안 됩니다.
일찍 진술하세요.

닫힘 또는 배수 상태가 끝나면 엔드포인트는 삭제해야 합니다.
모든 연결 상태. 엔드포인트는 Stateless Reset을 보낼 수 있습니다.
이에 속하는 추가 수신 패킷에 대한 응답
연결.

10.2.1. 연결 상태 닫기

엔드포인트는 즉각적인 시작 후 닫힘 상태로 전환됩니다.
닫다.

종료 상태에서 엔드포인트는 다음 정보만 유지합니다.
CONNECTION_CLOSE 프레임을 포함하는 패킷을 생성하고 식별합니다.
패킷이 연결에 속하는 것으로 간주합니다. 종료 시 엔드포인트
상태는 응답으로 CONNECTION_CLOSE 프레임을 포함하는 패킷을 보냅니다.
연결에 기인하는 모든 수신 패킷에 적용됩니다.

엔드포인트는 패킷을 생성하는 속도를 제한해야 합니다.
닫는 상태. 예를 들어, 엔드포인트는 다음을 기다릴 수 있습니다.
수신된 패킷의 수 또는 시간이 점차 증가함
수신된 패킷에 응답하기 전에.

엔드포인트의 선택된 연결 ID와 QUIC 버전은 다음과 같습니다.
닫히는 연결에 대한 패킷을 식별하기에 충분한 정보
엔드포인트는 다른 모든 연결 상태를 삭제할 수 있습니다. 엔드포인트
수신된 프레임을 처리하는 데 닫는 것이 필요하지 않습니다.
엔드포인트는 수신 패킷에 대한 패킷 보호 키를 보관할 수 있습니다.
CONNECTION_CLOSE 프레임을 읽고 처리할 수 있도록 허용합니다.

종료 시 엔드포인트는 패킷 보호 키를 삭제할 수 있습니다.
상태를 확인하고 CONNECTION_CLOSE 프레임을 포함하는 패킷을 보냅니다.
수신된 모든 UDP 데이터그램에 대한 응답입니다. 그러나 엔드포인트
패킷 보호 키를 삭제하면 식별 및 삭제가 불가능합니다.
잘못된 패킷입니다. 증폭 공격에 사용되는 것을 방지하려면
이러한 엔드포인트는 전송하는 패킷의 누적 크기를 제한해야 합니다.
수신된 패킷의 누적 크기의 3배
연결에 기인합니다. 엔드포인트의 상태를 최소화하려면
닫는 연결을 유지하기 위해 엔드포인트는 정확히 동일한 것을 보낼 수 있습니다.
수신된 패킷에 대한 응답으로 패킷을 보냅니다.

      | 참고: 종료 패킷의 재전송을 허용하는 것은
      | 새로운 패킷 번호를 사용해야 한다는 요구 사항에 대한 예외
      | 각 패킷에 대해; 섹션 12.3 참조. 새 패킷 번호 전송
      | 주로 손실 회복 및 혼잡에 유리합니다.
      | 폐쇄형에 관련성이 없을 것으로 예상되는 제어
      | 연결. 최종 패킷을 다시 전송하는 데는 더 적은 시간이 필요합니다.
      | 상태.

닫힘 상태에서 엔드포인트는 다음에서 패킷을 수신할 수 있습니다.
새로운 소스 주소는 연결 마이그레이션을 나타낼 수 있습니다. 참조
섹션 9. 닫힘 상태의 엔드포인트는 다음을 삭제해야 합니다.
검증되지 않은 주소에서 수신된 패킷 또는 누적 제한
검증되지 않은 주소로 보내는 패킷의 크기는 최대 3배까지 가능합니다.
해당 주소에서 수신하는 패킷의 크기입니다.

종료 시점에는 종료 시점에 키 업데이트를 처리할 것으로 예상되지 않습니다.
([QUIC-TLS]의 섹션 6). 주요 업데이트로 인해 엔드포인트가 차단될 수 있습니다.
닫힘 상태에서 배수 상태로 이동하는 것과 같이
엔드포인트는 이후에 수신된 패킷을 처리할 수 없습니다.
하지만 그 외에는 아무런 영향이 없습니다.

10.2.2. 배수 연결 상태

배수 상태는 엔드포인트가 다음을 수신하면 입력됩니다.
CONNECTION_CLOSE 프레임은 피어가 닫히고 있음을 나타냅니다.
배수 중입니다. 그 외에는 닫는 상태와 동일하지만
드레이닝 상태의 엔드포인트는 패킷을 보내서는 안 됩니다.
연결이 완료되면 패킷 보호 키가 필요하지 않습니다.
배수 상태.

CONNECTION_CLOSE 프레임을 수신하는 엔드포인트는 단일을 보낼 수 있습니다.
패킷이 CONNECTION_CLOSE 프레임을 포함하는 경우
배수 상태, 적절한 경우 NO_ERROR 코드 사용. 엔드포인트
추가 패킷을 보내면 안 됩니다. 그렇게 하면 지속적인
엔드포인트 중 하나가 종료될 때까지 CONNECTION_CLOSE 프레임 교환
마감 상태.

종료점은 닫는 상태에서 배수 상태로 전환될 수 있습니다.
피어가 CONNECTION_CLOSE 프레임을 수신합니다.
또한 닫거나 배수합니다. 이 경우 배수 상태는 다음과 같이 종료됩니다.
닫는 상태가 종료되었을 것입니다. 즉, 끝점
동일한 종료 시간을 사용하지만 이 패킷의 전송을 중단합니다.
연결.

10.2.3. 핸드셰이크 중 즉시 종료

CONNECTION_CLOSE 프레임을 보낼 때 목표는 다음을 보장하는 것입니다.
피어가 프레임을 처리합니다. 일반적으로 이는 프레임을 전송하는 것을 의미합니다.
패킷 보호 수준이 가장 높은 패킷으로 다음을 방지합니다.
패킷이 삭제됩니다. 핸드셰이크가 확인된 후(참조)
[QUIC-TLS]의 섹션 4.1.2)에 따르면 엔드포인트는 다음을 보내야 합니다.
1-RTT 패킷의 CONNECTION_CLOSE 프레임. 그러나 그 전에
핸드셰이크를 확인하면 더 진보된 패킷이 가능합니다.
보호 키는 피어에서 사용할 수 없으므로 다른
CONNECTION_CLOSE 프레임은 더 낮은 값을 사용하는 패킷으로 전송될 수 있습니다.
패킷 보호 수준. 더 구체적으로는 다음과 같습니다.

* 클라이언트는 서버에 핸드셰이크 키가 있는지 항상 알 수 있습니다.
  (섹션 17.2.2.1 참조) 그러나 서버가
  클라이언트에 Handshake 키가 있는지 확인합니다. 이러한 키 아래에서
  상황에 따라 서버는 CONNECTION_CLOSE 프레임을 보내야 합니다.
  핸드셰이크와 초기 패킷을 모두 사용하여 최소한 다음 중 하나를 보장합니다.
  클라이언트가 처리할 수 있습니다.

* 0-RTT 패킷에서 CONNECTION_CLOSE 프레임을 보내는 클라이언트
  서버가 0-RTT를 수락했는지 확신할 수 없습니다.
  초기 패킷에 CONNECTION_CLOSE 프레임을 추가하면 더 가능성이 높아집니다.
  서버가 닫힘 신호를 수신할 수 있음에도 불구하고
  애플리케이션 오류 코드를 받지 못할 수 있습니다.

* 핸드셰이크를 확인하기 전에 피어가 다음을 수행할 수 없을 수 있습니다.
  1-RTT 패킷을 처리하므로 엔드포인트는 다음을 보내야 합니다.
  핸드셰이크와 1-RTT 패킷 모두에 CONNECTION_CLOSE 프레임이 있습니다.
  서버는 또한 초기 CONNECTION_CLOSE 프레임을 보내야 합니다.
  패킷.

초기 또는 핸드셰이크에서 0x1d 유형의 CONNECTION_CLOSE 보내기
패킷은 애플리케이션 상태를 노출하거나 애플리케이션을 변경하는 데 사용될 수 있습니다.
상태. 0x1d 유형의 CONNECTION_CLOSE는 다음으로 대체되어야 합니다.
초기 또는 프레임을 보낼 때 0x1c 유형의 CONNECTION_CLOSE가 발생합니다.
핸드셰이크 패킷. 그렇지 않으면 애플리케이션에 대한 정보
상태가 공개될 수 있습니다. 엔드포인트는 값을 지워야 합니다.
Reason Phrase 필드 및 APPLICATION_ERROR 코드를 사용해야 합니다.
0x1c 유형의 CONNECTION_CLOSE로 변환합니다.

여러 패킷 유형으로 전송된 CONNECTION_CLOSE 프레임은 다음과 같습니다.
단일 UDP 데이터그램으로 통합됨. 섹션 12.2 참조.

엔드포인트는 초기 패킷에서 CONNECTION_CLOSE 프레임을 보낼 수 있습니다.
이는 인증되지 않은 정보에 대한 응답일 수 있습니다.
초기 또는 핸드셰이크 패킷. 이러한 즉각적인 종료는
서비스 거부에 대한 합법적인 연결. QUIC에는 포함되지 않습니다.
핸드셰이크 중 경로상 공격에 대한 방어 조치 참조
섹션 21.2. 그러나 오류에 대한 피드백을 줄이는 대가로
합법적인 동료의 경우 일부 형태의 서비스 거부가 이루어질 수 있습니다.
엔드포인트가 불법 패킷을 삭제하면 공격자에게 더 어렵습니다.
CONNECTION_CLOSE로 연결을 종료하는 대신.
이유로, 엔드포인트는 즉시 닫히지 않고 패킷을 삭제할 수 있습니다.
인증이 부족한 패킷에서 오류가 감지된 경우.

서버와 같이 상태가 설정되지 않은 엔드포인트
초기 패킷에서 오류를 감지하고 닫는 패킷에 들어가지 않습니다.
상태. 연결에 대한 상태가 없는 엔드포인트는
CONNECTION_CLOSE를 보낼 때 마감 또는 배수 기간을 입력합니다.
액자.

10.3. 상태 비저장 재설정

상태 비저장 재설정은 최후의 수단으로 제공됩니다.
연결 상태에 액세스할 수 없는 엔드포인트입니다.
충돌이나 중단으로 인해 피어가 계속해서 데이터를 보낼 수 있습니다.
연결을 제대로 계속할 수 없는 엔드포인트입니다.
엔드포인트는 패킷 수신에 대한 응답으로 Stateless Reset을 보낼 수 있습니다.
활성 연결과 연관될 수 없습니다.

상태 비저장 재설정은 활성 오류를 표시하는 데 적합하지 않습니다.
연결. 치명적인 통신을 원하는 엔드포인트
연결 오류는 가능한 경우 CONNECTION_CLOSE 프레임을 사용해야 합니다.

이 프로세스를 지원하기 위해 엔드포인트는 상태 비저장 재설정 토큰을 발급합니다.
이는 추측하기 어려운 16바이트 값입니다. 피어가
그 후 UDP 데이터그램인 Stateless Reset을 수신합니다.
해당 상태 비저장 재설정 토큰으로 끝나면 피어는 즉시 종료합니다.
연결.

상태 비저장 재설정 토큰은 연결 ID에 따라 다릅니다. 엔드포인트
값을 포함하여 상태 비저장 재설정 토큰을 발행합니다.
NEW_CONNECTION_ID 프레임의 상태 비저장 재설정 토큰 필드. 서버
또한 stateless_reset_token 전송 매개변수를 발행할 수도 있습니다.
선택한 연결 ID에 적용되는 핸드셰이크
핸드셰이크. 이러한 교환은 암호화로 보호되므로
클라이언트와 서버는 자신의 값을 알고 있습니다. 클라이언트는 다음을 사용할 수 없습니다.
stateless_reset_token 전송 매개변수는 전송을 위해 사용됩니다.
매개변수에는 기밀 보호가 없습니다.

연결된 연결 ID가 만료되면 토큰은 무효화됩니다.
RETIRE_CONNECTION_ID 프레임을 통해(섹션 19.16).

처리할 수 없는 패킷을 수신한 엔드포인트는 다음을 보냅니다.
다음 레이아웃의 패킷(섹션 1.3 참조):

상태 비저장 재설정 {
고정 비트(2) = 1,
예측할 수 없는 비트(38..),
상태 비저장 재설정 토큰(128),
}

                         그림 10: 상태 비저장 재설정

이 설계는 Stateless Reset이 다음과 같은 범위 내에서 이루어지도록 보장합니다.
가능 -- 짧은 일반 패킷과 구별할 수 없음
헤더.

Stateless Reset은 전체 UDP 데이터그램을 사용합니다.
패킷 헤더의 처음 두 비트. 첫 번째 바이트의 나머지
그리고 그 뒤에 오는 임의의 바이트 수는 값으로 설정됩니다.
무작위와 구별할 수 없어야 합니다. 마지막 16바이트는
데이터그램에는 상태 비저장 재설정 토큰이 포함되어 있습니다.

의도된 수신자 이외의 엔터티에 대해 Stateless Reset은 다음과 같습니다.
짧은 헤더가 있는 패킷으로 보입니다. Stateless Reset의 경우
유효한 QUIC 패킷으로 나타나려면 예측할 수 없는 비트 필드가 필요합니다.
최소 38비트의 데이터(또는 5바이트, 고정된 두 바이트 빼기)를 포함합니다.
비트).

결과적으로 최소 크기가 21바이트가 되었다는 것은 다음을 보장하지 않습니다.
Stateless Reset은 다른 패킷과 구별하기 어렵습니다.
수신자는 연결 ID를 사용해야 합니다. 이를 위해
엔드포인트는 자신이 보내는 모든 패킷이 최소 22인지 확인해야 합니다.
요청하는 최소 연결 ID 길이보다 긴 바이트
패킷에 포함할 피어, PADDING 프레임 추가
필요합니다. 이렇게 하면 피어가 보낸 모든 Stateless Reset이
엔드포인트로 전송된 유효한 패킷과 구별할 수 없습니다.
패킷에 대한 응답으로 Stateless Reset을 보내는 엔드포인트
43바이트 이하인 경우 1바이트인 Stateless Reset을 보내야 합니다.
응답하는 패킷보다 짧습니다.

이러한 값은 상태 비저장 재설정 토큰의 길이가 동일하다고 가정합니다.
패킷 보호 AEAD의 최소 확장으로. 추가
엔드포인트가 예측할 수 없는 바이트를 가질 수 있는 경우 필요합니다.
더 큰 최소값으로 패킷 보호 계획을 협상했습니다.
확장.

엔드포인트는 3회 이상 Stateless Reset을 보내서는 안 됩니다.
수신한 패킷보다 더 큰 크기를 사용하여 사용되지 않도록 합니다.
증폭. 섹션 10.3.3에서는 추가 제한 사항을 설명합니다.
상태 비저장 재설정 크기.

엔드포인트는 유효한 QUIC가 될 수 없을 만큼 작은 패킷을 삭제해야 합니다.
패킷. 예를 들어, AEAD 함수 집합을 정의하면
[QUIC-TLS]에서는 21바이트보다 작은 짧은 헤더 패킷
유효하지 않습니다.

엔드포인트는 패킷으로 포맷된 상태 비저장 재설정을 보내야 합니다.
짧은 헤더. 그러나 엔드포인트는 모든 패킷을 짧은 헤더로 처리해야 합니다.
다른 QUIC와 마찬가지로 유효한 상태 비저장 재설정 토큰은 상태 비저장 재설정으로 사용됩니다.
버전에 따라 긴 헤더를 사용할 수도 있습니다.

엔드포인트는 패킷에 대한 응답으로 Stateless Reset을 보낼 수 있습니다.
긴 헤더입니다. Stateless Reset을 보내는 것은 이전에는 효과가 없습니다.
피어가 상태 비저장 재설정 토큰을 사용할 수 있습니다. 이 QUIC에서는
버전에서는 긴 헤더가 있는 패킷은 연결 중에만 사용됩니다.
상태 비저장 재설정 토큰을 사용할 수 없기 때문에
연결 설정이 완료되거나 거의 완료될 때까지
긴 헤더가 있는 알 수 없는 패킷을 무시하는 것이 효과적일 수 있습니다.
Stateless Reset을 보내는 것과 같습니다.

엔드포인트는 패킷에서 소스 연결 ID를 확인할 수 없습니다.
짧은 헤더가 있으므로 목적지를 설정할 수 없습니다.
Stateless Reset의 연결 ID. 대상 연결 ID
따라서 이전 패킷에서 사용된 값과 다릅니다.
임의의 대상 연결 ID를 사용하면 연결 ID가 다음과 같이 나타납니다.
제공된 새 연결 ID로 이동한 결과
NEW_CONNECTION_ID 프레임; 섹션 19.15를 참조하세요.

무작위 연결 ID를 사용하면 두 가지 문제가 발생합니다.

* 패킷이 피어에 도달하지 못할 수 있습니다. 목적지가
  연결 ID는 피어를 향한 라우팅에 중요합니다.
  패킷이 잘못 라우팅되었을 수 있습니다. 이는 또한
  응답으로 또 다른 Stateless Reset이 발생합니다. 섹션 10.3.3을 참조하세요.
  올바르게 라우팅되지 않은 Stateless Reset은 비효율적입니다.
  오류 감지 및 복구 메커니즘. 이 경우 엔드포인트
  타이머와 같은 다른 방법을 사용하여 감지해야 합니다.
  연결이 실패했습니다.

* 무작위로 생성된 연결 ID는 다른 엔터티에서도 사용할 수 있습니다.
  피어보다 이것을 잠재적인 Stateless Reset으로 식별하는 것이 더 좋습니다.
  가끔 다른 연결 ID를 사용하는 엔드포인트가 있을 수 있습니다.
  이에 대해서는 약간의 불확실성이 있습니다.

이 상태 비저장 재설정 디자인은 QUIC 버전 1에만 해당됩니다.
여러 버전의 QUIC를 지원하는 엔드포인트는 다음을 생성해야 합니다.
모든 피어가 지원하는 상태 비저장 재설정
엔드포인트가 지원할 수 있는 버전(또는 지원했을 수 있는 버전)
상태를 잃기 전에). 새로운 버전의 QUIC 설계자는 다음을 수행해야 합니다.
이를 알고 (1) 이 디자인을 재사용하거나 (2) 일부를 사용합니다.
패킷의 마지막 16바이트를 제외한 나머지는 데이터를 전송하는 데 사용됩니다.

10.3.1. 상태 비저장 재설정 감지

엔드포인트는 후행 16을 사용하여 잠재적인 Stateless Reset을 감지합니다.
UDP 데이터그램의 바이트. 엔드포인트는 모든 상태 비저장 재설정을 기억합니다.
연결 ID 및 원격 주소와 관련된 토큰
최근에 전송한 데이터그램입니다. 여기에는 Stateless Reset Token이 포함됩니다.
NEW_CONNECTION_ID 프레임의 필드 값과 서버의 전송
매개변수이지만 연관된 상태 비저장 재설정 토큰은 제외합니다.
사용되지 않거나 폐기된 연결 ID입니다. 엔드포인트
수신된 데이터그램을 Stateless Reset으로 식별하려면 다음을 비교합니다.
모든 상태 비저장 재설정 토큰이 포함된 데이터그램의 마지막 16바이트
데이터그램이 있는 원격 주소와 연결됨
받았다.

이러한 비교는 모든 인바운드 데이터그램에 대해 수행할 수 있습니다.
데이터그램의 패킷이 있는 경우 엔드포인트는 이 검사를 건너뛸 수 있습니다.
성공적으로 처리되었습니다. 그러나 비교는 반드시 수행되어야 합니다.
수신 데이터그램의 첫 번째 패킷이 다음과 같은 경우
연결과 연관되어 있거나 해독할 수 없습니다.

엔드포인트는 연관된 상태 비저장 재설정 토큰을 확인해서는 안 됩니다.
사용하지 않은 연결 ID 또는 연결 ID가 있는 경우
은퇴했습니다.

데이터그램을 상태 비저장 재설정 토큰 값과 비교할 때 엔드포인트
정보를 누출하지 않고 비교를 수행해야 합니다.
토큰의 가치. 예를 들어, 이 비교를 수행하면
상수 시간은 개별 상태 비저장 재설정 토큰의 값을 보호합니다.
타이밍 사이드 채널을 통한 정보 유출. 또 다른
접근 방식은 변환된 값을 저장하고 비교하는 것입니다.
원시 토큰 값 대신 상태 비저장 재설정 토큰을 사용합니다.
변환은 암호학적으로 안전한 의사난수로 정의됩니다.
비밀 키를 사용하는 기능(예: 블록 암호, 해시된 메시지)
인증 코드(HMAC) [RFC2104]). 엔드포인트가 예상되지 않습니다.
패킷이 성공적으로 전송되었는지 여부에 대한 정보를 보호하려면
복호화된 또는 유효한 상태 비저장 재설정 토큰의 수.

데이터그램의 마지막 16바이트가 값이 동일한 경우
상태 비저장 재설정 토큰의 경우 엔드포인트는 배수 기간을 입력해야 합니다.
그리고 이 연결에서 더 이상 패킷을 보내지 않습니다.

10.3.2. 상태 비저장 재설정 토큰 계산

상태 비저장 재설정 토큰은 추측하기 어려워야 합니다.
상태 비저장 재설정 토큰을 생성하면 엔드포인트가 무작위로 생성될 수 있습니다.
[랜덤] 모든 연결에 대한 비밀이 생성됩니다. 그러나
여러 개가 있는 경우 조정 문제가 발생합니다.
클러스터의 인스턴스 또는 엔드포인트에 대한 스토리지 문제
상태를 잃을 수 있습니다. 상태 비저장 재설정은 특별히 다음을 처리하기 위해 존재합니다.
상태가 손실된 경우이므로 이 접근 방식은 최적이 아닙니다.

단일 정적 키는 동일한 모든 연결에서 사용될 수 있습니다.
의사난수 함수를 사용하여 증명을 생성하여 끝점을 찾습니다.
정적 키와 엔드포인트에서 선택한 연결 ID를 사용합니다(참조
섹션 5.1)을 입력으로 사용합니다. 엔드포인트는 HMAC [RFC2104]를 사용할 수 있습니다.
예를 들어, HMAC(static_key, connection_id)) 또는 HMAC 기반 키
파생 함수(HKDF) [RFC5869](예: 정적 사용)
키를 입력 키 자료로 사용하고 연결 ID를 salt로 사용합니다.
이 함수의 출력은 16바이트로 잘려서 생성됩니다.
해당 연결에 대한 상태 비저장 재설정 토큰입니다.

상태를 잃은 엔드포인트는 동일한 방법을 사용하여 다음을 생성할 수 있습니다.
유효한 상태 비저장 재설정 토큰입니다. 연결 ID는 패킷에서 제공됩니다.
엔드포인트가 수신합니다.

이 설계는 피어가 항상 연결 ID를 보내는 것에 의존합니다.
패킷을 통해 엔드포인트가 패킷의 연결 ID를 사용할 수 있습니다.
연결을 재설정하려면 이 디자인을 사용하는 엔드포인트는 반드시
모든 연결에 동일한 연결 ID 길이를 사용하거나
연결 ID의 길이를 인코딩하여 복구할 수 있도록 합니다.
상태 없이. 또한 길이가 0인 값을 제공할 수 없습니다.
연결 ID.

상태 비저장 재설정 토큰을 공개하면 모든 엔터티가 종료할 수 있습니다.
연결이므로 값은 한 번만 사용할 수 있습니다. 이 방법은
상태 비저장 재설정 토큰을 선택하면 다음 조합이 필요합니다.
연결 ID와 정적 키는 다른 연결에 사용해서는 안 됩니다.
동일한 연결 ID가 있는 경우 서비스 거부 공격이 가능합니다.
정적 키를 공유하는 인스턴스에서 사용되거나 공격자가 발생할 수 있는 경우
상태가 없지만 동일한 인스턴스로 라우팅되는 패킷
정적 키; 섹션 21.11 참조. 연결의 연결 ID
상태 비저장 재설정 토큰을 공개하여 재설정된 것은 다음과 같아야 합니다.
정적 키를 공유하는 노드에서 새로운 연결에 재사용됩니다.

동일한 상태 비저장 재설정 토큰은 여러 개에 사용할 수 없습니다.
연결 ID. 엔드포인트는 새 값을 비교할 필요가 없습니다.
이전 모든 값에 대해 적용되지만 중복 값은 다음과 같이 처리될 수 있습니다.
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

Stateless Resets에는 암호화 보호가 없다는 점에 유의하세요.

10.3.3. 루핑

Stateless Reset의 설계는 다음을 알지 못하는 경우입니다.
상태 비저장 재설정 토큰은 유효한 패킷과 구별할 수 없습니다.
예를 들어, 서버가 다른 서버로 Stateless Reset을 보내는 경우
응답으로 또 다른 Stateless Reset을 받을 수 있습니다.
무한한 교환으로 이어진다.

엔드포인트는 자신이 보내는 모든 Stateless Reset이 다음과 같은지 확인해야 합니다.
패킷이 상태를 유지하지 않는 한, 이를 트리거한 패킷보다 작습니다.
루핑을 방지하기에 충분합니다. 루프가 발생하는 경우 다음과 같은 결과가 발생합니다.
결국 패킷이 너무 작아서 응답을 트리거할 수 없게 됩니다.

엔드포인트는 자신이 가지고 있는 Stateless Resets의 수를 기억할 수 있습니다.
한도가 설정되면 새로운 Stateless Reset을 생성하고 중지합니다.
도달했습니다. 다른 원격 주소에 대해 별도의 제한을 사용하면
Stateless Resets를 사용하여 연결을 닫을 수 있는지 확인하십시오.
다른 동료나 연결은 한계에 도달했습니다.

41바이트보다 작은 Stateless Reset은 식별 가능할 수 있습니다.
관찰자에 의한 상태 비저장 재설정으로, 길이에 따라 다름
피어의 연결 ID. 반대로, Stateless Reset을 보내지 않음
작은 패킷에 대한 응답으로 인해 Stateless Resets가 실행되지 않을 수 있습니다.
매우 작은 경우에만 끊어진 연결의 경우를 감지하는 데 유용합니다.
패킷이 전송됩니다. 이러한 실패는 다른 패킷에 의해서만 감지될 수 있습니다.
타이머와 같은 수단.

11. 오류 처리

오류를 감지한 엔드포인트는 해당 오류의 존재를 신호로 알려야 합니다.
피어에게 오류를 전달합니다. 전송 수준 및 애플리케이션 수준 오류 모두
전체 연결에 영향을 미칠 수 있습니다. 섹션 11.1을 참조하세요. 응용 프로그램만
수준 오류는 단일 스트림으로 분리될 수 있습니다. 섹션 11.2를 참조하세요.

가장 적절한 오류 코드(섹션 20)는 다음에 포함되어야 합니다.
오류를 신호하는 프레임. 이 사양이 있는 경우
오류 조건을 식별하고 오류 코드도 식별합니다.
사용됩니다. 이것들은 요구 사항으로 표현되었지만 다릅니다.
구현 전략에 따라 다양한 오류가 발생할 수 있습니다.
보고됨. 특히, 엔드포인트는 적용 가능한 모든 오류를 사용할 수 있습니다.
오류 조건을 감지할 때의 코드; 일반 오류 코드(예:
PROTOCOL_VIOLATION 또는 INTERNAL_ERROR)는 항상 대신 사용할 수 있습니다.
특정 오류 코드.

상태 비저장 재설정(섹션 10.3)은 다음과 같은 오류에 적합하지 않습니다.
CONNECTION_CLOSE 또는 RESET_STREAM 프레임으로 신호를 보낼 수 있습니다.
상태 비저장 재설정은 상태가 있는 엔드포인트에서 사용되어서는 안 됩니다.
연결에 프레임을 보내는 것이 필요합니다.

11.1. 연결 오류

연결을 사용할 수 없게 만드는 오류(예:
프로토콜 의미론의 명백한 위반 또는 상태 손상
전체 연결에 영향을 미치므로 다음을 사용하여 신호를 보내야 합니다.
CONNECTION_CLOSE 프레임(섹션 19.19).

응용 프로그램별 프로토콜 오류는 다음을 사용하여 표시됩니다.
프레임 유형이 0x1d인 CONNECTION_CLOSE 프레임. 다음과 같은 오류가 발생합니다.
여기에 설명된 모든 것을 포함하여 운송에 특화된
문서는 CONNECTION_CLOSE 프레임에 프레임 유형으로 전달됩니다.
0x1c의.

CONNECTION_CLOSE 프레임은 손실된 패킷으로 전송될 수 있습니다.
엔드포인트는 다음을 포함하는 패킷을 재전송할 준비가 되어 있어야 합니다.
종료된 패킷에 대해 더 많은 패킷을 수신하는 경우 CONNECTION_CLOSE 프레임
연결. 재전송 횟수와 시간 제한
이 마지막 패킷이 전송되면 소요되는 노력이 제한됩니다.
종료된 연결.

패킷을 재전송하지 않기로 선택한 엔드포인트
CONNECTION_CLOSE 프레임은 피어가 첫 번째 패킷을 놓칠 위험이 있습니다.
계속해서 수신하는 엔드포인트에 사용 가능한 유일한 메커니즘
종료된 연결에 대한 데이터는 상태 비저장 재설정을 시도하는 것입니다.
프로세스(섹션 10.3).

초기 패킷의 AEAD는 강력한 기능을 제공하지 않습니다.
인증 시 엔드포인트는 잘못된 초기 패킷을 삭제할 수 있습니다.
이것이 있는 경우에도 초기 패킷을 버리는 것은 허용됩니다.
그렇지 않으면 사양에 따라 연결 오류가 발생합니다. 엔드포인트는
패킷의 프레임을 처리하지 않는 경우에만 패킷을 삭제합니다.
또는 모든 처리의 효과를 되돌립니다. 잘못된 초기값 삭제
패킷은 서비스 거부 노출을 줄이는 데 사용될 수 있습니다.
섹션 21.2.

11.2. 스트림 오류

애플리케이션 수준 오류가 단일 스트림에 영향을 미치지만 그렇지 않은 경우
연결을 복구 가능한 상태로 남겨두면 엔드포인트가 다음을 보낼 수 있습니다.
적절한 오류 코드가 포함된 RESET_STREAM 프레임(섹션 19.4)
영향을 받은 스트림만 종료합니다.

애플리케이션의 개입 없이 스트림 재설정
프로토콜은 애플리케이션 프로토콜이 입력되도록 할 수 있습니다.
복구할 수 없는 상태입니다. RESET_STREAM은 다음에 의해서만 시작되어야 합니다.
QUIC를 사용하는 애플리케이션 프로토콜.

RESET_STREAM에 전달되는 애플리케이션 오류 코드의 의미
애플리케이션 프로토콜에 의해 정의됩니다. 애플리케이션만
프로토콜은 스트림을 종료할 수 있습니다. 로컬
애플리케이션 프로토콜의 인스턴스는 직접 API 호출을 사용하고
원격 인스턴스는 STOP_SENDING 프레임을 사용하는데, 이는 다음을 트리거합니다.
자동 RESET_STREAM.

애플리케이션 프로토콜은 스트림을 처리하기 위한 규칙을 정의해야 합니다.
두 종점 중 하나에서 조기에 취소되었습니다.

12. 패킷과 프레임

QUIC 엔드포인트는 패킷을 교환하여 통신합니다. 패킷에는
기밀성 및 무결성 보호; 섹션 12.1 참조. 패킷
UDP 데이터그램으로 전송됩니다. 섹션 12.2를 참조하세요.

이 버전의 QUIC는 연결 중에 긴 패킷 헤더를 사용합니다.
설립; 섹션 17.2를 참조하세요. 긴 헤더가 있는 패킷은 다음과 같습니다.
초기(섹션 17.2.2), 0-RTT(섹션 17.2.3), 핸드셰이크
(섹션 17.2.4) 및 재시도(섹션 17.2.5). 버전 협상
긴 헤더가 있는 버전 독립 패킷을 사용합니다. 참조
섹션 17.2.1.

짧은 헤더가 있는 패킷은 최소한의 오버헤드를 위해 설계되었습니다.
연결이 설정되고 1-RTT 키가 사용된 후에 사용됩니다.
사용 가능; 섹션 17.3 참조.

12.1. 보호된 패킷

QUIC 패킷에는 다양한 수준의 암호화 보호가 있습니다.
패킷 유형에 따라 다릅니다. 패킷 보호에 대한 자세한 내용은 다음에서 확인할 수 있습니다.
[QUIC-TLS]; 이 섹션에는 보호에 대한 개요가 포함되어 있습니다.
제공됩니다.

버전 협상 패킷에는 암호화 보호가 없습니다.
[빠른 불변성].

재시도 패킷은 AEAD 기능[AEAD]을 사용하여 보호합니다.
실수로 인한 변경.

초기 패킷은 AEAD 기능을 사용하며 해당 키는 다음과 같이 파생됩니다.
와이어에 표시되는 값을 사용합니다. 따라서 초기 패킷
효과적인 기밀 보호가 없습니다. 초기 보호
패킷 발신자가 네트워크에 있는지 확인하기 위해 존재합니다.
경로. 클라이언트로부터 초기 패킷을 수신하는 모든 엔터티는
내용을 읽을 수 있는 키를 복구합니다.
패킷을 생성하고 성공적으로 전송될 초기 패킷을 생성합니다.
두 엔드포인트 모두에서 인증됩니다. AEAD는 또한 초기
패킷을 실수로 수정하는 것을 방지합니다.

다른 모든 패킷은 다음에서 파생된 키로 보호됩니다.
암호화 핸드셰이크. 암호화 핸드셰이크는 다음을 보장합니다.
통신하는 엔드포인트만이 해당 키를 수신합니다.
핸드셰이크, 0-RTT, 1-RTT 패킷. 0-RTT로 보호된 패킷
1-RTT 키는 강력한 기밀성과 무결성 보호 기능을 갖추고 있습니다.

일부 패킷 유형에 나타나는 패킷 번호 필드는 다음과 같습니다.
다음의 일부로 적용되는 대체 기밀 보호
헤더 보호; 자세한 내용은 [QUIC-TLS]의 섹션 5.4를 참조하세요.
기본 패킷 번호는 주어진 패킷이 전송될 때마다 증가합니다.
패킷 번호 공간; 자세한 내용은 섹션 12.3을 참조하세요.

12.2. 패킷 병합

초기(섹션 17.2.2), 0-RTT(섹션 17.2.3) 및 핸드셰이크
(섹션 17.2.4) 패킷에는 길이 필드가 포함되어 있습니다.
패킷의 끝. 길이에는 패킷 번호와
둘 다 기밀성이 보호되는 페이로드 필드
처음에는 길이가 알려지지 않았습니다. 페이로드 필드의 길이는 다음과 같습니다.
헤더 보호가 제거되면 학습됩니다.

길이 필드를 사용하여 발신자는 여러 QUIC 패킷을 병합할 수 있습니다.
하나의 UDP 데이터그램으로 변환합니다. 이렇게 하면 UDP 데이터그램 수를 줄일 수 있습니다.
암호화 핸드셰이크를 완료하고 전송을 시작하려면 필요합니다.
데이터. 이는 경로 최대 전송을 구성하는 데에도 사용할 수 있습니다.
단위(PMTU) 프로브; 섹션 14.4.1 참조. 수신기는 다음을 수행할 수 있어야 합니다.
병합된 패킷을 처리합니다.

암호화 수준을 높이는 순서대로 패킷을 병합합니다(초기,
0-RTT, 핸드셰이크, 1-RTT; [QUIC-TLS]의 섹션 4.1.4 참조)
수신기가 모든 패킷을 처리할 가능성이 더 높습니다.
단일 패스에서. 짧은 헤더가 있는 패킷에는 다음이 포함되지 않습니다.
길이가 길기 때문에 UDP 데이터그램에 포함되는 마지막 패킷만 될 수 있습니다.
엔드포인트는 단일 패킷에 여러 프레임을 포함해야 합니다.
병합하는 대신 동일한 암호화 수준으로 전송해야 합니다.
동일한 암호화 수준의 여러 패킷.

수신기는 첫 번째 패킷의 정보를 기반으로 라우팅할 수 있습니다.
UDP 데이터그램에 포함되어 있습니다. 발신자는 QUIC 패킷을 병합해서는 안 됩니다.
서로 다른 연결 ID를 단일 UDP 데이터그램으로 변환합니다. 수신자
다른 목적지를 갖는 후속 패킷은 무시해야 합니다.
데이터그램의 첫 번째 패킷보다 연결 ID가 더 큽니다.

단일 UDP 데이터그램으로 통합된 모든 QUIC 패킷은 다음과 같습니다.
분리되어 완전합니다. 병합된 QUIC 패킷의 수신자는 반드시
각 QUIC 패킷을 개별적으로 처리하고 별도로 확인합니다.
마치 다른 UDP의 페이로드로 수신된 것처럼
데이터그램. 예를 들어, 암호 해독이 실패하면(키가
사용할 수 없거나 다른 이유로 인해 수신기는 다음 중 하나를 수행할 수 있습니다.
패킷을 나중에 처리하기 위해 삭제하거나 버퍼링해야 하며 다음을 시도해야 합니다.
나머지 패킷을 처리합니다.

재시도 패킷(섹션 17.2.5), 버전 협상 패킷
(섹션 17.2.1) 및 짧은 헤더가 있는 패킷(섹션 17.3)
길이 필드가 없으므로 다른 패킷이 뒤따를 수 없습니다.
동일한 UDP 데이터그램에서. 또한 다음과 같은 상황이 없다는 점에 유의하십시오.
재시도 또는 버전 협상 패킷이 다른 패킷과 병합됩니다.
패킷.

12.3. 패킷 번호

패킷 번호는 0~2^62-1 범위의 정수입니다.
숫자는 패킷의 암호화 nonce를 결정하는 데 사용됩니다.
보호. 각 엔드포인트는 별도의 패킷 번호를 유지합니다.
보내기와 받기.

패킷 번호는 이 범위로 제한됩니다.
ACK의 가장 큰 확인된 필드에서 전체적으로 표현 가능
프레임(섹션 19.3). 긴 헤더나 짧은 헤더에 있는 경우
그러나 패킷 번호는 줄어들고 1~4바이트로 인코딩됩니다.
섹션 17.1.

버전 협상(섹션 17.2.1) 및 재시도(섹션 17.2.5)
패킷에는 패킷 번호가 포함되어 있지 않습니다.

QUIC에서는 패킷 번호가 세 개의 공간으로 나뉩니다.

초기 공간: 모든 초기 패킷(섹션 17.2.2)은 여기에 있습니다.
공간.

핸드셰이크 공간: 모든 핸드셰이크 패킷(섹션 17.2.4)은 여기에 있습니다.
공간.

응용 프로그램 데이터 공간: 모든 0-RTT(섹션 17.2.3) 및 1-RTT
(섹션 17.3.1) 패킷은 이 공간에 있습니다.

[QUIC-TLS]에서 설명한 대로 각 패킷 유형은 서로 다른 것을 사용합니다.
보호 키.

개념적으로 패킷 번호 공간은 패킷이 있는 컨텍스트입니다.
처리 및 확인이 가능합니다. 초기 패킷은 다음 중 하나만 전송할 수 있습니다.
초기 패킷 보호 키와 패킷에서 확인됨
초기 패킷도 마찬가지입니다. 마찬가지로 핸드셰이크 패킷은
핸드셰이크 암호화 수준이며 다음에서만 인식될 수 있습니다.
핸드셰이크 패킷.

이는 전송된 데이터 간의 암호화 분리를 강화합니다.
다른 패킷 번호 공간. 각 공간의 패킷 번호는 다음과 같습니다.
패킷 번호 0에서. 동일한 패킷으로 전송된 후속 패킷
숫자 공간은 패킷 번호를 최소한 1만큼 늘려야 합니다.

0-RTT 및 1-RTT 데이터는 동일한 패킷 번호 공간에 존재하여
두 패킷 사이에 손실 복구 알고리즘을 구현하는 것이 더 쉽습니다.
유형.

QUIC 엔드포인트는 동일한 패킷 내에서 패킷 번호를 재사용해서는 안 됩니다.
하나의 연결에 있는 숫자 공간. 전송을 위한 패킷 번호가
2^62-1에 도달하면 보낸 사람은 전송하지 않고 연결을 닫아야 합니다.
CONNECTION_CLOSE 프레임 또는 추가 패킷; 엔드포인트는 다음을 보낼 수 있습니다.
추가 패킷에 대한 응답으로 상태 비저장 재설정(섹션 10.3)
받습니다.

수신기는 새로 보호되지 않은 패킷을 다음과 같은 경우를 제외하고 삭제해야 합니다.
동일한 패킷을 포함하는 다른 패킷을 처리하지 않았는지 확인하십시오.
동일한 패킷 번호 공간에서 번호를 삭제해야 합니다. 중복 제거는 반드시
패킷 보호를 제거한 후 다음과 같은 이유로 발생합니다.
[QUIC-TLS]의 섹션 9.5.

모든 개별 패킷을 추적하는 엔드포인트
중복을 감지하면 과도한 상태가 누적될 위험이 있습니다.
중복을 감지하는 데 필요한 데이터는 다음에 의해 제한될 수 있습니다.
모든 패킷이 그 이하로 유지되는 최소 패킷 번호 유지
즉시 삭제됩니다. 최소값은 큰 값을 고려해야 합니다.
왕복 시간의 변동에는 다음이 포함될 가능성이 있습니다.
피어는 훨씬 더 긴 왕복 시간을 갖는 네트워크 경로를 조사할 수 있습니다.
섹션 9.

송신측에서 패킷번호 인코딩과 수신측에서 디코딩은 다음과 같습니다.
섹션 17.1에 설명되어 있습니다.

12.4. 프레임 및 프레임 유형

패킷 보호를 제거한 후 QUIC 패킷의 페이로드는
그림 11에 표시된 것처럼 완전한 프레임의 시퀀스로 구성됩니다.
버전 협상, 상태 비저장 재설정 및 재시도 패킷은 작동하지 않습니다.
프레임을 포함합니다.

패킷 페이로드 {
프레임(8..) ...,
}

                          그림 11: QUIC 페이로드

프레임을 포함하는 패킷의 페이로드에는 최소한 다음이 포함되어야 합니다.
하나의 프레임이며, 여러 개의 프레임과 여러 개의 프레임 유형을 포함할 수 있습니다.
엔드포인트는 프레임이 없는 패킷 수신을 다음과 같이 처리해야 합니다.
PROTOCOL_VIOLATION 유형의 연결 오류가 발생했습니다. 프레임은 항상 맞춰집니다.
단일 QUIC 패킷 내에서만 가능하며 여러 패킷에 걸쳐 적용될 수 없습니다.

각 프레임은 프레임 유형을 나타내는 프레임 유형으로 시작하고 그 뒤에 다음이 붙습니다.
추가 유형 종속 필드:

액자 {
프레임 유형(i),
유형 종속 필드(..),
}

                      그림 12: 일반 프레임 레이아웃

표 3은 각 프레임 유형에 대한 정보를 나열하고 요약합니다.
이 사양에서는 정의되어 있습니다. 이 요약에 대한 설명은 다음과 같습니다.
표 뒤에 포함됨.

    +============+=======================+===============+=======+======+=====+
    | 유형 값 | 프레임 유형 이름 | 정의 | 패킷 | 사양 |
    +============+=======================+===============+=======+======+=====+
    | 0x00 | 패딩 | 섹션 19.1 | IH01 | NP |
    +------------+------------+---------------+------+------+
    | 0x01 | PING | 섹션 19.2 | IH01 | |
    +------------+------------+---------------+------+------+
    | 0x02-0x03 | ACK | 섹션 19.3 | IH_1 | NC |
    +------------+------------+---------------+------+------+
    | 0x04 | RESET_STREAM | 섹션 19.4 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x05 | STOP_SENDING | 섹션 19.5 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x06 | CRYPTO | 섹션 19.6 | IH_1 | |
    +------------+------------+---------------+------+------+
    | 0x07 | NEW_TOKEN | 섹션 19.7 | ___1 | |
    +------------+------------+---------------+------+------+
    | 0x08-0x0f | 스트림 | 섹션 19.8 | __01 | F |
    +------------+------------+---------------+------+------+
    | 0x10 | MAX_DATA | 섹션 19.9 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x11 | MAX_STREAM_DATA | 섹션 19.10 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x12-0x13 | MAX_STREAMS | 섹션 19.11 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x14 | DATA_BLOCKED | 섹션 19.12 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x15 | STREAM_DATA_BLOCKED | 섹션 19.13 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x16-0x17 | STREAMS_BLOCKED | 섹션 19.14 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x18 | NEW_CONNECTION_ID | 섹션 19.15 | __01 | P |
    +------------+------------+---------------+------+------+
    | 0x19 | RETIRE_CONNECTION_ID | 섹션 19.16 | __01 | |
    +------------+------------+---------------+------+------+
    | 0x1a | PATH_CHALLENGE | 섹션 19.17 | __01 | P |
    +------------+------------+---------------+------+------+
    | 0x1b | PATH_RESPONSE | 섹션 19.18 | ___1 | P |
    +------------+------------+---------------+------+------+
    | 0x1c-0x1d | 연결_닫힘 | 섹션 19.19 | ih01 | N |
    +------------+------------+---------------+------+------+
    | 0x1e | HANDSHAKE_DONE | 섹션 19.20 | ___1 | |
    +------------+------------+---------------+------+------+

                            표 3: 프레임 유형

각 프레임 유형의 형식과 의미는 자세히 설명되어 있습니다.
섹션 19에 자세히 나와 있습니다. 이 섹션의 나머지 부분에서는 다음을 제공합니다.
중요하고 일반적인 정보의 요약입니다.

ACK, STREAM, MAX_STREAMS, STREAMS_BLOCKED 등의 프레임 유형
CONNECTION_CLOSE 프레임은 다른 프레임별 플래그를 전달하는 데 사용됩니다.
다른 모든 프레임의 경우 프레임 유형 필드는 단순히 다음을 식별합니다.
액자.

표 3의 "Pkts" 열에는 각 패킷 유형이 나열되어 있습니다.
프레임 유형은 다음 문자로 표시될 수 있습니다.

I: 초기(섹션 17.2.2)

H: 핸드셰이크(섹션 17.2.4)

0: 0-RTT (섹션 17.2.3)

1: 1-RTT (섹션 17.3.1)

ih: 초기값에는 0x1c 유형의 CONNECTION_CLOSE 프레임만 나타날 수 있습니다.
또는 핸드셰이크 패킷.

이러한 제한 사항에 대한 자세한 내용은 섹션 12.5를 참조하세요. 참고
모든 프레임이 1-RTT 패킷에 나타날 수 있습니다. 엔드포인트는 다음을 처리해야 합니다.
허용되지 않는 패킷 유형의 프레임 수신
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

표 3의 "사양" 열은 다음을 규정하는 특별 규칙을 요약합니다.
프레임 유형의 처리 또는 생성은 다음에 의해 표시됩니다.
다음 문자:

N: 이 표시가 있는 프레임만 포함된 패킷은 확인되지 않습니다.
유도; 섹션 13.2 참조.

C: 이 표시가 있는 프레임만 포함된 패킷은 계산되지 않습니다.
혼잡 제어 목적으로 비행 중 바이트를 참조하세요.
[빠른 복구]

P: 이 표시가 있는 프레임만 포함된 패킷은 다음에 사용할 수 있습니다.
연결 마이그레이션 중에 새로운 네트워크 경로를 조사합니다.
섹션 9.1.

F: 이 표시가 있는 프레임의 내용은 흐름 제어됩니다.
섹션 4를 참조하세요.

표 3의 "Pkts" 및 "Spec" 열은 IANA의 일부를 형성하지 않습니다.
레지스트리; 섹션 22.4를 참조하세요.

엔드포인트는 알 수 없는 유형의 프레임 수신을 다음과 같이 처리해야 합니다.
FRAME_ENCODING_ERROR 유형의 연결 오류입니다.

이 버전의 QUIC에서는 모든 프레임이 멱등합니다. 즉, 유효한
프레임은 수신 시 바람직하지 않은 부작용이나 오류를 일으키지 않습니다.
한 번 이상.

프레임 유형 필드는 가변 길이 정수 인코딩을 사용합니다(참조
섹션 16) 한 가지 예외를 제외하고 간단하고 효율적인
프레임 구문 분석 구현에서 프레임 유형은 가장 짧은 것을 사용해야 합니다.
가능한 인코딩. 이 문서에 정의된 프레임 유형의 경우
인코딩이 가능하더라도 단일 바이트 인코딩을 의미합니다.
이러한 값을 2바이트, 4바이트 또는 8바이트 가변 길이 정수로 표현합니다.
예를 들어, 0x4001은 합법적인 2바이트 인코딩이지만
1의 값을 갖는 가변 길이 정수, PING 프레임은 항상
0x01 값을 갖는 단일 바이트로 인코딩됩니다. 이 규칙은 다음에 적용됩니다.
현재 및 미래의 모든 QUIC 프레임 유형. 엔드포인트는 다음을 처리할 수 있습니다.
필요 이상으로 긴 인코딩을 사용하는 프레임 유형을 수신하는 경우
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

12.5. 프레임과 숫자 공간

일부 프레임은 다른 패킷 번호 공간에서 금지됩니다.
여기의 규칙은 TLS의 규칙을 일반화합니다. 즉, 프레임이 다음과 연관되어 있습니다.
연결 설정은 일반적으로 모든 패킷에 나타날 수 있습니다.
패킷 번호 공간은 데이터 전송과 관련된 공간입니다.
애플리케이션 데이터 패킷 번호 공간에만 나타날 수 있습니다.

* PADDING, PING 및 CRYPTO 프레임은 모든 패킷 번호에 나타날 수 있습니다.
  공간.

* QUIC 계층에서 오류를 신호하는 CONNECTION_CLOSE 프레임(유형
  0x1c)는 모든 패킷 번호 공간에 나타날 수 있습니다. CONNECTION_CLOSE
  프레임 신호 애플리케이션 오류(유형 0x1d)는 다음 중 하나만 나타나야 합니다.
  애플리케이션 데이터 패킷 번호 공간에서.

* ACK 프레임은 모든 패킷 번호 공간에 나타날 수 있지만
  해당 패킷 번호 공간에 나타난 패킷을 확인합니다.
  하지만 아래에 언급된 것처럼 0-RTT 패킷에는 ACK 프레임이 포함될 수 없습니다.

* 다른 모든 프레임 유형은 애플리케이션 데이터로만 전송되어야 합니다.
  패킷 번호 공간.

다음 프레임을 0-RTT로 보내는 것은 불가능하다는 점에 유의하세요.
다양한 이유로 패킷: ACK, CRYPTO, HANDSHAKE_DONE, NEW_TOKEN,
PATH_RESPONSE 및 RETIRE_CONNECTION_ID. 서버는 수신을 처리할 수 있습니다.
0-RTT 패킷의 이러한 프레임은 연결 오류 유형으로 표시됩니다.
프로토콜 위반.

13. 패킷화 및 신뢰성

발신자는 QUIC 패킷에 하나 이상의 프레임을 보냅니다. 섹션 12.4를 참조하세요.

발신자는 패킷당 대역폭과 계산 비용을 최소화할 수 있습니다.
각 QUIC 패킷에 가능한 한 많은 프레임을 포함합니다. 송신자
여러 프레임을 수집하기 전에 짧은 시간 동안 기다릴 수 있습니다.
최대로 압축되지 않은 패킷을 보내어 전송을 방지합니다.
많은 수의 작은 패킷. 구현은 지식을 사용할 수 있습니다.
애플리케이션 전송 동작 또는 휴리스틱을 사용하여 다음을 결정합니다.
그리고 얼마나 기다려야 하는지. 이 대기 기간은 구현입니다.
결정과 구현은 지연에 주의해야 합니다.
보수적으로 말하면 지연이 발생하면 신청이 늘어날 가능성이 있기 때문입니다.
눈에 보이는 지연 시간.

스트림 멀티플렉싱은 STREAM 프레임을 인터리빙하여 달성됩니다.
여러 스트림을 하나 이상의 QUIC 패킷으로 변환합니다. 단일 QUIC 패킷
하나 이상의 스트림에서 여러 개의 STREAM 프레임을 포함할 수 있습니다.

QUIC의 이점 중 하나는 HOL(Head-of-Line) 블로킹을 피할 수 있다는 것입니다.
여러 스트림에 걸쳐 있습니다. 패킷 손실이 발생하면 스트림만
해당 패킷의 데이터가 재전송을 기다리는 동안 차단됩니다.
수신될 수 있으며, 다른 스트림은 계속 진행될 수 있습니다. 참고
여러 스트림의 데이터가 단일 QUIC에 포함되는 경우
패킷이 손실되면 모든 스트림이 차단됩니다.
진행 상황. 구현에는 가능한 한 적은 수의 스트림을 포함하는 것이 좋습니다.전송 효율성을 잃지 않고 나가는 패킷
에 필요함
채워지지 않은 패킷에.

13.1. 패킷 처리

패킷 보호가 완료될 때까지 패킷을 확인해서는 안 됩니다.
성공적으로 제거되었으며 패킷에 포함된 모든 프레임이 제거되었습니다.
처리됨. STREAM 프레임의 경우 이는 데이터가 대기열에 추가되었음을 의미합니다.
신청 프로토콜에 의해 수신될 준비를 하고 있지만,
데이터가 전달되고 소비될 필요가 없습니다.

패킷이 완전히 처리되면 수신기가 확인합니다.
패킷을 포함하는 하나 이상의 ACK 프레임을 보내 수신
수신된 패킷의 번호.

엔드포인트는 패킷에 대한 확인 수신을 처리해야 합니다.
PROTOCOL_VIOLATION 유형의 연결 오류로 전송되지 않았습니다.
상태를 감지할 수 있습니다. 이 방법에 대한 자세한 내용은
달성될 수 있는 내용은 21.4절을 참조하세요.

13.2. 확인 메시지 생성

엔드포인트는 수신하고 처리하는 모든 패킷을 확인합니다. 그러나
ACK를 유도하는 패킷만이 ACK 프레임을 전송하게 합니다.
최대 ack 지연. ack를 유도하지 않는 패킷은
다른 이유로 ACK 프레임이 전송되면 확인됩니다.

어떤 이유로든 패킷을 보낼 때 엔드포인트는 다음을 시도해야 합니다.
최근에 전송되지 않은 ACK 프레임이 있으면 포함합니다. 그렇게 하면
피어에서 적시에 손실을 감지하는 데 도움이 됩니다.

일반적으로 수신기로부터 자주 피드백을 받으면 손실이 개선됩니다.
혼잡 대응이지만 과도한 대응과 균형을 이루어야 합니다.
응답으로 ACK 프레임을 보내는 수신기에 의해 생성된 부하
모든 ack 유도 패킷. 아래에 제공된 지침은 다음을 목표로 합니다.
이 균형을 맞추세요.

13.2.1. ACK 프레임 전송

모든 패킷은 적어도 한 번은 확인되어야 하며 확인 유도
패킷은 최대 지연 시간 내에 적어도 한 번은 확인되어야 합니다.
max_ack_delay 전송 매개변수를 사용하여 통신된 엔드포인트
섹션 18.2를 참조하세요. max_ack_delay는 명시적 계약을 선언합니다.
엔드포인트는 의도적으로 확인을 지연하지 않을 것을 약속합니다.
ack 유도 패킷이 지정된 값보다 더 많이 전송되는 경우
초과분은 RTT 추정치에 누적되어 허위로 표시될 수 있습니다.
또는 피어로부터의 지연된 재전송. 발신자는 다음을 사용합니다.
타이머의 타임아웃을 결정하는 수신기의 max_ack_delay 값
[QUIC-RECOVERY]의 섹션 6.2에 자세히 설명된 대로 기반 재전송.

엔드포인트는 모든 ack-eliciting Initial 및 Handshake를 확인해야 합니다.
패킷을 즉시 그리고 모든 ack-eliciting 0-RTT 및 1-RTT 패킷
광고된 max_ack_delay 내에서 다음 예외가 적용됩니다.
핸드셰이크 확인 전에 엔드포인트에 패킷이 없을 수 있습니다.
핸드셰이크, 0-RTT 또는 1-RTT 패킷을 해독하기 위한 보호 키
수신될 때. 따라서 버퍼링될 수 있습니다.
필요한 키가 제공되면 이를 인지합니다.

ACK 프레임만 포함된 패킷은 혼잡이 아닙니다.
제어되는 경우 엔드포인트는 이러한 패킷을 두 개 이상 보내서는 안 됩니다.
ACK를 유도하는 패킷을 수신한 것에 대한 응답.

엔드포인트는 응답으로 ACK를 유도하지 않는 패킷을 보내서는 안 됩니다.
패킷 간격이 선행하더라도 ACK를 유발하지 않는 패킷
수신된 패킷. 이렇게 하면 무한 피드백 루프가 방지됩니다.
연결이 영원히 중단될 수 있는 확인 사항
유휴 상태가 됩니다. ACK를 유발하지 않는 패킷은 결국 확인됩니다.
엔드포인트가 다른 이벤트에 대한 응답으로 ACK 프레임을 보낼 때.

ACK 프레임만 보내는 엔드포인트는 수신하지 않습니다.
해당 인정이 다음과 같은 경우를 제외하고 동료의 인정은 허용되지 않습니다.
ack-eliciting 프레임이 있는 패킷에 포함됩니다. 엔드포인트는 다음을 수행해야 합니다.
새로운 ACK를 유도하는 프레임이 있을 때 다른 프레임과 함께 ACK 프레임을 보냅니다.
확인 패킷. 확인하지 않는 패킷만 확인이 필요한 경우
확인되면 엔드포인트는 ACK 프레임을 보내지 않기로 선택할 수 있습니다.
ACK를 유도하는 패킷을 수신할 때까지 나가는 프레임입니다.

ACK를 유발하지 않는 패킷만 보내는 엔드포인트는 다음과 같습니다.
가끔씩 해당 패킷에 ACK 유도 프레임을 추가하도록 선택합니다.
확인을 받았는지 확인하십시오. 섹션 13.2.4를 참조하십시오.
이 경우 엔드포인트는 모든 ACK 유도 프레임을 보내서는 안 됩니다.
그렇지 않으면 ACK를 유발하지 않는 패킷을 피하기 위해
무한한 감사의 피드백 루프.

발신자에서 손실 감지를 지원하기 위해 엔드포인트는 다음을 수행해야 합니다.
ACK를 받으면 지연 없이 ACK 프레임을 생성하여 전송합니다.
패킷을 유도하는 방법:

* 수신된 패킷의 패킷 번호가 다른 패킷보다 작은 경우
  수신된 ack-eliciting 패킷 또는

* 패킷의 패킷 번호가 가장 높은 패킷 번호보다 큰 경우
  수신된 번호가 매겨진 ack-eliciting 패킷이 있고
  해당 패킷과 이 패킷 사이에 패킷이 누락되었습니다.

마찬가지로 ECN Congestion Experienced(CE)로 표시된 패킷
IP 헤더의 코드포인트는 즉시 인식되어야 합니다.
혼잡 이벤트에 대한 피어의 응답 시간을 줄입니다.

[QUIC-RECOVERY]의 알고리즘은 다음과 같은 상황에서도 복원력이 있을 것으로 예상됩니다.
위에 제공된 지침을 따르지 않는 수신기. 그러나
구현은 이러한 요구 사항에서 벗어나야 합니다.
변경 사항의 성능 영향에 대한 신중한 고려
엔드포인트에서 만든 연결과 다른 사용자를 위한 연결
회로망.

13.2.2. 확인 빈도

수신기는 확인 메시지를 얼마나 자주 보낼지 결정합니다.
ack 유도 패킷에 대한 응답입니다. 이 결정에는 다음이 포함됩니다.
상충관계.

엔드포인트는 손실을 감지하기 위해 적시 확인에 의존합니다. 섹션 6을 참조하세요.
[QUIC-RECOVERY]의. Window 기반 혼잡 컨트롤러(예:
[QUIC-RECOVERY]의 섹션 7에 설명된 것 중 하나를 사용합니다.
혼잡 윈도우를 관리하기 위한 감사의 말. 두 경우 모두,
확인을 지연하면 성능에 부정적인 영향을 미칠 수 있습니다.

반면, 패킷의 빈도를 줄이는 것은 단지
확인은 패킷 전송 및 처리 비용을 줄입니다.
두 엔드포인트 모두. 연결 처리량을 크게 향상시킬 수 있습니다.
비대칭 링크 및 확인 트래픽 볼륨 감소
반환 경로 용량 사용; [RFC3449]의 섹션 3을 참조하세요.

수신기는 최소 두 개의 ACK를 수신한 후 ACK 프레임을 보내야 합니다.
패킷을 유도합니다. 이 권장 사항은 일반적인 성격을 띠고 있습니다.
TCP 엔드포인트 동작에 대한 권장 사항[RFC5681]과 일치합니다.
네트워크 상황에 대한 지식, 피어의 혼잡에 대한 지식
컨트롤러 또는 추가 연구 및 실험에서 제안할 수 있습니다.
더 나은 성능을 제공하는 대체 확인 전략
형질.

수신기는 결정하기 전에 여러 개의 사용 가능한 패킷을 처리할 수 있습니다.
응답으로 ACK 프레임을 보낼지 여부.

13.2.3. ACK 범위 관리

ACK 프레임이 전송되면 하나 이상의 확인된 패킷 범위
포함됩니다. 이전 패킷에 대한 확인 메시지를 포함하면
이전에 손실된 것으로 인해 잘못된 재전송이 발생할 가능성
더 큰 ACK 프레임을 희생하여 ACK 프레임을 보냈습니다.

ACK 프레임은 항상 가장 최근에 수신된 것을 확인해야 합니다.
패킷이 많을수록 패킷 순서가 어긋날수록 더 많아집니다.
중요한 것은 업데이트된 ACK 프레임을 신속하게 보내는 것입니다.
패킷이 손실되었다고 선언하고 잘못 재전송하는 피어
포함된 프레임입니다. ACK 프레임은 다음에 맞춰야 합니다.
단일 QUIC 패킷. 그렇지 않은 경우 이전 범위(다음이 있는 범위)가
(가장 작은 패킷 번호)는 생략됩니다.

수신기는 ACK 범위의 수를 제한합니다(섹션 19.3.1)
ACK 프레임을 기억하고 전송하여 ACK 크기를 제한합니다.
프레임을 생성하고 리소스 고갈을 방지합니다. 수신 후
ACK 프레임에 대한 확인 응답이 있으면 수신기는 추적을 중지해야 합니다.
확인된 ACK 범위. 발신자는 확인 응답을 기대할 수 있습니다.
대부분의 패킷의 경우 QUIC는 수신을 보장하지 않습니다.
수신기가 처리하는 모든 패킷에 대한 확인.

많은 ACK 범위를 유지하면 ACK가 발생할 수 있습니다.
프레임이 너무 커지면 수신자는 확인되지 않은 ACK를 삭제할 수 있습니다.
ACK 프레임 크기를 제한하는 범위는 증가 비용을 수반합니다.
송신자로부터의 재전송. 이는 ACK 프레임이 수신자에게 도달하는 경우에 필요합니다.
패킷에 들어가기에는 너무 큽니다. 수신자는 ACK를 제한할 수도 있습니다.
다른 프레임을 위한 공간을 확보하거나 프레임 크기를 제한하기 위해 프레임 크기를 더욱 늘립니다.
확인이 소모하는 용량.

수신기는 ACK 범위를 유지해야 합니다.
이후에는 해당 범위 내의 숫자를 포함하는 패킷을 수락하지 않습니다.
범위가 증가함에 따라 최소 패킷 수를 유지합니다.
폐기는 최소한의 상태로 이를 달성하는 한 가지 방법입니다.

수신기는 모든 ACK 범위를 삭제할 수 있지만 다음을 유지해야 합니다.
성공적으로 처리된 가장 큰 패킷 번호입니다.
이후 패킷에서 패킷 번호를 복구하는 데 사용됩니다. 참조
섹션 17.1.

수신기는 가장 큰 값을 포함하는 ACK 범위를 포함해야 합니다.
모든 ACK 프레임에서 수신된 패킷 번호. 가장 큰 확인된 패킷
필드는 발신자의 ECN 검증에 사용되며 더 낮은 값을 포함합니다.
이전 ACK 프레임에 포함된 값보다 큰 값이 있으면 ECN이 발생할 수 있습니다.
불필요하게 비활성화됨; 섹션 13.4.2 참조.

섹션 13.2.4에서는 다음을 결정하기 위한 모범적인 접근 방식을 설명합니다.
각 ACK 프레임에서 확인 응답할 패킷. 이 방법의 목적은
알고리즘은 모든 패킷에 대한 확인을 생성하는 것입니다.
처리가 완료되었더라도 확인 메시지가 손실될 가능성이 있습니다.

13.2.4. ACK 프레임 추적을 통한 범위 제한

ACK 프레임을 포함하는 패킷이 전송되면 가장 큰
해당 프레임의 확인된 필드는 저장될 수 있습니다. 패킷이
ACK 프레임이 포함된 경우 수신자는 수신을 중지할 수 있습니다.
가장 큰 확인 패킷보다 작거나 같은 패킷 확인
전송된 ACK 프레임의 필드.

ACK와 같은 비ACK 유도 패킷만 보내는 수신기
프레임은 장기간 동안 확인을 받지 못할 수 있습니다.
시간. 이로 인해 수신기가 장시간 상태를 유지할 수 있습니다.
장시간 동안 ACK 프레임의 수와 ACK 프레임
전송이 불필요하게 클 수 있습니다. 그런 경우 수신기는
가끔 PING이나 기타 작은 ACK 유도 프레임을 보냅니다.
왕복당 한 번씩 피어로부터 ACK를 이끌어냅니다.

ACK 프레임 손실이 없는 경우 이 알고리즘은 최소값을 허용합니다.
1 RTT의 재정렬. ACK 프레임 손실 및 재정렬이 발생하는 경우,
이 접근 방식은 모든 확인이 다음에 의해 확인된다는 것을 보장하지 않습니다.
보낸 사람이 더 이상 ACK 프레임에 포함되지 않기 전에. 패킷
순서 없이 수신될 수 있으며 이후의 모든 ACK 프레임
이를 포함하는 것이 손실될 수 있습니다. 이 경우 손실 회복
알고리즘은 잘못된 재전송을 일으킬 수 있지만 보낸 사람은
계속해서 전진해 나가세요.

13.2.5. 호스트 지연 측정 및 보고

엔드포인트는 의도적으로 도입된 지연을 측정합니다.
가장 큰 패킷 번호를 가진 패킷이 수신되는 시간과
확인이 전송되는 시간입니다. 엔드포인트는 이를 인코딩합니다.
ACK 프레임의 ACK 지연 필드에서의 확인 지연; 참조
섹션 19.3. 이를 통해 ACK 프레임의 수신자는 다음을 조정할 수 있습니다.
더 나은 결과를 얻기 위해 중요한 의도적인 지연에 대해서는
확인이 지연될 때 경로 RTT를 추정합니다.

패킷은 OS 커널이나 호스트의 다른 곳에 보관될 수 있습니다.
처리되기 전에. 엔드포인트에는 지연이 포함되어서는 안 됩니다.
ACK 프레임의 ACK 지연 필드를 채우는 시기를 제어하지 않습니다.
그러나 엔드포인트에는 버퍼링 지연이 포함되어야 합니다.
이러한 지연이 클 수 있으므로 복호화 키를 사용할 수 없음
반복되지 않을 가능성이 높습니다.

측정된 확인 지연이 실제보다 큰 경우
max_ack_delay, 엔드포인트는 측정된 지연을 보고해야 합니다.
정보는 특히 지연이 발생하는 핸드셰이크 중에 유용합니다.
클 수 있음; 섹션 13.2.1 참조.

13.2.6. ACK 프레임 및 패킷 보호

ACK 프레임은 동일한 패킷을 포함하는 패킷에만 전송되어야 합니다.
패킷이 확인되는 대로 숫자 공간을 지정합니다. 섹션 12.1을 참조하세요.
예를 들어, 1-RTT 키로 보호되는 패킷은 반드시 다음과 같아야 합니다.
1-RTT 키로 보호되는 패킷에서도 확인됩니다.

클라이언트가 0-RTT 패킷 보호로 보내는 패킷은 다음과 같아야 합니다.
1-RTT 키로 보호되는 패킷에서 서버에 의해 확인됩니다.
클라이언트가 이러한 확인을 사용할 수 없다는 것을 의미할 수 있습니다.
서버 암호화 핸드셰이크 메시지가 지연되거나 손실됩니다.
동일한 제한 사항이 다른 데이터에도 적용됩니다.
1-RTT 키로 보호되는 서버입니다.

13.2.7. 패딩 프레임은 혼잡 윈도우를 소모합니다.

PADDING 프레임이 포함된 패킷은 비행 중인 것으로 간주됩니다.
혼잡 제어 목적 [QUIC-RECOVERY]. 다음만 포함하는 패킷
따라서 PADDING 프레임은 혼잡 창을 소모하지만
혼잡 창을 여는 확인을 생성합니다.
교착 상태를 피하기 위해 발신자는 다른 프레임이 전송되도록 해야 합니다.
주기적으로 PADDING 프레임에 추가하여 확인을 유도합니다.
수신자로부터.

13.3. 정보 재전송

손실된 것으로 판단된 QUIC 패킷은 재전송되지 않습니다.
전체. 손실된 프레임에 포함된 프레임에도 동일하게 적용됩니다.
패킷. 대신 프레임에 포함될 수 있는 정보는 다음과 같습니다.
필요에 따라 새로운 프레임으로 다시 전송됩니다.

새로운 프레임과 패킷은 정보를 전달하는 데 사용됩니다.
분실된 것으로 확인되었습니다. 일반적으로 정보는 다시 전송됩니다.
해당 정보가 포함된 패킷이 손실된 것으로 판단되는 경우,
해당 정보가 포함된 패킷이 전송되면 전송이 중단됩니다.
인정됨.

* CRYPTO 프레임으로 전송된 데이터는 규칙에 따라 재전송됩니다.
  [QUIC-RECOVERY]에서 모든 데이터가 확인될 때까지. 데이터
  초기 및 핸드셰이크 패킷에 대한 CRYPTO 프레임은 다음과 같은 경우 삭제됩니다.
  해당 패킷 번호 공간에 대한 키는 삭제됩니다.

* STREAM 프레임으로 전송된 애플리케이션 데이터는 새로운 프레임으로 재전송됩니다.
  엔드포인트가 해당 RESET_STREAM을 전송하지 않는 한 STREAM 프레임
  스트림. 엔드포인트가 RESET_STREAM 프레임을 보내면 더 이상
  STREAM 프레임이 필요합니다.

* ACK 프레임은 가장 최근의 확인 집합과
  가장 큰 확인 패킷으로부터 확인 지연이 발생합니다.
  13.2.1절에 설명되어 있습니다. 패킷 전송 지연
  ACK 프레임을 포함하거나 이전 ACK 프레임을 다시 보내면 다음과 같은 문제가 발생할 수 있습니다.
  피어가 부풀려진 RTT 샘플을 생성하거나 불필요하게 비활성화합니다.
  ECN(이씨엔)

* RESET_STREAM에서 수행되는 스트림 전송 취소
  프레임은 확인되거나 모든 스트림 데이터가 전송될 때까지 전송됩니다.
  피어가 인식한 것(즉, "Reset Recvd" 또는
  스트림의 전송 부분에서 "데이터 수신" 상태에 도달합니다.
  RESET_STREAM 프레임의 내용은 변경될 수 없습니다.
  다시 보냈습니다.

* 마찬가지로, 인코딩된 대로 스트림 전송을 취소하라는 요청은
  STOP_SENDING 프레임은 수신 부분까지 전송됩니다.
  스트림이 "데이터 수신" 또는 "재설정 수신" 상태로 전환됩니다.
  섹션 3.5.

* 패킷을 포함한 연결 종료 신호
  CONNECTION_CLOSE 프레임은 패킷 손실이 발생하면 다시 전송되지 않습니다.
  감지되었습니다. 이러한 신호를 다시 보내는 방법은 섹션 10에 설명되어 있습니다.

* 현재 연결 최대 데이터는 MAX_DATA 프레임으로 전송됩니다.
  패킷이 MAX_DATA 프레임에 업데이트된 값으로 전송됩니다.
  가장 최근에 전송된 MAX_DATA 프레임이 포함된 것이 손실되었다고 선언됩니다.
  또는 엔드포인트가 한도를 업데이트하기로 결정할 때 주의하세요.
  이 프레임을 너무 자주 보내는 것을 방지하기 위해 필요합니다. 제한이 있을 수 있습니다.
  자주 증가하고 불필요하게 많은 수의
  전송할 MAX_DATA 프레임 수; 섹션 4.2 참조.

* 현재 최대 스트림 데이터 오프셋은 MAX_STREAM_DATA로 전송됩니다.
  프레임. MAX_DATA와 마찬가지로 패킷이 전송될 때 업데이트된 값이 전송됩니다.
  스트림에 대한 최신 MAX_STREAM_DATA 프레임을 포함하는 것은 다음과 같습니다.
  손실되거나 한도가 업데이트될 때, 주의해서 방지하십시오.
  프레임이 너무 자주 전송되는 것을 방지합니다. 엔드포인트는 전송을 중지해야 합니다.
  스트림 수신 부분이 MAX_STREAM_DATA 프레임일 때
  "알려진 크기" 또는 "수신 재설정" 상태로 전환됩니다.

* 주어진 유형의 스트림에 대한 제한은 MAX_STREAMS로 전송됩니다.
  프레임. MAX_DATA와 마찬가지로 패킷이 전송될 때 업데이트된 값이 전송됩니다.
  스트림 유형 프레임에 대한 최신 MAX_STREAMS를 포함하는 것은 다음과 같습니다.
  분실 신고가 접수되거나 한도가 업데이트될 때 주의가 필요합니다.
  프레임이 너무 자주 전송되는 것을 방지합니다.

* 차단된 신호는 DATA_BLOCKED, STREAM_DATA_BLOCKED로 전송됩니다.
  및 STREAMS_BLOCKED 프레임. DATA_BLOCKED 프레임에는 연결이 있습니다.
  범위, STREAM_DATA_BLOCKED 프레임에는 스트림 범위가 있으며
  STREAMS_BLOCKED 프레임은 특정 스트림 유형으로 범위가 지정됩니다.
  가장 최근의 프레임을 포함하는 패킷이 전송되면 새 프레임이 전송됩니다.
  범위가 손실되지만 엔드포인트가 차단된 동안만 손실됩니다.
  해당 제한. 이러한 프레임에는 항상 다음 제한이 포함됩니다.
  전송되는 시점에 차단이 발생합니다.

* PATH_CHALLENGE 프레임을 사용한 활성 또는 경로 유효성 검사는
  일치하는 PATH_RESPONSE 프레임이 수신될 때까지 주기적으로 전송됨
  또는 더 이상 생명력이나 경로에 대한 필요성이 없을 때까지
  유효성 검사. PATH_CHALLENGE 프레임에는 다른 것이 포함됩니다.
  보낼 때마다 탑재량이 늘어납니다.

* PATH_RESPONSE 프레임을 사용하여 경로 검증에 대한 응답이 전송됩니다.
  한 번만. 피어는 더 많은 PATH_CHALLENGE를 보낼 것으로 예상됩니다.
  필요에 따라 추가 PATH_RESPONSE 프레임을 불러오기 위해 프레임을 사용합니다.

* 새로운 연결 ID는 NEW_CONNECTION_ID 프레임으로 전송됩니다.
  해당 패킷이 손실되면 재전송됩니다.
  이 프레임의 재전송은 동일한 시퀀스 번호를 갖습니다.
  값. 마찬가지로, 폐기된 연결 ID가 전송됩니다.
  RETIRE_CONNECTION_ID 프레임을 전송하고 패킷이 재전송되면
  이를 담고 있는 내용이 손실되었습니다.

* NEW_TOKEN 프레임은 해당 프레임을 포함하는 패킷이 있는 경우 재전송됩니다.
  손실되었습니다. 재정렬된 항목을 감지하기 위한 특별한 지원은 제공되지 않습니다.
  직접 비교 이외의 중복된 NEW_TOKEN 프레임
  프레임 내용.

* PING 및 PADDING 프레임에는 정보가 없으므로 PING 또는
  패딩 프레임은 수리할 필요가 없습니다.

* HANDSHAKE_DONE 프레임은 완료될 때까지 다시 전송되어야 합니다.
  인정됨.

엔드포인트는 새로운 데이터를 보내는 것보다 데이터 재전송을 우선시해야 합니다.
데이터는 애플리케이션에서 지정한 우선순위를 나타내지 않는 한
그렇지 않은 경우 섹션 2.3을 참조하세요.

발신자가 다음을 포함하는 프레임을 조립하도록 권장되더라도
패킷을 보낼 때마다 최신 정보를 전송하는 것은 금지되어 있지 않습니다.
손실된 패킷에서 프레임 사본을 다시 전송합니다. 보낸 사람이
프레임 사본을 재전송하려면 사용 가능한 프레임의 감소를 처리해야 합니다.
패킷 번호 길이, 연결 ID 변경으로 인한 페이로드 크기
길이 및 경로 MTU. 수신기는 다음을 포함하는 패킷을 수락해야 합니다.
더 작은 최대값을 갖는 MAX_DATA 프레임과 같은 오래된 프레임
이전 패킷에서 발견된 것보다 데이터 값이 더 큽니다.

발신자는 패킷에서 정보를 다시 전송하지 않아야 합니다.
확인됩니다. 여기에는 확인된 패킷이 포함됩니다.
분실 신고 후, 이는 다음과 같은 상황에서 발생할 수 있습니다.
네트워크 재정렬. 이를 위해서는 발신자가 정보를 보관해야 합니다.
패킷이 손실되었다고 선언된 후 패킷에 대해. 보낸 사람은 패킷을 삭제할 수 있습니다.
이 정보는 일정 시간이 경과한 후에 적절하게
PTO(섹션 6.2)와 같은 재주문을 허용합니다.
[QUIC-RECOVERY]), 또는 메모리 도달과 같은 다른 이벤트를 기반으로
한계.

손실을 감지하면 발신자는 적절한 혼잡을 취해야 합니다.
제어 조치. 손실 감지 및 혼잡 제어에 대한 세부 정보
[QUIC-RECOVERY]에 설명되어 있습니다.

13.4. 명시적 혼잡 알림

QUIC 엔드포인트는 ECN[RFC3168]을 사용하여 네트워크를 감지하고 응답할 수 있습니다.
혼잡. ECN을 사용하면 엔드포인트가 ECN 지원 전송을 설정할 수 있습니다.
IP 패킷의 ECN 필드에 있는 (ECT) 코드포인트. 네트워크 노드는
그런 다음 ECN에서 ECN-CE 코드포인트를 설정하여 혼잡을 표시합니다.
패킷을 삭제하는 대신 필드[RFC8087]. 엔드포인트는 다음에 반응합니다.
응답으로 전송 속도를 줄여 혼잡을 보고했습니다.
[QUIC-RECOVERY]에 설명되어 있습니다.

ECN을 활성화하려면 전송 QUIC 엔드포인트가 먼저 다음을 결정합니다.
경로가 ECN 표시를 지원하고 피어가 ECN 값을 보고하는지 여부
수신된 IP 헤더에서; 섹션 13.4.2를 참조하세요.

13.4.1. ECN 수 보고

ECN을 사용하려면 수신 엔드포인트에서 ECN 필드를 읽어야 합니다.
모든 플랫폼에서 가능한 것은 아닌 IP 패킷에서.
엔드포인트는 ECN 지원을 구현하지 않거나 액세스할 수 없습니다.
수신된 ECN 필드에서는 패킷에 대한 ECN 수를 보고하지 않습니다.
받습니다.

엔드포인트가 전송하는 패킷에 ECT 필드를 설정하지 않더라도,
엔드포인트는 수신한 ECN 표시에 대한 피드백을 제공해야 합니다.
이러한 항목은 접근 가능합니다. ECN 수를 보고하지 않으면
발신자가 이 연결에 대해 ECN 사용을 비활성화하도록 요청합니다.

ECT(0), ECT(1) 또는 ECN-CE가 포함된 IP 패킷을 수신할 때
코드포인트, ECN 지원 엔드포인트는 ECN 필드에 액세스합니다.
해당 ECT(0), ECT(1) 또는 ECN-CE 카운트를 증가시킵니다.
ECN 수는 후속 ACK 프레임에 포함됩니다. 섹션 13.2를 참조하세요.
그리고 19.3.

각 패킷 번호 공간은 별도의 확인 상태를 유지합니다.
별도의 ECN 카운트. 병합된 QUIC 패킷(섹션 12.2 참조) 공유
동일한 IP 헤더이므로 ECN 수는 각각 한 번씩 증가합니다.
병합된 QUIC 패킷.

예를 들어, Initial, Handshake 및 1-RTT QUIC 중 각각 하나가 있는 경우
패킷은 단일 UDP 데이터그램으로 통합되며 ECN은 다음을 계산합니다.
세 개의 패킷 번호 공간 모두 각각 하나씩 증가합니다.
단일 IP 헤더의 ECN 필드에 있습니다.

ECN 수는 수신된 QUIC 패킷이 있을 때만 증가합니다.
IP 패킷이 처리됩니다. 따라서 중복된 QUIC 패킷은 처리되지 않습니다.
처리되고 ECN 수가 증가하지 않습니다. 자세한 내용은 섹션 21.10을 참조하세요.
관련 보안 문제.

13.4.2. ECN 검증

결함이 있는 네트워크 장치는 손상되거나 잘못 작동할 수 있습니다.
0이 아닌 ECN 코드포인트를 전달하는 패킷을 삭제합니다.
이러한 장치가 있는 경우 연결성을 확인하려면 엔드포인트를 확인합니다.
ECN은 각 네트워크 경로에 대해 계산되며 ECN 사용을 비활성화합니다.
오류가 감지되면 해당 경로로 이동합니다.

새 경로에 대한 ECN 검증을 수행하려면:

* 엔드포인트는 초기 IP 헤더에 ECT(0) 코드포인트를 설정합니다.
  피어에게 새로운 경로로 전송되는 발신 패킷[RFC8311].

* 엔드포인트는 ECT와 함께 전송된 모든 패킷이 전송되는지 여부를 모니터링합니다.
  코드 포인트는 결국 손실된 것으로 간주됩니다(섹션 6)
  [QUIC-RECOVERY])는 ECN 검증에 실패했음을 나타냅니다.

엔드포인트가 ECT가 포함된 IP 패킷을 예상할 수 있는 원인이 있는 경우
코드 포인트는 잘못된 네트워크 요소, 엔드포인트에 의해 삭제될 수 있습니다.
첫 번째 10개의 나가는 패킷에 대해서만 ECT 코드포인트를 설정할 수 있습니다.
경로 또는 3개의 PTO 기간 동안(섹션 6.2 참조)
[QUIC-RECOVERY]). 0이 아닌 ECN 코드포인트로 표시된 모든 패킷이 있는 경우
이후에 손실되면 표시를 비활성화할 수 있습니다.
표시로 인해 손실이 발생했습니다.

따라서 엔드포인트는 ECN을 사용하려고 시도하고 각각의 새 항목에 대해 이를 검증합니다.
연결, 서버의 기본 주소로 전환할 때 및
활성 연결을 새 경로로 마이그레이션합니다. 부록 A.4에서 설명합니다.
가능한 알고리즘 중 하나.

ECN 지원 경로를 조사하는 다른 방법도 가능합니다.
다양한 마킹 전략이 있습니다. 구현 시 다른 방법을 사용할 수 있습니다.
RFC에 정의되어 있습니다. [RFC8311]을 참조하세요. ECT(1)을 사용하는 구현
코드포인트는 보고된 ECT(1)를 사용하여 ECN 검증을 수행해야 합니다.
카운트합니다.

13.4.2.1. ECN 카운트가 포함된 ACK 프레임 수신

네트워크에서 ECN-CE 표시를 잘못 적용하면 다음과 같은 결과가 발생할 수 있습니다.
연결 성능이 저하되었습니다. ACK를 수신하는 엔드포인트
따라서 ECN 카운트가 있는 프레임은 사용하기 전에 카운트를 검증합니다.
그것들. 새로 수신된 카운트를 비교하여 이 검증을 수행합니다.
마지막으로 성공적으로 처리된 ACK 프레임의 ACK 프레임과 비교합니다.
ECN 수의 증가는 ECN 표시를 기준으로 검증됩니다.
ACK에서 새로 확인된 패킷에 적용된
액자.

ACK 프레임이 엔드포인트가 보낸 패킷을 새롭게 확인하는 경우
ECT(0) 또는 ECT(1) 코드포인트가 설정된 경우 ECN 유효성 검사가 실패합니다.
ACK 프레임에 해당 ECN 카운트가 없는 경우.
이 검사는 ECN 필드를 0으로 만드는 네트워크 요소를 감지합니다.
ECN 표시를 보고하지 않는 피어입니다.

ECT(0)의 증가와 합이 같으면 ECN 검증도 실패합니다.
ECN-CE 카운트는 새로 확인된 패킷 수보다 적습니다.
원래 ECT(0) 표시가 있는 ECN
ECT(1) 및 ECN-CE의 증가 합계가 0이면 검증이 실패합니다.
카운트는 새로 확인된 패킷의 수보다 적습니다.
ECT(1) 표시가 있는 경우 이러한 검사를 통해 ECN-CE의 재표시를 감지할 수 있습니다.
네트워크에 의한 표시.

ACK 프레임이 있는 경우 엔드포인트는 패킷에 대한 확인을 놓칠 수 있습니다.
손실됩니다. 따라서 ECT(0)의 총 증가가 가능합니다.
ECT(1) 및 ECN-CE는 패킷 수보다 더 큰 것으로 계산됩니다.
ACK 프레임에 의해 새롭게 확인된 것입니다. 이것이 ECN이 중요한 이유입니다.
패킷의 총 수보다 클 수 있습니다.
인정됨.

재정렬된 ACK 프레임에서 ECN 카운트를 검증하면 다음과 같은 결과가 발생할 수 있습니다.
실패. 엔드포인트는 다음으로 인해 ECN 유효성 검사에 실패해서는 안 됩니다.
가장 큰 값을 증가시키지 않는 ACK 프레임을 처리합니다.
확인된 패킷 번호.

ECT(0)에 대한 수신된 총 개수가 0인 경우 ECN 검증이 실패할 수 있습니다.
또는 ECT(1)이 각각 전송된 패킷의 총 수를 초과합니다.
해당 ECT 코드포인트. 특히 유효성 검사가 실패합니다.
엔드포인트가 0이 아닌 ECN 카운트를 수신하는 경우
ECT 코드포인트가 적용되지 않았습니다. 이 검사는 패킷이
네트워크의 ECT(0) 또는 ECT(1)에 기록됩니다.

13.4.2.2. ECN 검증 결과

유효성 검사가 실패하면 엔드포인트는 ECN을 비활성화해야 합니다.
IP 패킷에 ECT 코드포인트를 설정하여 전송합니다.
네트워크 경로나 피어가 ECN을 지원하지 않습니다.

유효성 검사에 실패하더라도 엔드포인트는 동일한 ECN을 다시 유효성 검사할 수 있습니다.
연결의 이후 어느 시점에서든 경로가 변경됩니다. 엔드포인트는 계속될 수 있습니다.
주기적으로 검증을 시도합니다.

성공적인 검증 후 엔드포인트는 ECT를 계속 설정할 수 있습니다.
이후 패킷에 코드포인트가 추가될 것으로 예상합니다.
경로는 ECN을 지원합니다. 네트워크 라우팅 및 경로 요소는 다음과 같습니다.
연결 중간에 변경합니다. 유효성 검사가 수행되는 경우 엔드포인트는 ECN을 비활성화해야 합니다.
나중에 실패합니다.

14. 데이터그램 크기

UDP 데이터그램에는 하나 이상의 QUIC 패킷이 포함될 수 있습니다. 데이터그램
크기는 단일 UDP 데이터그램의 총 UDP 페이로드 크기를 나타냅니다.
QUIC 패킷을 전달합니다. 데이터그램 크기에는 하나 이상의 QUIC 패킷이 포함됩니다.
패킷 헤더와 보호된 페이로드는 허용되지만 UDP나 IP 헤더는 허용되지 않습니다.

최대 데이터그램 크기는 UDP의 가장 큰 크기로 정의됩니다.
단일 UDP를 사용하여 네트워크 경로를 통해 전송할 수 있는 페이로드
데이터그램. 네트워크 경로가 데이터그램을 지원할 수 없는 경우 QUIC를 사용해서는 안 됩니다.
최소 1200바이트의 최대 데이터그램 크기.

QUIC은 최소 1280바이트의 IP 패킷 크기를 가정합니다.
IPv6 최소 크기[IPv6]이며 대부분의 최신 버전에서도 지원됩니다.
IPv4 네트워크. 최소 IP 헤더 크기를 40바이트로 가정합니다.
IPv6 및 IPv4의 경우 20바이트, UDP 헤더 크기는 8바이트입니다.
IPv6의 경우 최대 데이터그램 크기는 1232바이트이고 IPv6의 경우 최대 데이터그램 크기는 1252바이트입니다.
IPv4의 경우 바이트입니다. 따라서 최신 IPv4 및 모든 IPv6 네트워크 경로는
QUIC를 지원할 수 있을 것으로 예상됩니다.

      | 참고: 이 요구 사항은 1200바이트의 UDP 페이로드를 지원해야 합니다.
      | IPv6 확장 헤더에 사용 가능한 공간을 32로 제한합니다.
      | 경로가 다음을 지원하는 경우 바이트 또는 IPv4 옵션을 52바이트로 설정합니다.
      | IPv6 최소 MTU는 1280바이트입니다. 이는 초기 패킷에 영향을 미칩니다.
      | 및 경로 검증.

1200바이트보다 큰 최대 데이터그램 크기를 검색할 수 있습니다.
PMTUD(Path Maximum Transmission Unit Discovery) 사용(참조
섹션 14.2.1) 또는 데이터그램 패킷화 계층 PMTU 검색
(DPLPMTUD) (섹션 14.3 참조).

max_udp_payload_size 전송 매개변수 적용
(섹션 18.2)는 최대값에 대한 추가 제한으로 작용할 수 있습니다.
데이터그램 크기. 발신자는 이 제한을 초과하지 않도록 할 수 있습니다.
값은 알려져 있습니다. 그러나 값을 배우기 전에
전송 매개변수, 엔드포인트는 데이터그램을 보낼 경우 손실될 위험이 있습니다.
허용되는 최소 최대 데이터그램 크기보다 큰 데이터그램
1200바이트.

UDP 데이터그램은 IP 계층에서 조각화되어서는 안 됩니다. IPv4에서는
[IPv4] 가능한 경우 DF(Don't Fragment) 비트를 설정해야 합니다.
경로의 단편화를 방지합니다.

QUIC에서는 때때로 데이터그램이 특정 크기보다 작지 않아야 합니다.
크기; 8.1절을 예로 들어 보겠습니다. 그러나 데이터그램의 크기는
인증되지 않았습니다. 즉, 엔드포인트가 데이터그램을 수신하는 경우
특정 크기에서는 송신자가 데이터그램을 보냈다는 것을 알 수 없습니다.
동일한 크기입니다. 따라서 엔드포인트는 연결을 닫아서는 안 됩니다.
크기 제한을 충족하지 않는 데이터그램을 수신하는 경우
엔드포인트는 이러한 데이터그램을 삭제할 수 있습니다.

14.1. 초기 데이터그램 크기

클라이언트는 모든 UDP 데이터그램의 페이로드를 확장해야 합니다.
최소 허용 최대 데이터그램까지의 초기 패킷
초기 패킷에 PADDING 프레임을 추가하여 1200바이트 크기 또는
초기 패킷을 병합하여; 섹션 12.2. 초기 패킷을 참조하세요.
수신기가 잘못된 패킷과 병합할 수도 있습니다.
삭제합니다. 마찬가지로 서버는 모든 UDP의 페이로드를 확장해야 합니다.
최소한 ACK 유도 초기 패킷을 전달하는 데이터그램
허용되는 최소 최대 데이터그램 크기는 1200바이트입니다.

이 크기의 UDP 데이터그램을 보내면 네트워크 경로가 보장됩니다.
두 가지 모두에서 합리적인 경로 최대 전송 단위(PMTU)를 지원합니다.
방향. 또한 초기 패킷을 확장하는 클라이언트
서버로 인한 증폭 공격의 진폭을 줄이는 데 도움이 됩니다.
확인되지 않은 클라이언트 주소에 대한 응답; 섹션 8을 참조하세요.

초기 패킷을 포함하는 데이터그램은 다음과 같은 경우 1200바이트를 초과할 수 있습니다.
발신자는 네트워크 경로와 피어가 모두 크기를 지원한다고 믿습니다.
그것이 선택한다는 것입니다.

서버는 UDP에서 전송되는 초기 패킷을 삭제해야 합니다.
허용된 최소값보다 작은 페이로드를 갖는 데이터그램
최대 데이터그램 크기는 1200바이트입니다. 서버는 또한 즉시
CONNECTION_CLOSE 프레임을 보내어 연결을 닫습니다.
PROTOCOL_VIOLATION 오류 코드; 섹션 10.2.3을 참조하세요.

서버는 또한 전송하기 전에 보내는 바이트 수를 제한해야 합니다.
클라이언트 주소 검증; 섹션 8 참조.

14.2. 경로 최대 전송 단위

PMTU는 다음을 포함한 전체 IP 패킷의 최대 크기입니다.
IP 헤더, UDP 헤더 및 UDP 페이로드. UDP 페이로드에는 다음이 포함됩니다.
또는 더 많은 QUIC 패킷 헤더와 보호된 페이로드. PMTU는
경로 특성에 따라 달라지므로 시간이 지남에 따라 변경될 수 있습니다.
엔드포인트가 주어진 시간에 보내는 가장 큰 UDP 페이로드는 다음과 같습니다.
엔드포인트의 최대 데이터그램 크기라고 합니다.

엔드포인트는 DPLPMTUD(섹션 14.3) 또는 PMTUD를 사용해야 합니다.
(섹션 14.2.1) 목적지까지의 경로가 올바른지 여부를 확인하려면
조각화 없이 원하는 최대 데이터그램 크기를 지원합니다.
이러한 메커니즘이 없으면 QUIC 엔드포인트는 보내서는 안 됩니다.
허용되는 가장 작은 최대 데이터그램 크기보다 큰 데이터그램입니다.

DPLPMTUD와 PMTUD는 모두 다음보다 큰 데이터그램을 보냅니다.
현재 최대 데이터그램 크기(PMTU 프로브라고 함). 모든 QUIC
PMTU 프로브에서 전송되지 않은 패킷은 크기가 조정되어야 합니다.
데이터그램이 최대 크기 내에서 전송되지 않도록 합니다.
조각화되거나 삭제됨[RFC8085].

QUIC 엔드포인트가 로컬 쌍 사이의 PMTU를 결정하는 경우
원격 IP 주소는 허용되는 가장 작은 최대값을 지원할 수 없습니다.
데이터그램 크기가 1200바이트인 경우 QUIC 전송을 즉시 중단해야 합니다.
PMTU 프로브에 있는 패킷이나 다음을 포함하는 패킷을 제외한 패킷
영향을 받는 경로에서 CONNECTION_CLOSE 프레임. 엔드포인트는
대체 경로를 찾을 수 없는 경우 연결을 종료합니다.

로컬 주소와 원격 주소의 각 쌍은 서로 다른 PMTU를 가질 수 있습니다.
모든 종류의 PMTU 검색을 구현하는 QUIC 구현
따라서 각 데이터그램의 최대 크기를 유지해야 합니다.
로컬 및 원격 IP 주소의 조합.

QUIC 구현은 계산에 있어 더 보수적일 수 있습니다.
알 수 없는 터널 오버헤드 또는 IP를 허용하기 위한 최대 데이터그램 크기
헤더 옵션/확장자.

14.2.1. PMTUD에 의한 ICMP 메시지 처리

PMTUD [RFC1191] [RFC8201]은 ICMP 메시지 수신에 의존합니다.
즉, IP 패킷이 너무 큰 경우(PTB)를 나타내는 IPv6 메시지입니다.
패킷은 로컬 라우터 MTU보다 크기 때문에 삭제됩니다.
DPLPMTUD는 선택적으로 이러한 메시지를 사용할 수도 있습니다. ICMP를 사용하는 경우
메시지는 잠재적으로 다음과 같은 엔터티의 공격에 취약합니다.
패킷을 관찰하지만 사용된 주소를 성공적으로 추측할 수 있습니다.
경로. 이러한 공격은 PMTU를 대역폭으로 줄일 수 있습니다.
비효율적인 가치.

엔드포인트는 PMTU가 있다고 주장하는 ICMP 메시지를 무시해야 합니다.
QUIC에서 허용하는 가장 작은 최대 데이터그램 크기보다 작아졌습니다.

ICMP 생성을 위한 요구 사항[RFC1812] [RFC4443]은 다음을 명시합니다.
인용된 패킷에는 원본 패킷의 내용이 그대로 포함되어야 합니다.
IP 버전의 최소 MTU를 초과하지 않고도 가능합니다.
인용된 패킷의 크기는 실제로 더 작을 수 있습니다. 또는 정보
[DPLPMTUD]의 섹션 1.1에 설명된 대로 이해할 수 없습니다.

PMTUD를 사용하는 QUIC 엔드포인트는 ICMP 메시지를 검증하여 보호해야 합니다.
[RFC8201] 및 섹션 5.2에 지정된 패킷 주입으로부터
[RFC8085]. 이 검증은 제공된 인용 패킷을 사용해야 합니다.
ICMP 메시지의 페이로드를 메시지와 연관시키기 위해
해당 전송 연결([DPLPMTUD]의 섹션 4.6.1 참조).
ICMP 메시지 검증에는 일치하는 IP 주소와 UDP가 포함되어야 합니다.
포트[RFC8085] 및 가능한 경우 활성 QUIC에 대한 연결 ID
세션. 엔드포인트는 실패한 모든 ICMP 메시지를 무시해야 합니다.
확인.

엔드포인트는 ICMP 메시지를 기반으로 PMTU를 증가시켜서는 안 됩니다.
[DPLPMTUD] 섹션 3의 항목 6. QUIC의 최대값 감소
ICMP 메시지에 대한 응답으로 데이터그램 크기가 임시적일 수 있습니다.
QUIC의 손실 감지 알고리즘은 인용된 패킷이 다음과 같은지 확인합니다.
실제로 분실되었습니다.

14.3. 데이터그램 패킷화 계층 PMTU 검색

DPLPMTUD [DPLPMTUD]는 QUIC의 손실 또는 확인 추적에 의존합니다.
PMTU 프로브에서 전송되는 패킷. DPLPMTUD용 PMTU 프로브
PADDING 프레임을 사용하여 "패딩 데이터를 사용하여 프로빙"을 구현합니다.
[DPLPMTUD]의 섹션 4.1에 정의되어 있습니다.

엔드포인트는 BASE_PLPMTU의 초기 값을 설정해야 합니다(섹션 5.1)
[DPLPMTUD])는 QUIC의 최소 허용 최대값과 일치하도록 합니다.
데이터그램 크기입니다. MIN_PLPMTU는 BASE_PLPMTU와 같습니다.

DPLPMTUD를 구현하는 QUIC 엔드포인트는 DPLPMTUD 최대값을 유지합니다.
각 조합에 대한 패킷 크기(MPS)([DPLPMTUD]의 섹션 4.4)
로컬 및 원격 IP 주소입니다. 이는 최대값에 해당합니다.
데이터그램 크기.

14.3.1. DPLPMTUD 및 초기 연결

DPLPMTUD의 관점에서 QUIC는 인정됩니다.
패킷화 계층(PL). 따라서 QUIC 송신자는 다음을 입력할 수 있습니다.
QUIC가 DPLPMTUD BASE 상태([DPLPMTUD]의 섹션 5.2)일 때
연결 핸드셰이크가 완료되었습니다.

14.3.2. DPLPMTUD를 사용하여 네트워크 경로 검증

QUIC는 확인된 PL이므로 QUIC 발신자는
SEARCH_COMPLETE 중에 DPLPMTUD CONFIRMATION_TIMER를 구현합니다.
상태; [DPLPMTUD]의 섹션 5.2를 참조하세요.

14.3.3. DPLPMTUD에 의한 ICMP 메시지 처리

DPLPMTUD를 사용하는 엔드포인트에는 수신된 모든 유효성 검사가 필요합니다.
PTB 정보를 사용하기 전 ICMP PTB 메시지는 다음과 같습니다.
[DPLPMTUD]의 섹션 4.6. UDP 포트 유효성 검사 외에도 QUIC
다른 PL 정보(예:)를 사용하여 ICMP 메시지를 검증합니다.
수신된 모든 패킷의 인용된 연결 ID 검증
ICMP 메시지).

ICMP 메시지 처리를 위한 고려 사항은 다음과 같습니다.
이러한 메시지가 DPLPMTUD에서 사용되는 경우에도 섹션 14.2.1이 적용됩니다.

14.4. QUIC PMTU 프로브 보내기

PMTU 프로브는 ack를 유도하는 패킷입니다.

엔드포인트는 PMTU 프로브의 내용을 PING 및 PADDING으로 제한할 수 있습니다.
프레임은 현재 최대 크기보다 큰 패킷이기 때문에
데이터그램 크기가 네트워크에서 삭제될 가능성이 더 높습니다. 손실
따라서 PMTU 프로브에서 전송되는 QUIC 패킷은 아닙니다.
혼잡의 신뢰할 수 있는 표시이며 혼잡을 유발해서는 안 됩니다.
제어 반응; [DPLPMTUD] 섹션 3의 항목 7을 참조하세요. 그러나,
PMTU 프로브는 혼잡 창을 소모하여 후속 작업을 지연시킬 수 있습니다.
애플리케이션을 통한 전송.

14.4.1. 소스 연결 ID를 포함하는 PMTU 프로브

대상 연결 ID 필드에 의존하는 엔드포인트
들어오는 QUIC 패킷을 라우팅하려면 다음이 필요할 가능성이 있습니다.
결과 ICMP를 라우팅하기 위해 PMTU 프로브에 연결 ID를 포함해야 합니다.
메시지(섹션 14.2.1)를 올바른 엔드포인트로 다시 보냅니다. 그러나
긴 헤더 패킷(섹션 17.2)에만 소스 연결이 포함됩니다.
ID 필드 및 긴 헤더 패킷은 복호화되거나 확인되지 않습니다.
핸드셰이크가 완료되면 동료가 이를 수락합니다.

PMTU 프로브를 구성하는 한 가지 방법은 다음을 병합하는 것입니다(섹션 12.2 참조)
핸드셰이크나 0-RTT 패킷과 같이 긴 헤더가 있는 패킷
(섹션 17.2) 단일 UDP 데이터그램에 짧은 헤더 패킷이 포함되어 있습니다.
결과 PMTU 프로브가 엔드포인트에 도달하면 패킷은
긴 헤더는 무시되지만 짧은 헤더 패킷은 무시됩니다.
확인됨. PMTU 프로브로 인해 ICMP 메시지가 전송되는 경우
프로브의 첫 번째 부분은 해당 메시지에 인용됩니다.
소스 연결 ID 필드는 프로브의 인용된 부분 내에 있습니다.
ICMP 메시지의 라우팅이나 검증에 사용될 수 있습니다.

      | 참고: 긴 헤더가 있는 패킷을 사용하는 목적은 다음과 같습니다.
      | ICMP 메시지에 포함된 인용 패킷을 보장합니다.
      | 소스 연결 ID 필드가 포함되어 있습니다. 이 패킷은
      | 유효한 패킷이어야 하며, 다음과 같은 경우에도 전송될 수 있습니다.
      | 해당 유형의 패킷은 현재 사용되지 않습니다.

15. 버전

QUIC 버전은 32비트 부호 없는 숫자를 사용하여 식별됩니다.

버전 0x00000000은 버전 협상을 나타내기 위해 예약되어 있습니다.
이 사양의 버전은 번호로 식별됩니다.
0x00000001.

다른 버전의 QUIC는 이와 다른 속성을 가질 수 있습니다.
버전. 일관성이 보장되는 QUIC의 속성
모든 버전의 프로토콜에 대해 설명되어 있습니다.
[빠른 불변성].

QUIC의 버전 0x00000001은 암호화 핸드셰이크로 TLS를 사용합니다.
[QUIC-TLS]에 설명된 대로 프로토콜입니다.

버전 번호의 최상위 16비트를 포함하는 버전
지워진 내용은 향후 IETF 합의 문서에서 사용하기 위해 예약되어 있습니다.

0x?a?a?a?a 패턴을 따르는 버전은 다음에서 사용하도록 예약되어 있습니다.
버전 협상을 강제로 실행해야 함 -- 즉, 모든 버전
모든 바이트의 하위 4비트가 1010(2진수)인 숫자입니다. A
클라이언트 또는 서버는 이러한 예약된 항목에 대한 지원을 광고할 수 있습니다.
버전.

예약된 버전 번호는 실제 프로토콜을 나타내지 않습니다.
클라이언트는 다음 버전 번호 중 하나를 사용할 수 있습니다.
서버는 버전 협상을 시작합니다. 서버는 광고할 수 있습니다.
이러한 버전 중 하나에 대한 지원을 받을 수 있으며 클라이언트가 무시할 것으로 예상할 수 있습니다.
가치.

16. 가변 길이 정수 인코딩

QUIC 패킷과 프레임은 일반적으로 가변 길이 인코딩을 사용합니다.
음이 아닌 정수 값. 이 인코딩은 더 작은
정수 값은 인코딩하는 데 더 적은 바이트가 필요합니다.

QUIC 가변 길이 정수 인코딩은 가장 많은 두 가지를 예약합니다.
2진 로그를 인코딩하기 위한 첫 번째 바이트의 유효 비트
정수 인코딩 길이(바이트). 정수 값은 인코딩됩니다.
나머지 비트는 네트워크 바이트 순서로 정렬됩니다.

이는 정수가 1, 2, 4 또는 8바이트로 인코딩되고
각각 6, 14, 30 또는 62비트 값을 인코딩합니다. 표 4
인코딩 속성을 요약합니다.

          +======+========+=============+========================+====================+
          | 2MSB | 길이 | 사용 가능 비트 | 범위 |
          +======+========+=============+========================+====================+
          | 00 | 1 | 6 | 0-63 |
          +-----+--------+-------------+-------------+
          | 01 | 2 | 14 | 0-16383 |
          +-----+--------+-------------+-------------+
          | 10 | 4 | 30 | 0-1073741823 |
          +-----+--------+-------------+-------------+
          | 11 | 8 | 62 | 0-4611686018427387903 |
          +-----+--------+-------------+-------------+

                   표 4: 정수 인코딩 요약

디코딩 알고리즘과 샘플 인코딩의 예는 다음과 같습니다.
부록 A.1.

값은 최소 바이트 수로 인코딩될 필요가 없습니다.
프레임 유형 필드만 제외하고 필요합니다.
섹션 12.4.

버전(섹션 15), 헤더에 전송된 패킷 번호
(섹션 17.1) 및 긴 헤더의 연결 ID 길이
패킷(섹션 17.2)은 정수를 사용하여 설명되지만 사용하지 않습니다.
이 인코딩.

17. 패킷 포맷

모든 숫자 값은 네트워크 바이트 순서(즉, 큰 바이트 순서)로 인코딩됩니다.
엔디안)이며 모든 필드 크기는 비트 단위입니다. 16진수 표기법은 다음과 같습니다.
필드의 값을 설명하는 데 사용됩니다.

17.1. 패킷 번호 인코딩 및 디코딩

패킷 번호는 0~2^62-1 범위의 정수입니다(섹션 12.3).
긴 패킷 헤더나 짧은 패킷 헤더에 존재하는 경우 1로 인코딩됩니다.
최대 4바이트. 패킷을 표현하는 데 필요한 비트 수
최하위 비트만 포함하면 숫자가 줄어듭니다.
패킷 번호.

인코딩된 패킷 번호는 섹션 5.4에 설명된 대로 보호됩니다.
[빠른 TLS].

패킷 번호 공간에 대한 확인을 받기 전에
전체 패킷 번호는 반드시 포함되어야 합니다. 잘라내서는 안 됩니다.
아래에 설명되어 있습니다.

패킷 번호 공간에 대한 확인이 수신된 후
발신자는 다음을 나타낼 수 있는 패킷 번호 크기를 사용해야 합니다.
가장 큰 차이의 두 배 더 큰 범위
확인된 패킷 번호와 전송되는 패킷 번호. 피어
패킷을 수신하면 패킷 번호가 올바르게 디코딩됩니다.
패킷이 전송 중에 지연되어 도착하지 않는 한
더 높은 번호의 패킷이 많이 수신되었습니다. 엔드포인트는 다음을 수행해야 합니다.
패킷 번호를 허용할 만큼 충분히 큰 패킷 번호 인코딩을 사용합니다.
패킷이 도착한 후에 패킷이 도착하더라도 복구할 수 없습니다.
나중에 보냈습니다.

결과적으로 패킷 번호 인코딩의 크기는 최소한 1입니다.
연속된 숫자의 밑이 2인 로그보다 약간 더 큽니다.
새로운 패킷을 포함한 확인되지 않은 패킷 번호. 의사코드
패킷 번호 인코딩에 대한 예는 다음에서 찾을 수 있습니다.
부록 A.2.

수신기에서는 패킷 번호 보호가 제거됩니다.
전체 패킷 번호를 복구합니다. 그러면 전체 패킷 번호는 다음과 같습니다.
존재하는 유효 비트 수를 기준으로 재구성됨
해당 비트의 값과 수신된 가장 큰 패킷 번호
성공적으로 인증된 패킷입니다. 전체 패킷 번호를 복구합니다.
패킷 제거를 성공적으로 완료하려면 필요합니다.
보호.

헤더 보호가 제거되면 패킷 번호는 다음과 같이 디코딩됩니다.
다음 예상 값에 가장 가까운 패킷 번호 값을 찾는 중
패킷. 다음으로 예상되는 패킷은 수신된 패킷 중 가장 높은 패킷입니다.
숫자 더하기 1. 패킷 번호에 대한 의사 코드 및 예
디코딩은 부록 A.3에서 확인할 수 있습니다.

17.2. 긴 헤더 패킷

긴 헤더 패킷 {
헤더 양식(1) = 1,
고정 비트(1) = 1,
긴 패킷 유형(2),
유형별 비트(4),
버전(32),
대상 연결 ID 길이(8),
대상 연결 ID(0..160),
소스 연결 ID 길이(8),
소스 연결 ID(0..160),
유형별 탑재체(..),
}

                    그림 13: 긴 헤더 패킷 형식

긴 헤더는 이전에 전송된 패킷에 사용됩니다.
1-RTT 키 설정. 1-RTT 키가 사용 가능해지면 발신자는
짧은 헤더를 사용하여 패킷을 전송하도록 전환합니다(섹션 17.3).
긴 형식은 버전과 같은 특수 패킷을 허용합니다.
협상 패킷 - 이 균일한 고정 길이로 표현됩니다.
패킷 형식입니다. 긴 헤더를 사용하는 패킷에는 다음이 포함됩니다.
다음 필드:

헤더 형식: 바이트 0의 가장 중요한 비트(0x80)(첫 번째
긴 헤더의 경우 바이트는 1로 설정됩니다.

고정 비트: 바이트 0의 다음 비트(0x40)는 1로 설정됩니다.
패킷은 버전 협상 패킷입니다. 0을 포함하는 패킷
이 비트의 값은 이 버전에서는 유효한 패킷이 아니며 반드시 유효해야 합니다.
삭제됩니다. 이 비트의 값이 1이면 QUIC이 공존할 수 있습니다.
다른 프로토콜과 함께; [RFC7983]을 참조하세요.

긴 패킷 유형: 다음 두 비트(0x30 마스크가 있는 비트)
바이트 0에는 패킷 유형이 포함됩니다. 패킷 유형은 표 5에 나열되어 있습니다.

유형별 비트: 하위 4비트(다음이 포함된 비트)의 의미
바이트 0의 마스크(0x0f)는 패킷 유형에 따라 결정됩니다.

버전: QUIC 버전은 첫 번째 다음에 오는 32비트 필드입니다.
바이트. 이 필드는 사용 중인 QUIC 버전을 나타냅니다.
나머지 프로토콜 필드가 어떻게 해석되는지 결정합니다.

대상 연결 ID 길이: 버전 뒤에 오는 바이트
대상 연결 ID의 길이(바이트)를 포함합니다.
그 뒤에 오는 필드입니다. 이 길이는 8비트로 인코딩됩니다.
부호 없는 정수. QUIC 버전 1에서는 이 값이 다음을 초과해서는 안 됩니다.
20바이트. 버전 1 긴 헤더를 수신하는 엔드포인트
20보다 큰 값은 패킷을 삭제해야 합니다. 제대로
버전 협상 패킷을 형성하면 서버는 다음을 읽을 수 있어야 합니다.
다른 QUIC 버전보다 더 긴 연결 ID.

대상 연결 ID: 대상 연결 ID 필드
대상 연결 ID 길이 필드 다음에 옵니다.
이 필드의 길이를 나타냅니다. 섹션 7.2에서는 사용법을 설명합니다.
이 분야에 대해 더 자세히 알아보세요.

소스 연결 ID 길이: 대상 뒤에 오는 바이트
연결 ID에는 소스의 바이트 길이가 포함됩니다.
그 뒤에 오는 연결 ID 필드입니다. 이 길이는 다음과 같이 인코딩됩니다.
8비트 부호 없는 정수. QUIC 버전 1에서는 이 값을 사용할 수 없습니다.
20바이트를 초과합니다. 버전 1 긴 헤더를 수신하는 엔드포인트
20보다 큰 값을 갖는 패킷은 반드시 삭제되어야 합니다.
버전 협상 패킷을 적절하게 형성하려면 서버가 다음을 수행해야 합니다.
다른 QUIC 버전에서 더 긴 연결 ID를 읽으려면.

소스 연결 ID: 소스 연결 ID 필드는 다음에 나옵니다.
소스 연결 ID 길이 필드는 길이를 나타냅니다.
이 필드. 섹션 7.2에서는 이 필드의 사용에 대해 자세히 설명합니다.
세부 사항.

유형별 페이로드: 패킷의 나머지 부분(있는 경우)은 유형입니다.
특정한.

이 QUIC 버전에서는 긴 패킷 유형이 다음과 같습니다.
헤더는 다음과 같이 정의됩니다.

                   +======+===========+================+
                   | 유형 | 이름 | 섹션 |
                   +======+===========+================+
                   | 0x00 | 초기 | 섹션 17.2.2 |
                   +------+----------+----------------+
                   | 0x01 | 0-RTT | 섹션 17.2.3 |
                   +------+----------+----------------+
                   | 0x02 | 핸드셰이크 | 섹션 17.2.4 |
                   +------+----------+----------------+
                   | 0x03 | 재시도 | 섹션 17.2.5 |
                   +------+----------+----------------+

                     표 5: 긴 헤더 패킷 유형

헤더 형식 비트, 대상 및 소스 연결 ID 길이
대상 및 소스 연결 ID 필드와 버전 필드
긴 헤더 패킷은 버전과 무관합니다. 다른 필드는
첫 번째 바이트는 버전에 따라 다릅니다. 자세한 내용은 [QUIC-INVARIANTS]를 참조하세요.
다양한 버전의 QUIC 패킷이 어떻게 해석되는지에 대한 내용입니다.

필드와 페이로드의 해석은 특정합니다.
버전 및 패킷 유형. 이 유형에 대한 유형별 의미론은
다음 섹션에서는 버전에 대해 설명합니다. 긴 헤더가 여러 개 있습니다.
이 버전의 QUIC 패킷에는 다음과 같은 추가 필드가 포함되어 있습니다.

예약된 비트: 바이트 0의 두 비트(0x0c 마스크가 있는 비트)
여러 패킷 유형에 걸쳐 예약되어 있습니다. 이러한 비트는 보호됩니다.
헤더 보호 사용; [QUIC-TLS]의 섹션 5.4를 참조하세요. 값
보호 이전에 포함된 항목은 0으로 설정되어야 합니다. 엔드포인트는 반드시 0으로 설정되어야 합니다.
이러한 비트에 대해 0이 아닌 값을 갖는 패킷의 수신을 처리합니다.
패킷과 헤더 보호를 모두 연결로 제거한 후
PROTOCOL_VIOLATION 유형의 오류입니다. 이러한 패킷을 삭제합니다.
헤더 보호를 제거해야만 엔드포인트가 노출될 수 있습니다.
공격; [QUIC-TLS]의 섹션 9.5를 참조하세요.

패킷 번호 길이: 패킷 번호가 포함된 패킷 유형
필드, 최하위 2비트(마스크가 0x03인 비트)
바이트 0에는 패킷 번호 필드의 길이가 포함되어 있으며 인코딩됩니다.
길이보다 하나 작은 부호 없는 2비트 정수로
패킷 번호 필드(바이트). 즉, 패킷의 길이입니다.
패킷 번호 필드는 이 필드 값에 1을 더한 값입니다.
비트는 헤더 보호를 사용하여 보호됩니다. 섹션 5.4를 참조하세요.
[빠른 TLS].

길이: 이것은 패킷의 나머지 길이입니다(즉,
패킷 번호 및 페이로드 필드(바이트)로 인코딩됨
가변 길이 정수(섹션 16).

패킷 번호: 이 필드는 1~4바이트 길이입니다. 패킷 번호
헤더 보호를 사용하여 보호됩니다. 섹션 5.4를 참조하세요.
[QUIC-TLS]. 패킷 번호 필드의 길이는 다음과 같이 인코딩됩니다.
바이트 0의 패킷 번호 길이 비트; 위를 참조하세요.

패킷 페이로드: 이것은 패킷의 페이로드입니다.
패킷 보호를 사용하여 보호되는 프레임 시퀀스입니다.

17.2.1. 버전 협상 패킷

버전 협상 패킷은 본질적으로 버전에 따라 달라지지 않습니다.
클라이언트가 수신하면 버전으로 식별됩니다.
버전 필드 값이 0인 협상 패킷입니다.

버전 협상 패킷은 클라이언트 패킷에 대한 응답입니다.
서버에서 지원하지 않는 버전이 포함되어 있습니다.
서버에서 보냈습니다.

버전 협상 패킷의 레이아웃은 다음과 같습니다.

버전 협상 패킷 {
헤더 양식(1) = 1,
미사용(7),
버전(32) = 0,
대상 연결 ID 길이(8),
대상 연결 ID(0..2040),
소스 연결 ID 길이(8),
소스 연결 ID(0..2040),
지원 버전(32) ...,
}

                   그림 14: 버전 협상 패킷

Unused 필드의 값은 다음에 의해 임의의 값으로 설정됩니다.
서버. 클라이언트는 이 필드의 값을 무시해야 합니다. QUIC
다른 프로토콜과 다중화될 수 있습니다([RFC7983] 참조), 서버
이 필드의 가장 중요한 비트(0x40)를 1로 설정해야 합니다.
버전 협상 패킷에는 고정 비트 필드가 있는 것으로 보입니다. 참고
다른 버전의 QUIC에서는 이와 비슷한 권장 사항이 없을 수도 있습니다.

버전 협상 패킷의 버전 필드는 반드시 다음으로 설정되어야 합니다.
0x00000000.

서버는 소스 연결 ID 필드의 값을 포함해야 합니다.
대상 연결 ID 필드에서 수신한 패킷의.
소스 연결 ID 값은 다음에서 복사해야 합니다.
수신된 패킷의 대상 연결 ID(초기)
클라이언트에 의해 무작위로 선택됩니다. 두 연결 ID를 모두 에코하면
클라이언트는 서버가 패킷을 수신했다는 확신을 가질 수 있습니다.
버전 협상 패킷은 엔터티에 의해 생성되지 않았습니다.
초기 패킷을 관찰하지 못했습니다.

QUIC의 향후 버전에는 다른 요구 사항이 있을 수 있습니다.
연결 ID의 길이. 특히 연결 ID에는
더 작은 최소 길이 또는 더 큰 최대 길이. 버전-
따라서 연결 ID에 대한 특정 규칙은 영향을 미쳐서는 안 됩니다.
버전 협상 패킷을 보낼지 여부에 대한 결정.

버전 협상 패킷의 나머지 부분은 32비트 목록입니다.
서버가 지원하는 버전입니다.

버전 협상 패킷은 확인되지 않습니다.
지원되지 않는 버전을 나타내는 패킷에 대한 응답; 참조
섹션 5.2.2.

버전 협상 패킷에는 패킷 번호가 포함되어 있지 않습니다.
긴 헤더 형식을 사용하는 다른 패킷에 존재하는 길이 필드입니다.
결과적으로 버전 협상 패킷은 전체 UDP를 소모합니다.
데이터그램.

서버는 두 개 이상의 버전 협상 패킷을 보내서는 안 됩니다.
단일 UDP 데이터그램에 대한 응답.

버전 협상 프로세스에 대한 설명은 섹션 6을 참조하세요.

17.2.2. 초기 패킷

초기 패킷은 0x00의 유형 값을 갖는 긴 헤더를 사용합니다.
클라이언트와 서버가 보낸 첫 번째 CRYPTO 프레임을 전달합니다.
키 교환을 수행하고 양방향으로 ACK 프레임을 전달합니다.

초기 패킷 {
헤더 양식(1) = 1,
고정 비트(1) = 1,
긴 패킷 유형(2) = 0,
예약된 비트(2),
패킷 번호 길이(2),
버전(32),
대상 연결 ID 길이(8),
대상 연결 ID(0..160),
소스 연결 ID 길이(8),
소스 연결 ID(0..160),
토큰 길이(i),
토큰(..),
길이(i),
패킷 번호(8..32),
패킷 페이로드(8..),
}

                         그림 15: 초기 패킷

초기 패킷에는 길이와 함께 긴 헤더가 포함되어 있습니다.
패킷 번호 필드; 섹션 17.2를 참조하세요. 첫 번째 바이트에는 다음이 포함됩니다.
예약된 비트와 패킷 번호 길이 비트; 섹션 17.2도 참조하세요.
소스 연결 ID와 길이 필드 사이에는 두 가지가 있습니다.
초기 패킷에 특정한 추가 필드입니다.

토큰 길이: 토큰 길이를 지정하는 가변 길이 정수
토큰 필드(바이트). 토큰이 없으면 이 값은 0입니다.
서버에서 보낸 초기 패킷은 토큰 길이 필드를 설정해야 합니다.
0으로; 0이 아닌 토큰이 포함된 초기 패킷을 수신하는 클라이언트
길이 필드는 패킷을 삭제하거나 생성해야 합니다.
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

토큰: 이전에 제공된 토큰의 가치
패킷 또는 NEW_TOKEN 프레임을 다시 시도하세요. 섹션 8.1을 참조하세요.

버전을 인식하지 못하는 중간 상자의 변조를 방지하기 위해 Initial
패킷은 연결 및 버전별 키로 보호됩니다.
(초기 키) [QUIC-TLS]에 설명된 대로. 이 보호 기능은
공격자에 대한 기밀성 또는 무결성을 제공합니다.
패킷을 관찰하지만 관찰할 수 없는 공격자는 방지할 수 있습니다.
스푸핑으로부터의 패킷 초기 패킷.

클라이언트와 서버는 모든 패킷에 대해 초기 패킷 유형을 사용합니다.
초기 암호화 핸드셰이크 메시지를 포함합니다. 여기에는 다음이 포함됩니다.
초기 암호화를 포함하는 새 패킷이 있는 모든 경우
수신 후 전송되는 패킷과 같은 메시지를 생성해야 합니다.
재시도 패킷; 섹션 17.2.5를 참조하세요.

서버는 클라이언트에 대한 응답으로 첫 번째 초기 패킷을 보냅니다.
초기. 서버는 여러 개의 초기 패킷을 보낼 수 있습니다.
암호화 키 교환에는 여러 번의 왕복이 필요할 수 있습니다.
이 데이터를 재전송합니다.

초기 패킷의 페이로드에는 CRYPTO 프레임(또는 프레임들)이 포함됩니다.
암호화 핸드셰이크 메시지, ACK 프레임 또는 둘 다를 포함합니다.
0x1c 유형의 PING, PADDING 및 CONNECTION_CLOSE 프레임도 있습니다.
허용됨. 초기 패킷을 수신하는 엔드포인트
다른 프레임은 패킷을 잘못된 것으로 간주하여 삭제하거나 처리할 수 있습니다.
연결 오류.

클라이언트가 보낸 첫 번째 패킷에는 항상 CRYPTO 프레임이 포함됩니다.
첫 번째 암호화 핸드셰이크의 시작 또는 전체를 포함합니다.
메시지. 전송된 첫 번째 CRYPTO 프레임은 항상 오프셋에서 시작됩니다.
0; 섹션 7을 참조하세요.

서버가 TLS HelloRetryRequest를 보내는 경우(참조)
[QUIC-TLS]의 섹션 4.7) 클라이언트는 또 다른 시리즈를 보냅니다.
초기 패킷. 이 초기 패킷은 계속됩니다.
암호화 핸드셰이크이며 시작 시 CRYPTO 프레임이 포함됩니다.
첫 번째로 전송된 CRYPTO 프레임의 크기와 일치하는 오프셋
초기 패킷의 비행.

17.2.2.1. 초기 패킷 포기

클라이언트는 초기 패킷 전송과 처리를 모두 중지합니다.
첫 번째 핸드셰이크 패킷을 보냅니다. 서버가 전송을 중단하고
첫 번째 핸드셰이크를 수신할 때 초기 패킷을 처리합니다.
패킷. 패킷이 아직 전송 중이거나 대기 중일 수 있음
확인, 더 이상 초기 패킷을 교환할 필요가 없습니다.
이 지점을 넘어서면 초기 패킷 보호 키가 삭제됩니다(참조
[QUIC-TLS]의 섹션 4.9.1과 손실 복구 및
혼잡 제어 상태; [QUIC-RECOVERY]의 섹션 6.4를 참조하세요.

CRYPTO 프레임의 모든 데이터는 삭제되며 더 이상 재전송되지 않습니다.
-- 초기 키가 삭제되는 경우.

17.2.3. 0-RTT

0-RTT 패킷은 0x01의 유형 값을 갖는 긴 헤더를 사용합니다.
길이 및 패킷 번호 필드로; 섹션 17.2를 참조하세요. 첫 번째
바이트에는 예약 비트와 패킷 번호 길이 비트가 포함됩니다.
섹션 17.2. 0-RTT 패킷은 "초기" 데이터를 전송하는 데 사용됩니다.
핸드셰이크 전 첫 번째 비행의 일부로 클라이언트에서 서버로
완료. TLS 핸드셰이크의 일부로 서버는 수락하거나
이 초기 데이터를 거부합니다.

0-RTT 데이터 및 해당 데이터에 대한 논의는 [TLS13]의 섹션 2.3을 참조하세요.
제한 사항.

0-RTT 패킷 {
헤더 양식(1) = 1,
고정 비트(1) = 1,
긴 패킷 유형(2) = 1,
예약된 비트(2),
패킷 번호 길이(2),
버전(32),
대상 연결 ID 길이(8),
대상 연결 ID(0..160),
소스 연결 ID 길이(8),
소스 연결 ID(0..160),
길이(i),
패킷 번호(8..32),
패킷 페이로드(8..),
}

                          그림 16: 0-RTT 패킷

0-RTT 보호 패킷의 패킷 번호는 다음과 같은 공간을 사용합니다.
1-RTT 보호 패킷.

클라이언트가 재시도 패킷을 수신한 후 0-RTT 패킷이 발생할 가능성이 높습니다.
서버에 의해 손실되거나 삭제되었습니다. 클라이언트는 다음을 시도해야 합니다.
새로운 초기 패킷을 보낸 후 0-RTT 패킷으로 데이터를 다시 보냅니다.
전송되는 모든 새 패킷에는 반드시 새 패킷 번호를 사용해야 합니다.
섹션 17.2.5.3에 설명된 대로 패킷 번호를 재사용할 수 있습니다.
패킷 보호가 손상되었습니다.

클라이언트는 0-RTT 패킷에 대한 확인만 받습니다.
[QUIC-TLS]의 섹션 4.1.1에 정의된 대로 핸드셰이크가 완료되었습니다.

클라이언트는 1-RTT 처리를 시작하면 0-RTT 패킷을 보내서는 안 됩니다.
서버에서 패킷을 보냅니다. 즉, 0-RTT 패킷은 보낼 수 없습니다.
1-RTT 패킷의 프레임에 대한 응답을 포함합니다. 예를 들어,
클라이언트는 0-RTT 패킷에서 ACK 프레임을 보낼 수 없습니다.
1-RTT 패킷에 대해서만 확인 응답을 보냅니다. 1-RTT에 대한 확인 응답은
패킷은 1-RTT 패킷으로 전송되어야 합니다.

서버는 기억된 제한 위반을 처리해야 합니다.
(섹션 7.4.1) 적절한 유형의 연결 오류로서(
예를 들어, 스트림 데이터 제한을 초과하면 FLOW_CONTROL_ERROR가 발생합니다.

17.2.4. 핸드셰이크 패킷

핸드셰이크 패킷은 0x02의 유형 값을 갖는 긴 헤더를 사용합니다.
길이 및 패킷 번호 필드 뒤에 나옵니다. 섹션 17.2를 참조하세요.
첫 번째 바이트에는 예약 비트와 패킷 번호 길이 비트가 포함됩니다.
섹션 17.2를 참조하세요. 암호화 핸드셰이크를 수행하는 데 사용됩니다.
서버와 클라이언트로부터의 메시지와 확인.

핸드셰이크 패킷 {
헤더 양식(1) = 1,
고정 비트(1) = 1,
긴 패킷 유형(2) = 2,
예약된 비트(2),
패킷 번호 길이(2),
버전(32),
대상 연결 ID 길이(8),
대상 연결 ID(0..160),
소스 연결 ID 길이(8),
소스 연결 ID(0..160),
길이(i),
패킷 번호(8..32),
패킷 페이로드(8..),
}

                   그림 17: 핸드셰이크 보호 패킷

클라이언트가 서버로부터 핸드셰이크 패킷을 수신하면 다음을 사용합니다.
후속 암호화 핸드셰이크 메시지를 보내기 위한 핸드셰이크 패킷
그리고 서버에 감사를 표합니다.

핸드셰이크 패킷의 대상 연결 ID 필드에는 다음이 포함됩니다.
패킷 수신자가 선택한 연결 ID
소스 연결 ID에는 보낸 사람이 연결 ID를 포함합니다.
패킷이 사용하려고 하는 내용입니다. 섹션 7.2를 참조하세요.

핸드셰이크 패킷에는 자체 패킷 번호 공간이 있으므로
서버에서 보낸 첫 번째 핸드셰이크 패킷에는 패킷 번호가 포함되어 있습니다.
0.

이 패킷의 페이로드에는 CRYPTO 프레임이 포함되어 있으며 다음을 포함할 수 있습니다.
PING, PADDING 또는 ACK 프레임. 핸드셰이크 패킷에는 다음이 포함될 수 있습니다.
0x1c 유형의 CONNECTION_CLOSE 프레임. 엔드포인트는 수신을 처리해야 합니다.
다른 프레임과의 핸드셰이크 패킷을 연결 오류 유형으로 표시
프로토콜 위반.

초기 패킷과 마찬가지로(섹션 17.2.2.1 참조), CRYPTO 프레임의 데이터
핸드셰이크 패킷은 삭제되고 더 이상 재전송되지 않습니다.
핸드셰이크 보호 키가 삭제되는 경우.

17.2.5. 재시도 패킷

그림 18에서 보여지는 것처럼 Retry 패킷은 긴 패킷 헤더를 사용합니다.
0x03의 유형 값입니다. 생성된 주소 검증 토큰을 전달합니다.
서버에 의해. 이는 다음을 수행하려는 서버에서 사용됩니다.
다시 시도하세요. 섹션 8.1을 참조하세요.

재시도 패킷 {
헤더 양식(1) = 1,
고정 비트(1) = 1,
긴 패킷 유형(2) = 3,
미사용(4),
버전(32),
대상 연결 ID 길이(8),
대상 연결 ID(0..160),
소스 연결 ID 길이(8),
소스 연결 ID(0..160),
재시도 토큰(..),
재시도 무결성 태그(128),
}

                          그림 18: 재시도 패킷

재시도 패킷에는 보호된 필드가 포함되어 있지 않습니다.
Unused 필드는 서버에 의해 임의의 값으로 설정됩니다. 클라이언트
이 비트는 반드시 무시해야 합니다. 긴 필드 외에도
헤더에는 다음과 같은 추가 필드가 포함되어 있습니다.

재시도 토큰: 서버가 유효성 검사에 사용할 수 있는 불투명 토큰
고객의 주소.

재시도 무결성 태그: 섹션 5.8("재시도 패킷"에 정의됨)
[QUIC-TLS]의 "무결성".

17.2.5.1. 재시도 패킷 전송

서버는 대상 연결 ID를 다음과 같이 채웁니다.
클라이언트가 소스 연결 ID에 포함한 연결 ID
초기 패킷.

서버는 소스에 선택한 연결 ID를 포함합니다.
연결 ID 필드. 이 값은 대상과 같을 수 없습니다.
클라이언트가 보낸 패킷의 연결 ID 필드. 클라이언트는 반드시
소스 연결 ID 필드가 포함된 재시도 패킷을 삭제합니다.
이는 대상 연결 ID 필드와 동일합니다.
초기 패킷. 클라이언트는 소스의 값을 사용해야 합니다.
대상 연결의 재시도 패킷의 연결 ID 필드
이후 전송되는 패킷의 ID 필드입니다.

서버는 초기 및 0-RTT에 대한 응답으로 재시도 패킷을 보낼 수 있습니다.
패킷. 서버는 0-RTT 패킷을 삭제하거나 버퍼링할 수 있습니다.
수신합니다. 서버는 수신하면서 여러 개의 재시도 패킷을 보낼 수 있습니다.
초기 또는 0-RTT 패킷. 서버는 재시도 패킷을 두 개 이상 보내서는 안 됩니다.
단일 UDP 데이터그램에 대한 응답 패킷입니다.

17.2.5.2. 재시도 패킷 처리

클라이언트는 각 Retry 패킷을 최대 1개까지 수락하고 처리해야 합니다.
연결 시도. 클라이언트가 연결을 수신하고 처리한 후
서버에서 초기 또는 재시도 패킷을 수신하면 모든 패킷을 삭제해야 합니다.
이후에 수신한 재시도 패킷.

클라이언트는 Retry Integrity 태그가 있는 Retry 패킷을 삭제해야 합니다.
검증할 수 없는 경우 [QUIC-TLS]의 섹션 5.8을 참조하세요.
공격자가 재시도 패킷을 주입하는 능력을 약화시킵니다.
Retry 패킷의 우발적인 손상으로부터 보호합니다. 클라이언트
0 길이의 재시도 토큰 필드가 있는 재시도 패킷은 반드시 삭제해야 합니다.

클라이언트는 초기 패킷으로 재시도 패킷에 응답합니다.
연결을 계속하기 위해 제공된 재시도 토큰이 포함됩니다.
설립.

클라이언트는 이 초기 연결의 대상 연결 ID 필드를 설정합니다.
재시도의 소스 연결 ID 필드 값에 대한 패킷
패킷. 대상 연결 ID 필드를 변경하면 다음과 같은 결과가 발생합니다.
초기 패킷을 보호하는 데 사용되는 키가 변경되었습니다. 또한
토큰 필드를 재시도 패킷에 제공된 토큰으로 설정합니다.
클라이언트는 서버가 소스 연결 ID를 변경해서는 안 됩니다.
토큰 검증의 일부로 연결 ID를 포함할 수 있습니다.
논리; 8.1.4절을 참조하세요.

재시도 패킷에는 패킷 번호가 포함되지 않으며
고객이 명시적으로 인정함.

17.2.5.3. 재시도 후 핸드셰이크 계속

클라이언트의 후속 초기 패킷에는 연결 ID가 포함됩니다.
Retry 패킷의 토큰 값. 클라이언트는 소스를 복사합니다.
Retry 패킷에서 Destination으로의 연결 ID 필드
연결 ID 필드 및 초기 패킷이 있을 때까지 이 값을 사용합니다.
업데이트된 값이 수신되었습니다. 섹션 7.2를 참조하세요.
토큰 필드는 모든 후속 초기 패킷에 복사됩니다. 참조
섹션 8.1.2.

대상 연결 ID 및 토큰 필드를 업데이트하는 것 외에도
클라이언트가 보낸 초기 패킷은 동일한 대상입니다.
첫 번째 초기 패킷과 같은 제한 사항이 적용됩니다. 클라이언트는 동일한 제한 사항을 사용해야 합니다.
이 패킷에 포함된 암호화 핸드셰이크 메시지입니다. 서버
다른 암호화 핸드셰이크를 포함하는 패킷을 처리할 수 있습니다.
메시지를 연결 오류로 간주하거나 삭제합니다. 다음을 포함하는 것에 유의하세요.
토큰 필드는 암호화에 사용 가능한 공간을 줄입니다.
핸드셰이크 메시지는 클라이언트가 보내야 할 수도 있는 결과를 초래할 수 있습니다.
여러 개의 초기 패킷.

클라이언트는 재시도 패킷을 수신한 후 다음을 보내 0-RTT를 시도할 수 있습니다.
서버가 제공한 연결 ID에 대한 0-RTT 패킷입니다.

클라이언트는 패킷 번호 공간에 대한 패킷 번호를 재설정해서는 안 됩니다.
재시도 패킷을 처리한 후. 특히, 0-RTT 패킷
가장 가능성이 높은 기밀 정보가 포함되어 있습니다.
재시도 패킷을 수신하면 재전송됩니다. 보호에 사용되는 키는 다음과 같습니다.
이러한 새로운 0-RTT 패킷은 응답의 결과로 변경되지 않습니다.
재시도 패킷. 그러나 이러한 패킷에 전송된 데이터는
이전에 보낸 것과 다릅니다. 이 새로운 패킷을 다음과 같이 보냅니다.
동일한 패킷 번호는 패킷 보호를 손상시킬 가능성이 있습니다.
동일한 키와 nonce를 사용할 수 있기 때문에 해당 패킷의 경우
다른 콘텐츠를 보호합니다. 서버는 다음과 같은 경우 연결을 중단할 수 있습니다.
클라이언트가 패킷 번호를 재설정한 것을 감지합니다.

초기 및 재시도 패킷에서 교환된 연결 ID
클라이언트와 서버 사이에 전송 매개변수가 복사됩니다.
섹션 7.3에 설명된 대로 검증되었습니다.

17.3. 짧은 헤더 패킷

이 QUIC 버전은 짧은 패킷 유형을 사용하는 단일 패킷 유형을 정의합니다.
패킷 헤더.

17.3.1. 1-RTT 패킷

1-RTT 패킷은 짧은 패킷 헤더를 사용합니다.
버전 및 1-RTT 키가 협상됩니다.

1-RTT 패킷 {
헤더 양식(1) = 0,
고정 비트(1) = 1,
스핀비트(1),
예약된 비트(2),
핵심 단계(1),
패킷 번호 길이(2),
대상 연결 ID(0..160),
패킷 번호(8..32),
패킷 페이로드(8..),
}

                          그림 19: 1-RTT 패킷

1-RTT 패킷에는 다음 필드가 포함됩니다.

헤더 형식: 바이트 0의 최상위 비트(0x80)가 0으로 설정됩니다.
짧은 헤더용.

고정 비트: 바이트 0의 다음 비트(0x40)가 1로 설정됩니다. 패킷
이 비트에 0 값이 포함된 패킷은 이 패킷에서 유효하지 않습니다.
버전이며 반드시 삭제해야 합니다. 이 비트의 값이 1이면
QUIC는 다른 프로토콜과 공존할 수 있습니다. [RFC7983]을 참조하세요.

스핀 비트: 바이트 0의 세 번째로 중요한 비트(0x20)는
지연 스핀 비트는 섹션 17.4에 설명된 대로 설정됩니다.

예약된 비트: 바이트의 다음 두 비트(0x18 마스크가 있는 비트)
0은 예약되어 있습니다. 이 비트들은 헤더 보호를 통해 보호됩니다.
[QUIC-TLS]의 섹션 5.4를 참조하세요. 이전에 포함된 값
보호는 0으로 설정되어야 합니다. 엔드포인트는 수신을 처리해야 합니다.
이러한 비트에 대해 0이 아닌 값을 갖는 패킷을 제거한 후
패킷 및 헤더 보호 모두 연결 오류 유형으로
PROTOCOL_VIOLATION. 해당 패킷을 제거한 후 삭제합니다.
헤더 보호는 엔드포인트를 공격에 노출시킬 수 있습니다.
[QUIC-TLS]의 섹션 9.5.

키 단계: 바이트 0의 다음 비트(0x04)는 키 단계를 나타냅니다.
패킷 수신자가 패킷을 식별할 수 있도록 허용합니다.
패킷을 보호하는 데 사용되는 보호 키입니다. 참조
자세한 내용은 [QUIC-TLS]를 참조하세요. 이 비트는 헤더를 사용하여 보호됩니다.
보호; [QUIC-TLS]의 섹션 5.4를 참조하세요.

패킷 번호 길이: 최하위 2비트(
바이트 0의 0x03 마스크에는 패킷 번호의 길이가 포함됩니다.
필드는 1이 적은 부호 없는 2비트 정수로 인코딩됩니다.
패킷 번호 필드의 길이(바이트)보다 큽니다. 즉,
패킷 번호 필드의 길이는 이 필드의 값에 다음을 더한 값입니다.
1. 이 비트는 헤더 보호를 사용하여 보호됩니다.
[QUIC-TLS]의 섹션 5.4.

대상 연결 ID: 대상 연결 ID는
의도된 수신자가 선택한 연결 ID
패킷. 자세한 내용은 5.1절을 참조하세요.

패킷 번호: 패킷 번호 필드는 1~4바이트 길이입니다.
패킷 번호는 헤더 보호를 사용하여 보호됩니다.
[QUIC-TLS]의 섹션 5.4. 패킷 번호 필드의 길이
패킷 번호 길이 필드에 인코딩됩니다. 자세한 내용은 섹션 17.1을 참조하세요.
세부.

패킷 페이로드: 1-RTT 패킷에는 항상 1-RTT 보호가 포함됩니다.
유효 탑재량.

헤더 형식 비트와 대상 연결 ID 필드
짧은 헤더 패킷은 버전과 무관합니다. 나머지 필드는
선택한 QUIC 버전에만 적용됩니다. 자세한 내용은 [QUIC-INVARIANTS]를 참조하세요.
QUIC의 다양한 버전에서 패킷이 어떻게 전송되는지에 대한 세부 정보
해석됨.

17.4. 레이턴시 스핀 비트

1-RTT 패킷에 대해 정의된 레이턴시 스핀 비트
(섹션 17.3.1) 관찰에서 수동 지연 모니터링을 활성화합니다.
연결 기간 동안 네트워크 경로의 지점입니다.
서버는 수신된 스핀 값을 반영하는 반면 클라이언트는 "스핀"합니다.
한 번의 RTT 후에. 경로상의 관찰자는 두 시간 사이의 시간을 측정할 수 있습니다.
스핀 비트 토글 이벤트를 사용하여 엔드투엔드 RTT를 추정합니다.
연결.

스핀 비트는 1-RTT 패킷에만 존재합니다.
연결의 초기 RTT를 측정하려면 다음을 관찰해야 합니다.
핸드셰이크. 따라서 스핀 비트는 버전 이후에 사용 가능합니다.
협상 및 연결 설정이 완료되었습니다. 경로상
레이턴시 스핀 비트의 측정 및 사용에 대해서는 다음에서 자세히 논의합니다.
[빠른 관리성]

스핀 비트는 이 QUIC 버전의 선택 기능입니다.
이 기능을 지원하지 않는 엔드포인트는 이를 비활성화해야 합니다.
아래에 정의되어 있습니다.

각 엔드포인트는 스핀 비트가 활성화되었는지 여부를 일방적으로 결정합니다.
연결에 대해 비활성화되었습니다. 구현 시 관리자가 다음을 허용해야 합니다.
클라이언트와 서버에서 스핀 비트를 전역적으로 또는 개별적으로 비활성화합니다.
연결당 기준. 스핀 비트가 비활성화되지 않은 경우에도
관리자는 엔드포인트가 스핀 비트 사용을 비활성화해야 합니다.
16개 네트워크 경로 중 적어도 하나를 무작위로 선택하거나
QUIC를 보장하기 위해 16개 연결 ID 중 하나에 대해
스핀 비트를 비활성화하는 연결은 일반적으로 다음에서 관찰됩니다.
네트워크. 각 엔드포인트가 스핀 비트를 독립적으로 비활성화하므로
스핀 비트 신호가 약 1초 동안 비활성화되도록 보장합니다.
8개의 네트워크 경로.

스핀 비트가 비활성화되면 엔드포인트는 스핀 비트를 어떤 것으로든 설정할 수 있습니다.
값을 지정하고 들어오는 모든 값을 무시해야 합니다. 권장 사항:
엔드포인트는 스핀 비트를 선택한 임의의 값으로 설정합니다.
각 패킷에 대해 독립적으로 또는 각 패킷에 대해 독립적으로 선택됨
연결 ID.

연결에 대해 스핀 비트가 활성화된 경우 엔드포인트는 다음을 유지합니다.
각 네트워크 경로에 대한 스핀 값과 스핀 비트를 설정합니다.
1-RTT 패킷이 있을 때 패킷 헤더를 현재 저장된 값으로 변경합니다.
해당 경로로 전송됩니다. 스핀 값은 0으로 초기화됩니다.
각 네트워크 경로에 대한 엔드포인트. 각 엔드포인트는 또한 다음을 기억합니다.
각 경로에서 피어로부터 확인된 가장 높은 패킷 번호입니다.

서버가 가장 높은 값을 증가시키는 1-RTT 패킷을 수신하면
주어진 네트워크에서 클라이언트가 서버에서 보는 패킷 번호
경로의 경우 해당 경로의 스핀 값을 스핀과 동일하게 설정합니다.
수신된 패킷의 비트.

클라이언트가 가장 높은 값을 증가시키는 1-RTT 패킷을 수신하는 경우
주어진 네트워크의 서버에서 클라이언트가 보는 패킷 번호
경로의 경우 해당 경로의 스핀 값을 스핀의 역수로 설정합니다.
수신된 패킷의 비트.

엔드포인트는 네트워크 경로의 스핀 값을 0으로 재설정합니다.
해당 네트워크 경로에서 사용되는 연결 ID를 변경합니다.

18. 전송 매개변수 인코딩

quic_transport_parameters 확장의 extension_data 필드
[QUIC-TLS]에 정의된 QUIC 전송 매개변수를 포함합니다.
전송 매개변수의 시퀀스로 인코딩됩니다.
그림 20:

전송 매개변수 {
전송 매개변수(..) ...,
}

                그림 20: 전송 매개변수 순서

각 전송 매개변수는 (식별자, 길이, 값)으로 인코딩됩니다.
그림 21에 표시된 대로 튜플:

전송 매개변수 {
전송 매개변수 ID(i),
전송 매개변수 길이(i),
전송 매개변수 값(..),
}

                  그림 21: 전송 매개변수 인코딩

전송 매개변수 길이 필드에는 길이가 포함됩니다.
바이트 단위의 전송 매개변수 값 필드입니다.

QUIC는 전송 매개변수를 바이트 시퀀스로 인코딩합니다.
그런 다음 암호화 핸드셰이크에 포함됩니다.

18.1. 예약된 전송 매개변수

"31 * N + 27" 형식의 식별자를 갖는 전송 매개변수
N의 정수 값은 요구 사항을 실행하기 위해 예약되어 있습니다.
알 수 없는 전송 매개변수는 무시됩니다. 이러한 전송 매개변수는
의미가 없으며 임의의 값을 가질 수 있습니다.

18.2. 전송 매개변수 정의

이 섹션에서는 여기에 정의된 전송 매개변수를 자세히 설명합니다.
문서.

여기에 나열된 많은 전송 매개변수는 정수 값을 갖습니다.
정수로 식별되는 전송 매개변수는 변수를 사용합니다.
길이 정수 인코딩; 섹션 16 참조. 전송 매개변수에는 다음이 있습니다.
전송 매개변수가 없는 경우 기본값은 0입니다.
달리 명시되지 않은 경우.

다음 전송 매개변수가 정의됩니다.

original_destination_connection_id(0x00): 이 매개변수는
첫 번째 대상 연결 ID 필드의 값
클라이언트가 보낸 초기 패킷입니다. 섹션 7.3을 참조하세요.
전송 매개변수는 서버에서만 전송됩니다.

max_idle_timeout(0x01): 최대 유휴 시간 초과는 다음 값입니다.
정수로 인코딩된 밀리초입니다. (섹션 10.1)을 참조하세요.
두 엔드포인트 모두 이 전송을 생략하면 유휴 시간 초과가 비활성화됩니다.
매개변수 또는 0 값을 지정하세요.

stateless_reset_token(0x02): 상태 비저장 재설정 토큰이 사용됩니다.
상태 비저장 재설정 확인; 섹션 10.3 참조. 이 매개변수는
16바이트 시퀀스입니다. 이 전송 매개변수는 전송되어서는 안 됩니다.
클라이언트에 의해 전송되지만 서버에서 전송될 수도 있습니다.
이 전송 매개변수를 보내면 상태 비저장 재설정을 사용할 수 없습니다.
(섹션 10.3) 협상 중 연결 ID에 대해
악수.

max_udp_payload_size(0x03): 최대 UDP 페이로드 크기 매개변수
UDP 페이로드의 크기를 제한하는 정수 값입니다.
엔드포인트가 수신할 의향이 있습니다. 페이로드가 포함된 UDP 데이터그램
이 한도보다 큰 것은 처리되지 않을 가능성이 높습니다.
수화기.

      이 매개변수의 기본값은 허용되는 최대 UDP입니다.
      65527의 페이로드. 1200 미만의 값은 유효하지 않습니다.

      이 제한은 데이터그램 크기에 대한 추가 제약으로 작용합니다.
      경로 MTU와 같은 방식이지만 속성입니다.
      경로가 아닌 종료점입니다. 섹션 14를 참조하세요. 예상됩니다.
      이것은 엔드포인트가 수신 데이터를 보관하는 데 사용하는 공간입니다.
      패킷.

initial_max_data(0x04): 초기 최대 데이터 매개변수는
최대값의 초기값을 포함하는 정수 값
연결에서 전송할 수 있는 데이터 양입니다.
연결에 대해 MAX_DATA(섹션 19.9)를 보내는 것과 동일합니다.
악수를 마친 직후.

initial_max_stream_data_bidi_local(0x05): 이 매개변수는
초기 흐름 제어 한계를 지정하는 정수 값
로컬에서 시작된 양방향 스트림. 이 제한은 다음에 적용됩니다.
엔드포인트에서 열린 새로 생성된 양방향 스트림
전송 매개변수를 보냅니다. 클라이언트 전송 매개변수에서
이것은 식별자가 가장 적은 스트림에 적용됩니다.
서버 전송 매개변수에서 중요한 두 비트가 0x00으로 설정됨
이는 최하위 2비트가 설정된 스트림에 적용됩니다.
0x01.

initial_max_stream_data_bidi_remote(0x06): 이 매개변수는
피어에 대한 초기 흐름 제어 한계를 지정하는 정수 값
양방향 스트림이 시작되었습니다. 이 제한은 새로
수신하는 엔드포인트에서 열린 양방향 스트림을 생성했습니다.
전송 매개변수. 클라이언트 전송 매개변수에서 이
식별자가 가장 낮은 스트림에 적용됩니다.
두 비트가 0x01로 설정됨; 서버 전송 매개변수에서 이것이 적용됩니다.
최하위 2비트가 0x00으로 설정된 스트림으로.

initial_max_stream_data_uni(0x07): 이 매개변수는 정수입니다.
단방향에 대한 초기 흐름 제어 한계를 지정하는 값
스트림. 이 제한은 새로 생성된 단방향에 적용됩니다.
전송을 수신하는 엔드포인트에서 열린 스트림
매개변수. 클라이언트 전송 매개변수에서 이는 다음에 적용됩니다.
최하위 2비트가 설정된 식별자가 있는 스트림
0x03까지; 서버 전송 매개변수에서 이는 스트림에 적용됩니다.
최하위 2비트가 0x02로 설정됩니다.

initial_max_streams_bidi (0x08): 초기 최대 양방향
streams 매개변수는 초기값을 포함하는 정수 값입니다.
수신하는 엔드포인트의 양방향 스트림의 최대 수
이 전송 매개변수는 시작이 허용됩니다.
매개변수가 없거나 0이면 피어가 양방향으로 열 수 없습니다.
MAX_STREAMS 프레임이 전송될 때까지 스트림을 전송합니다. 이 매개변수를 설정하면
MAX_STREAMS(섹션 19.11)를 전송하는 것과 동일합니다.
동일한 값을 갖는 해당 유형.

initial_max_streams_uni(0x09): 초기 최대 단방향
streams 매개변수는 초기값을 포함하는 정수 값입니다.
엔드포인트의 단방향 스트림의 최대 개수
이 전송 매개변수를 수신하면 시작할 수 있습니다.
이 매개변수가 없거나 0이면 피어가 열 수 없습니다.
MAX_STREAMS 프레임이 전송될 때까지 단방향 스트림을 설정합니다.
이 매개변수는 MAX_STREAMS를 보내는 것과 동일합니다.
(섹션 19.11) 동일한 값을 가진 해당 유형입니다.

ack_delay_exponent(0x0a): 확인 지연 지수는
ACK 지연을 디코딩하는 데 사용되는 지수를 나타내는 정수 값
ACK 프레임의 필드(섹션 19.3). 이 값이 없으면
기본값은 3으로 가정됩니다(배수 8을 나타냄).
20보다 큰 값은 유효하지 않습니다.

max_ack_delay(0x0b): 최대 확인 지연은 정수입니다.
밀리초 단위로 최대 시간을 나타내는 값
엔드포인트가 확인 메시지 전송을 지연할 값입니다.
경보가 울리는 데 수신기가 예상하는 지연 시간을 포함해야 합니다.
예를 들어 수신기가 타이머를 5ms로 설정하고 알람을 울리면
일반적으로 최대 1ms 늦게 실행되면 max_ack_delay를 보내야 합니다.
6ms입니다. 이 값이 없으면 기본값인 25밀리초가 사용됩니다.
가정합니다. 2^14 이상의 값은 유효하지 않습니다.

disable_active_migration(0x0c): 활성 마이그레이션 비활성화
엔드포인트가 지원하지 않으면 전송 매개변수가 포함됩니다.
사용 중인 주소에 대한 활성 연결 마이그레이션(섹션 9)
핸드셰이크 중. 이 전송을 수신하는 엔드포인트
매개변수는 보낼 때 새 로컬 주소를 사용해서는 안 됩니다.
핸드셰이크 중에 피어가 사용한 주소입니다. 이 전송
매개변수는 클라이언트 이후 연결 마이그레이션을 금지하지 않습니다.
preferred_address 전송 매개변수에 대해 작동했습니다.
매개변수는 길이가 0인 값입니다.

preferred_address(0x0d): 서버의 기본 주소는 다음에 사용됩니다.
핸드셰이크가 끝나면 서버 주소가 변경됩니다.
섹션 9.6에 설명되어 있습니다. 이 전송 매개변수는 다음에서만 전송됩니다.
서버에 의해. 서버는 선호하는 주소만 보낼 수 있습니다.
모든 0 주소와 포트를 전송하여 하나의 주소 패밀리로
(0.0.0.0:0 또는 [::]:0) 다른 패밀리의 경우 IP 주소는 다음과 같습니다.
네트워크 바이트 순서로 인코딩됨.

      preferred_address 전송 매개변수에는 주소가 포함되어 있습니다.
      IPv4와 IPv6 모두에 대한 포트입니다. 4바이트 IPv4 주소 필드는 다음과 같습니다.
      연관된 2바이트 IPv4 포트 필드가 뒤따릅니다.
      16바이트 IPv6 주소 필드와 2바이트 IPv6 포트가 뒤따릅니다.
      필드. 주소 및 포트 쌍 뒤에 연결 ID 길이 필드가 있습니다.
      다음 연결 ID 필드의 길이를 설명합니다.
      마지막으로 16바이트 Stateless Reset Token 필드에는 다음이 포함됩니다.
      연결 ID와 연관된 상태 비저장 재설정 토큰입니다.
      이 전송 매개변수의 형식은 아래 그림 22에 나와 있습니다.

      연결 ID 필드 및 상태 비저장 재설정 토큰 필드
      시퀀스 번호가 있는 대체 연결 ID를 포함합니다.
      1; 섹션 5.1.1을 참조하세요. 이러한 값을 함께 보내면
      선호하는 주소는 최소한 하나의 사용되지 않은 주소가 있음을 보장합니다.
      클라이언트가 마이그레이션을 시작할 때 활성 연결 ID
      선호하는 주소.

      선호하는 연결 ID 및 상태 비저장 재설정 토큰 필드
      주소는 해당 주소와 구문 및 의미론적으로 동일합니다.
      NEW_CONNECTION_ID 프레임의 필드(섹션 19.15). 서버
      길이가 0인 연결 ID를 선택하는 경우 다음을 제공해서는 안 됩니다.
      선호하는 주소입니다. 마찬가지로 서버는 0을 포함해서는 안 됩니다.
      이 전송 매개변수에 길이 연결 ID가 있어야 합니다. 클라이언트는
      이러한 요구 사항 위반을 연결 오류로 처리합니다.
      TRANSPORT_PARAMETER_ERROR 유형.

선호 주소 {
IPv4 주소(32),
IPv4 포트(16),
IPv6 주소(128),
IPv6 포트(16),
연결 ID 길이(8),
연결 ID(..),
상태 비저장 재설정 토큰(128),
}

                    그림 22: 선호되는 주소 형식

active_connection_id_limit(0x0e): 이것은 정수 값입니다.
피어에서 연결 ID의 최대 개수 지정
엔드포인트가 저장하려고 합니다. 이 값에는 다음이 포함됩니다.
핸드셰이크 중에 수신된 연결 ID
preferred_address 전송 매개변수 및 수신된 매개변수
NEW_CONNECTION_ID 프레임.
active_connection_id_limit 매개변수는 최소 2여야 합니다.
2보다 작은 값을 수신하는 엔드포인트는 다음을 닫아야 합니다.
TRANSPORT_PARAMETER_ERROR 유형의 오류가 있는 연결입니다.
이 전송 매개변수가 없는 경우 기본값 2가 가정됩니다.
엔드포인트가 길이가 0인 연결 ID를 발급하면 절대로 연결 ID를 보내지 않습니다.
NEW_CONNECTION_ID 프레임이므로 무시됩니다.
피어로부터 active_connection_id_limit 값을 받았습니다.

initial_source_connection_id(0x0f): 이것은 값입니다.
첫 번째 소스 연결 ID 필드에 포함된 엔드포인트
연결을 위해 보내는 초기 패킷입니다. 섹션 7.3을 참조하세요.

retry_source_connection_id(0x10): 이것은 서버가 지정하는 값입니다.
재시도 패킷의 소스 연결 ID 필드에 포함됨; 참조
섹션 7.3. 이 전송 매개변수는 서버에서만 전송됩니다.

존재하는 경우, 초기 스트림당 흐름을 설정하는 전송 매개변수
관리 한계(initial_max_stream_data_bidi_local,
initial_max_stream_data_bidi_remote 및 initial_max_stream_data_uni)
MAX_STREAM_DATA 프레임(섹션 19.10)을 보내는 것과 동일합니다.
해당 유형의 모든 스트림을 열자마자 즉시.
전송 매개변수가 없으면 해당 유형의 스트림은 다음으로 시작합니다.
유량 제어 한계는 0입니다.

클라이언트는 서버 전용 전송 매개변수를 포함해서는 안 됩니다.
원래_목적지_연결_ID, 선호_주소,
retry_source_connection_id 또는 stateless_reset_token. 서버는 반드시
이러한 전송 매개변수 중 하나라도 수신되면 연결로 처리합니다.
TRANSPORT_PARAMETER_ERROR 유형의 오류입니다.

19. 프레임 유형 및 형식

12.4절에서 설명한 대로 패킷에는 하나 이상의 프레임이 포함됩니다.
이 섹션에서는 핵심 QUIC의 형식과 의미론을 설명합니다.
프레임 유형.

19.1. 패딩 프레임

PADDING 프레임(type=0x00)에는 의미적 값이 없습니다. PADDING 프레임
패킷 크기를 늘리는 데 사용할 수 있습니다. 패딩은 다음과 같은 경우에 사용할 수 있습니다.
초기 패킷을 최소 요구 크기로 늘리거나 제공하려면
보호된 패킷에 대한 트래픽 분석으로부터 보호합니다.

PADDING 프레임은 그림 23과 같이 포맷되어 있습니다.
PADDING 프레임에는 콘텐츠가 없습니다. 즉, PADDING 프레임은 다음으로 구성됩니다.
프레임을 PADDING 프레임으로 식별하는 단일 바이트입니다.

패딩 프레임 {
유형(i) = 0x00,
}

                      그림 23: PADDING 프레임 형식

19.2. PING 프레임

엔드포인트는 PING 프레임(유형=0x01)을 사용하여 피어를 확인할 수 있습니다.
아직 살아 있는지 또는 피어와의 연결 가능성을 확인합니다.

PING 프레임은 그림 24에 표시된 대로 포맷됩니다.
PING 프레임에는 내용이 없습니다.

PING 프레임 {
유형(i) = 0x01,
}

                        그림 24: PING 프레임 형식

PING 프레임의 수신자는 패킷을 확인하기만 하면 됩니다.
이 프레임을 포함합니다.

PING 프레임은 연결이 끊어졌을 때 연결을 유지하는 데 사용할 수 있습니다.
응용 프로그램 또는 응용 프로그램 프로토콜이 연결을 방지하려고 합니다.
시간 초과로부터; 섹션 10.1.2를 참조하세요.

19.3. ACK 프레임

수신자는 송신자에게 ACK 프레임(유형 0x02 및 0x03)을 보내서 알립니다.
수신 및 처리한 패킷입니다. ACK 프레임에는 다음이 포함됩니다.
또는 그 이상의 ACK 범위. ACK 범위는 확인된 패킷을 식별합니다.
프레임 유형은 0x03이고 ACK 프레임에는 누적 개수도 포함됩니다.
연결에서 수신된 관련 ECN 표시가 있는 QUIC 패킷
이 시점까지. QUIC 구현은 두 가지 모두를 적절하게 처리해야 합니다.
유형 및 패킷에 대해 ECN을 활성화한 경우
ECN 섹션의 정보를 사용하여 관리해야 합니다.
혼잡 상태.

QUIC 확인은 취소할 수 없습니다. 확인되면 패킷은
향후 ACK에 나타나지 않더라도 계속 인정됩니다.
프레임입니다. 이는 TCP 선택적 확인(TCP Selective Acknowledgments)을 포기하는 것과는 다릅니다.
(SACK) [RFC2018].

다른 패킷 번호 공간의 패킷은 다음을 사용하여 식별할 수 있습니다.
동일한 숫자 값입니다. 패킷에 대한 확인은 다음이 필요합니다.
패킷 번호와 패킷 번호 공간을 모두 나타냅니다. 이는
각 ACK 프레임이 패킷 번호만 확인하도록 하여 달성됨
ACK 프레임이 포함된 패킷과 같은 공간에 있습니다.

버전 협상 및 재시도 패킷은 다음과 같은 이유로 확인될 수 없습니다.
패킷 번호가 포함되어 있지 않습니다. ACK에 의존하는 대신
프레임의 경우 이러한 패킷은 다음 초기 프레임에서 암묵적으로 확인됩니다.
클라이언트가 보낸 패킷.

ACK 프레임은 그림 25와 같이 포맷됩니다.

ACK 프레임 {
유형(i) = 0x02..0x03,
가장 큰 인정(i),
ACK 지연(i),
ACK 범위 수(i),
첫 번째 ACK 범위(i),
ACK 범위 (..) ...,
[ECN 카운트(..)],
}

                        그림 25: ACK 프레임 형식

ACK 프레임에는 다음 필드가 포함됩니다.

가장 큰 확인: 가변 길이 정수는 다음을 나타냅니다.
피어가 확인하는 가장 큰 패킷 번호입니다. 이는 일반적으로 다음과 같습니다.
피어가 이전에 수신한 가장 큰 패킷 번호
ACK 프레임을 생성합니다. QUIC의 패킷 번호와 달리
긴 헤더나 짧은 헤더에 관계없이 ACK 프레임의 값은 잘리지 않습니다.

ACK 지연: 확인을 인코딩하는 가변 길이 정수
지연 시간은 마이크로초입니다. 섹션 13.2.5를 참조하세요. 다음에 의해 디코딩됩니다.
필드의 값을 2의 거듭제곱으로 곱합니다.
송신자가 보낸 ack_delay_exponent 전송 매개변수
ACK 프레임; 섹션 18.2 참조. 단순히 표현하는 것과 비교
지연을 정수로 표현하면 이 인코딩은 더 넓은 범위를 허용합니다.
동일한 바이트 수 내에서 값을 더 낮은 비용으로 제공합니다.
해결.

ACK 범위 수: ACK 범위 수를 지정하는 가변 길이 정수
프레임의 ACK 범위 필드.

첫 번째 ACK 범위: 첫 번째 ACK 범위 수를 나타내는 가변 길이 정수
가장 큰 확인 패킷 앞에 있는 연속 패킷
확인됨. 즉, 확인된 가장 작은 패킷입니다.
범위는 First ACK Range 값을 빼서 결정됩니다.
가장 큰 인정 분야에서.

ACK 범위: 패킷의 추가 범위를 포함합니다.
교대로 인식되지 않음(갭) 및 인식됨(ACK 범위)
섹션 19.3.1을 참조하세요.

ECN 카운트: 세 가지 ECN 카운트. 섹션 19.3.2를 참조하세요.

19.3.1. ACK 범위

각 ACK 범위는 교대로 갭과 ACK 범위 길이로 구성됩니다.
내림차순 패킷 번호 순서로 값을 지정합니다. ACK 범위는 다음과 같습니다.
반복됩니다. Gap 및 ACK 범위 길이 값의 수는 다음과 같습니다.
ACK 범위 카운트 필드에 의해 결정됨; 각 값 중 하나가 존재함
ACK 범위 카운트 필드의 각 값에 대해.

ACK 범위는 그림 26과 같이 구성됩니다.

ACK 범위 {
갭(i),
ACK 범위 길이(i),
}

                           그림 26: ACK 범위

각 ACK 범위를 구성하는 필드는 다음과 같습니다.

Gap: 연속된 문자열의 개수를 나타내는 가변 길이 정수
패킷 번호 1보다 앞에 있는 확인되지 않은 패킷
이전 ACK 범위에서 가장 작은 값입니다.

ACK 범위 길이: ACK 범위 수를 나타내는 가변 길이 정수
가장 큰 패킷 앞에 있는 연속된 확인된 패킷
숫자는 앞의 간격에 따라 결정됩니다.

Gap 및 ACK 범위 길이 값은 상대 정수 인코딩을 사용합니다.
효율성. 각 인코딩된 값은 양수이지만 값은
빼서 각 ACK 범위가 점점 낮아지는 것을 설명합니다.
번호가 매겨진 패킷.

각 ACK 범위는 다음을 통해 연속된 패킷 범위를 확인합니다.
앞에 있는 확인된 패킷의 수를 나타냅니다.
해당 범위에서 가장 큰 패킷 번호입니다. 값 0은 다음을 나타냅니다.
가장 큰 패킷 번호만 확인 응답됩니다. 더 넓은 ACK 범위
값은 더 넓은 범위를 나타내며 이에 해당하는 더 낮은 값은 다음과 같습니다.
범위에서 가장 작은 패킷 번호입니다. 따라서 가장 큰
범위에 대한 패킷 번호의 경우 가장 작은 값은 다음에 의해 결정됩니다.
다음 공식:

      가장 작은 값 = 가장 큰 값 - ack_range

ACK 범위는 가장 작은 패킷 사이의 모든 패킷을 확인합니다.
숫자이자 가장 큰 것을 포함합니다.

ACK 범위의 가장 큰 값은 누적적으로 결정됩니다.
이전의 모든 ACK 범위 길이와 간격의 크기를 뺍니다.

각 간격은 전송되지 않는 패킷 범위를 나타냅니다.
확인됨. 갭의 패킷 수는 다음보다 하나 더 많습니다.
Gap 필드의 인코딩된 값입니다.

Gap 필드의 값은 가장 큰 패킷 번호를 설정합니다.
다음 공식을 사용하여 후속 ACK 범위에 대한 값을 구합니다.

      가장 큰 값 = 이전_가장 작은 값 - 간격 - 2

계산된 패킷 번호가 음수이면 엔드포인트는 다음을 생성해야 합니다.
FRAME_ENCODING_ERROR 유형의 연결 오류.

19.3.2. ECN 카운트

ACK 프레임은 유형 값의 최하위 비트를 사용합니다.
ECN 피드백과 QUIC 수신 보고를 나타내려면 0x03을 입력합니다.
ECT(0), ECT(1) 또는 ECN-CE의 연관된 ECN 코드포인트가 있는 패킷
패킷의 IP 헤더에 있습니다. ECN 수는 ACK가 있을 때만 존재합니다.
프레임 유형은 0x03입니다.

그림 27에서 볼 수 있듯이 ECN 카운트는 3개입니다.

ECN 카운트 {
ECT0 카운트(i),
ECT1 수치(i),
ECN-CE 카운트(i),
}

                        그림 27: ECN 카운트 형식

ECN 카운트 필드는 다음과 같습니다.

ECT0 Count: 총 개수를 나타내는 가변 길이 정수
패킷 번호에 ECT(0) 코드포인트가 포함된 패킷 수신
ACK 프레임의 공간.

ECT1 Count: 총 개수를 나타내는 가변 길이 정수
패킷 번호에 ECT(1) 코드포인트가 포함된 패킷 수신
ACK 프레임의 공간.

ECN-CE Count: 총계를 나타내는 가변 길이 정수
패킷에 ECN-CE 코드포인트가 포함된 수신 패킷 수
ACK 프레임의 숫자 공간.

ECN 수는 각 패킷 번호 공간마다 별도로 관리됩니다.

19.4. RESET_STREAM 프레임

엔드포인트는 RESET_STREAM 프레임(유형=0x04)을 사용하여 갑자기
스트림의 전송 부분을 종료합니다.

RESET_STREAM을 보낸 후 엔드포인트는 전송을 중단합니다.
식별된 스트림에서 STREAM 프레임을 재전송합니다. 수신기
RESET_STREAM은 이미 수신한 모든 데이터를 삭제할 수 있습니다.
개울.

전송 전용 스트림에 대한 RESET_STREAM 프레임을 수신하는 엔드포인트
STREAM_STATE_ERROR 오류로 인해 연결을 종료해야 합니다.

RESET_STREAM 프레임은 그림 28과 같이 포맷됩니다.

RESET_STREAM 프레임 {
유형(i) = 0x04,
스트림 ID(i),
애플리케이션 프로토콜 오류 코드(i),
최종 크기(i),
}

                    그림 28: RESET_STREAM 프레임 형식

RESET_STREAM 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 스트림 ID의 가변 길이 정수 인코딩
스트림이 종료됩니다.

애플리케이션 프로토콜 오류 코드: 가변 길이 정수
애플리케이션 프로토콜 오류 코드를 포함합니다(섹션 20.2 참조)
이는 스트림이 닫히는 이유를 나타냅니다.

최종 크기: 최종 크기를 나타내는 가변 길이 정수
RESET_STREAM 송신자가 바이트 단위로 전송하는 스트림을 참조하세요.
섹션 4.5.

19.5. STOP_SENDING 프레임

엔드포인트는 STOP_SENDING 프레임(유형=0x05)을 사용하여 다음을 전달합니다.
수신 데이터는 애플리케이션 요청 시 즉시 삭제됩니다.
STOP_SENDING은 피어가 스트림 전송을 중단하도록 요청합니다.

STOP_SENDING 프레임은 "Recv" 또는 "Size" 스트림에 대해 전송될 수 있습니다.
알려진 상태; 섹션 3.2 참조. STOP_SENDING 프레임 수신
아직 생성되지 않은 로컬 시작 스트림은 반드시 생성되어야 합니다.
STREAM_STATE_ERROR 유형의 연결 오류로 처리됩니다.
수신 전용 스트림에 대한 STOP_SENDING 프레임을 수신하는 엔드포인트
STREAM_STATE_ERROR 오류로 인해 연결을 종료해야 합니다.

STOP_SENDING 프레임은 그림 29와 같이 포맷됩니다.

STOP_SENDING 프레임 {
유형(i) = 0x05,
스트림 ID(i),
애플리케이션 프로토콜 오류 코드(i),
}

                    그림 29: STOP_SENDING 프레임 형식

STOP_SENDING 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 스트림 ID를 전달하는 가변 길이 정수
스트림이 무시됩니다.

애플리케이션 프로토콜 오류 코드: 가변 길이 정수
보낸 사람이 무시하는 애플리케이션 지정 이유가 포함되어 있습니다.
스트림; 섹션 20.2를 참조하세요.

19.6. CRYPTO 프레임

암호화 프레임(유형=0x06)은 암호화를 전송하는 데 사용됩니다.
핸드셰이크 메시지입니다. 0-RTT를 제외한 모든 패킷 유형으로 전송될 수 있습니다.
CRYPTO 프레임은 암호화 프로토콜에 순서 스트림을 제공합니다.
바이트. CRYPTO 프레임은 기능적으로 STREAM 프레임과 동일합니다.
단, 스트림 식별자가 없다는 점이 다릅니다. 흐름이 ​​아닙니다.
제어됨; 그리고 선택적 오프셋에 대한 마커를 가지고 있지 않습니다.
선택적인 길이와 스트림의 끝.

CRYPTO 프레임은 그림 30과 같이 포맷됩니다.

CRYPTO 프레임 {
유형(i) = 0x06,
오프셋(i),
길이(i),
암호화 데이터(..),
}

                       그림 30: CRYPTO 프레임 형식

CRYPTO 프레임에는 다음 필드가 포함됩니다.

오프셋: 바이트 오프셋을 지정하는 가변 길이 정수
이 CRYPTO 프레임의 데이터에 대한 스트림입니다.

길이: 길이를 지정하는 가변 길이 정수
이 CRYPTO 프레임의 암호화 데이터 필드입니다.

암호화 데이터: 암호화 메시지 데이터.

각 암호화 핸드셰이크 데이터의 별도 흐름이 있습니다.
각각 오프셋 0에서 시작하는 암호화 수준입니다.
각 암호화 수준이 별도의 CRYPTO로 처리된다는 것을 의미합니다.
데이터의 흐름.

스트림에 전달된 가장 큰 오프셋은 오프셋과
데이터 길이 - 2^62-1을 초과할 수 없습니다. 다음을 초과하는 프레임 수신
이 제한은 다음 유형의 연결 오류로 처리되어야 합니다.
FRAME_ENCODING_ERROR 또는 CRYPTO_BUFFER_EXCEEDED.

스트림 ID를 포함하는 STREAM 프레임과 달리
데이터가 속한 스트림, CRYPTO 프레임은 단일 데이터를 전송합니다.
암호화 수준별 스트림입니다. 스트림에는 명시적인
끝이므로 CRYPTO 프레임에는 FIN 비트가 없습니다.

19.7. NEW_TOKEN 프레임

서버는 클라이언트에게 NEW_TOKEN 프레임(type=0x07)을 전송합니다.
미래를 위한 초기 패킷 헤더에 보낼 토큰 포함
연결.

NEW_TOKEN 프레임은 그림 31과 같이 포맷됩니다.

NEW_TOKEN 프레임 {
유형(i) = 0x07,
토큰 길이(i),
토큰(..),
}

                     그림 31: NEW_TOKEN 프레임 형식

NEW_TOKEN 프레임에는 다음 필드가 포함됩니다.

토큰 길이: 토큰 길이를 지정하는 가변 길이 정수
바이트 단위의 토큰.

토큰: 클라이언트가 향후 초기값으로 사용할 수 있는 불투명한 블롭
패킷. 토큰은 비어 있으면 안 됩니다. 클라이언트는 수신을 처리해야 합니다.
연결로 빈 토큰 필드가 있는 NEW_TOKEN 프레임의 경우
FRAME_ENCODING_ERROR 유형의 오류입니다.

클라이언트는 다음을 포함하는 여러 NEW_TOKEN 프레임을 수신할 수 있습니다.
프레임을 포함하는 패킷이 잘못된 경우 동일한 토큰 값
분실된 것으로 확인되었습니다. 고객은 폐기에 대한 책임이 있습니다.
연결 시도를 연결하는 데 사용될 수 있는 중복 값
섹션 8.1.3을 참조하세요.

클라이언트는 NEW_TOKEN 프레임을 보내서는 안 됩니다. 서버는 수신을 처리해야 합니다.
NEW_TOKEN 프레임의 연결 오류 유형
프로토콜 위반.

19.8. STREAM 프레임

STREAM 프레임은 암시적으로 스트림을 생성하고 스트림 데이터를 전달합니다.
STREAM 프레임의 유형 필드는 0b00001XXX(또는 집합) 형식을 취합니다.
0x08에서 0x0f까지의 값). 프레임의 하위 3비트
프레임에 존재하는 필드를 결정합니다.

* 프레임 유형의 OFF 비트(0x04)는 다음을 나타내도록 설정됩니다.
  Offset 필드가 존재합니다. 1로 설정된 경우 Offset 필드는
  현재. 0으로 설정하면 Offset 필드가 없고 Stream이
  데이터는 오프셋 0에서 시작합니다(즉, 프레임에 다음이 포함됩니다.
  스트림의 첫 번째 바이트 또는 아무것도 포함하지 않는 스트림의 끝
  데이터).

* 프레임 유형의 LEN 비트(0x02)는 다음을 나타내도록 설정됩니다.
  길이 필드가 존재합니다. 이 비트가 0으로 설정되면 길이
  필드가 없고 스트림 데이터 필드가 끝까지 확장됩니다.
  패킷. 이 비트가 1로 설정되면 길이 필드가 존재합니다.

* FIN 비트(0x01)는 프레임이 종료되었음을 나타냅니다.
  스트림. 스트림의 최종 크기는 오프셋과
  이 프레임의 길이.

엔드포인트는 오류로 인해 연결을 종료해야 합니다.
로컬에 대한 STREAM 프레임을 수신하는 경우 STREAM_STATE_ERROR
아직 생성되지 않은 시작된 스트림 또는 전송 전용 스트림
개울.

STREAM 프레임은 그림 32와 같이 포맷됩니다.

스트림 프레임 {
유형(i) = 0x08..0x0f,
스트림 ID(i),
[오프셋(i)],
[길이(i)],
스트림 데이터(..),
}

                       그림 32: STREAM 프레임 형식

STREAM 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 스트림 ID를 나타내는 가변 길이 정수
스트림; 섹션 2.1을 참조하세요.

오프셋: 바이트 오프셋을 지정하는 가변 길이 정수
이 STREAM 프레임의 데이터에 대한 스트림입니다. 이 필드는 다음과 같습니다.
OFF 비트가 1로 설정된 경우. Offset 필드가 없는 경우
오프셋은 0입니다.

길이: 길이를 지정하는 가변 길이 정수
이 STREAM 프레임의 스트림 데이터 필드입니다. 이 필드는 존재합니다.
LEN 비트가 1로 설정되면. LEN 비트가 0으로 설정되면
스트림 데이터 필드는 패킷의 나머지 바이트를 모두 소모합니다.

스트림 데이터: 지정된 스트림에서 전달되는 바이트입니다.

Stream Data 필드의 길이가 0인 경우 STREAM의 오프셋은 다음과 같습니다.
프레임은 전송될 다음 바이트의 오프셋입니다.

스트림의 첫 번째 바이트는 오프셋이 0입니다. 가장 큰 오프셋
스트림으로 전달됨 -- 오프셋과 데이터 길이의 합 --
흐름 제어를 제공할 수 없으므로 2^62-1을 초과할 수 없습니다.
해당 데이터에 대한 크레딧입니다. 이 제한을 초과하는 프레임 수신
FRAME_ENCODING_ERROR 유형의 연결 오류로 처리되어야 합니다.
흐름 제어 오류.

19.9. MAX_DATA 프레임

MAX_DATA 프레임(유형=0x10)은 흐름 제어에 사용되어 다음을 알려줍니다.
연결에서 보낼 수 있는 최대 데이터 양의 피어
전체적으로.

MAX_DATA 프레임은 그림 33과 같이 포맷됩니다.

MAX_DATA 프레임 {
유형(i) = 0x10,
최대 데이터(i),
}

                      그림 33: MAX_DATA 프레임 형식

MAX_DATA 프레임에는 다음 필드가 포함됩니다.

최대 데이터: 최대값을 나타내는 가변 길이 정수
전체 연결에서 보낼 수 있는 데이터 양(단위)
바이트.

STREAM 프레임으로 전송된 모든 데이터는 이 제한에 포함됩니다.
터미널의 스트림을 포함한 모든 스트림의 최종 크기
상태 - 수신자가 광고한 가치를 초과해서는 안 됩니다.
엔드포인트는 오류 유형으로 연결을 종료해야 합니다.
최대 데이터 수보다 많은 데이터를 수신하면 FLOW_CONTROL_ERROR가 발생합니다.
전송한 값입니다. 여기에는 기억된 위반 사항이 포함됩니다.
초기 데이터의 한계; 섹션 7.4.1 참조.

19.10. MAX_STREAM_DATA 프레임

MAX_STREAM_DATA 프레임(유형=0x11)은 흐름 제어에 사용되어 정보를 제공합니다.
스트림으로 전송할 수 있는 최대 데이터 양의 피어입니다.

"Recv" 상태의 스트림에 대해 MAX_STREAM_DATA 프레임을 보낼 수 있습니다.
섹션 3.2를 참조하세요. 로컬에 대한 MAX_STREAM_DATA 프레임 수신
아직 생성되지 않은 시작된 스트림은 다음과 같이 처리되어야 합니다.
STREAM_STATE_ERROR 유형의 연결 오류입니다.
수신 전용 스트림에 대해 MAX_STREAM_DATA 프레임을 수신해야 합니다.
STREAM_STATE_ERROR 오류로 인해 연결을 종료합니다.

MAX_STREAM_DATA 프레임은 그림 34와 같이 포맷됩니다.

MAX_STREAM_DATA 프레임 {
유형(i) = 0x11,
스트림 ID(i),
최대 스트림 데이터(i),
}

                  그림 34: MAX_STREAM_DATA 프레임 형식

MAX_STREAM_DATA 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 영향을 받는 스트림의 스트림 ID(인코딩됨)
가변 길이 정수.

최대 스트림 데이터: 최대 스트림 데이터 크기를 나타내는 가변 길이 정수
식별된 스트림에서 전송할 수 있는 최대 데이터 양
바이트 단위로.

이 한도에 대한 데이터를 계산할 때 엔드포인트는 다음을 고려합니다.
전송되거나 수신된 데이터의 가장 큰 수신 오프셋
스트림. 손실 또는 재정렬은 수신된 가장 큰 오프셋을 의미할 수 있습니다.
스트림의 크기는 수신된 데이터의 총 크기보다 클 수 있습니다.
해당 스트림. STREAM 프레임을 수신해도 가장 큰 값이 증가하지 않을 수 있습니다.
수신된 오프셋.

스트림에 전송된 데이터는 최대 스트림 크기를 초과해서는 안 됩니다.
수신기가 광고하는 데이터 값입니다. 엔드포인트는 다음을 종료해야 합니다.
FLOW_CONTROL_ERROR 유형의 오류가 있는 연결
전송한 가장 큰 최대 스트림 데이터보다 더 많은 데이터
영향을 받는 스트림. 여기에는 기억된 제한 위반이 포함됩니다.
초기 데이터에서는 섹션 7.4.1을 참조하세요.

19.11. MAX_STREAMS 프레임

MAX_STREAMS 프레임(유형=0x12 또는 0x13)은 피어에게 다음을 알립니다.
주어진 유형의 스트림을 열 수 있는 누적 개수입니다.
0x12 유형의 MAX_STREAMS 프레임은 양방향에 적용됩니다.
스트림 및 0x13 유형의 MAX_STREAMS 프레임이 적용됩니다.
단방향 스트림.

MAX_STREAMS 프레임은 그림 35와 같이 포맷됩니다.

MAX_STREAMS 프레임 {
유형 (i) = 0x12..0x13,
최대 스트림(i),
}

                    그림 35: MAX_STREAMS 프레임 형식

MAX_STREAMS 프레임에는 다음 필드가 포함됩니다.

최대 스트림: 누적 스트림 수를 계산합니다.
수명 동안 열 수 있는 해당 유형
연결. 이 값은 2^60을 초과할 수 없습니다.
2^62-1보다 큰 스트림 ID를 인코딩하려면 프레임을 수신합니다.
이 한계보다 큰 스트림을 여는 허가는 반드시 처리되어야 합니다.
FRAME_ENCODING_ERROR 유형의 연결 오류로 인해.

손실 또는 재정렬로 인해 엔드포인트가 MAX_STREAMS를 수신할 수 있습니다.
이전에 수신한 것보다 스트림 한도가 낮은 프레임입니다.
스트림 제한을 늘리지 않는 MAX_STREAMS 프레임은 반드시 있어야 합니다.
무시됨.

엔드포인트는 현재 허용된 것보다 더 많은 스트림을 열면 안 됩니다.
피어가 설정한 스트림 제한입니다. 예를 들어,
단방향 스트림 제한 3은 스트림 3, 7을 열 수 있도록 허용됩니다.
11이지만 스트림 15는 아닙니다. 엔드포인트는 연결을 종료해야 합니다.
피어가 더 많은 스트림을 열면 STREAM_LIMIT_ERROR 유형의 오류가 발생합니다.
허용된 것보다 더 많은. 여기에는 기억된 한계 위반이 포함됩니다.
초기 데이터; 섹션 7.4.1 참조.

이러한 프레임(및 해당 전송 매개변수)에 유의하세요.
열 수 있는 스트림의 수를 설명하지 마십시오
동시에. 제한에는 닫힌 스트림이 포함됩니다.
그리고 열려 있는 것들도 있습니다.

19.12. DATA_BLOCKED 프레임

발신자는 원할 때 DATA_BLOCKED 프레임(유형=0x14)을 보내야 합니다.
데이터를 보내려고 하지만 연결 수준 흐름으로 인해 데이터를 보낼 수 없습니다.
제어; 섹션 4 참조. DATA_BLOCKED 프레임은 입력으로 사용될 수 있습니다.
흐름 제어 알고리즘의 조정; 섹션 4.2 참조.

DATA_BLOCKED 프레임은 그림 36과 같이 포맷됩니다.

DATA_BLOCKED 프레임 {
유형(i) = 0x14,
최대 데이터(i),
}

                    그림 36: DATA_BLOCKED 프레임 형식

DATA_BLOCKED 프레임에는 다음 필드가 포함됩니다.

최대 데이터: 연결을 나타내는 가변 길이 정수
차단이 발생한 수준 제한입니다.

19.13. STREAM_DATA_BLOCKED 프레임

발신자는 STREAM_DATA_BLOCKED 프레임(유형=0x15)을 보내야 합니다.
데이터를 보내고 싶어하지만 스트림 수준 흐름으로 인해 보낼 수 없습니다.
제어. 이 프레임은 DATA_BLOCKED(19.12절)와 유사합니다.

전송 전용 STREAM_DATA_BLOCKED 프레임을 수신하는 엔드포인트
스트림은 STREAM_STATE_ERROR 오류로 연결을 종료해야 합니다.

STREAM_DATA_BLOCKED 프레임은 그림 37과 같이 포맷됩니다.

STREAM_DATA_BLOCKED 프레임 {
유형(i) = 0x15,
스트림 ID(i),
최대 스트림 데이터(i),
}

                그림 37: STREAM_DATA_BLOCKED 프레임 형식

STREAM_DATA_BLOCKED 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 스트림을 나타내는 가변 길이 정수
흐름 제어로 인해 차단되었습니다.

최대 스트림 데이터: 오프셋을 나타내는 가변 길이 정수
차단이 발생한 스트림의.

19.14. STREAMS_BLOCKED 프레임

발신자는 STREAMS_BLOCKED 프레임(유형=0x16 또는 0x17)을 보내야 합니다.
스트림을 열려고 하지만 최대값으로 인해 스트림을 열 수 없습니다.
피어가 설정한 스트림 제한입니다. 섹션 19.11을 참조하세요. STREAMS_BLOCKED
0x16 유형의 프레임은 양방향 도달을 나타내는 데 사용됩니다.
스트림 제한 및 0x17 유형의 STREAMS_BLOCKED 프레임이 사용됩니다.
단방향 스트림 한계에 도달했음을 나타냅니다.

STREAMS_BLOCKED 프레임은 스트림을 열지 않지만 다음을 알려줍니다.
새로운 스트림이 필요하고 스트림 제한으로 인해 방해를 받는 피어
스트림의 생성.

STREAMS_BLOCKED 프레임은 그림 38과 같이 포맷됩니다.

STREAMS_BLOCKED 프레임 {
유형 (i) = 0x16..0x17,
최대 스트림(i),
}

                  그림 38: STREAMS_BLOCKED 프레임 형식

STREAMS_BLOCKED 프레임에는 다음 필드가 포함됩니다.

최대 스트림: 최대 스트림을 나타내는 가변 길이 정수
프레임이 전송될 당시 허용된 스트림 수입니다.
스트림을 인코딩할 수 없으므로 값은 2^60을 초과할 수 없습니다.
2^62-1보다 큰 ID. 더 큰 값을 인코딩하는 프레임 수신
스트림 ID는 다음 유형의 연결 오류로 처리되어야 합니다.
STREAM_LIMIT_ERROR 또는 FRAME_ENCODING_ERROR.

19.15. NEW_CONNECTION_ID 프레임

엔드포인트는 NEW_CONNECTION_ID 프레임(유형=0x18)을 전송하여 제공합니다.
연결 ID를 대체하여 사용할 수 있는 피어
연결을 마이그레이션할 때의 연결성; 섹션 9.5 참조.

NEW_CONNECTION_ID 프레임은 그림 39와 같이 포맷됩니다.

NEW_CONNECTION_ID 프레임 {
유형(i) = 0x18,
일련번호(i),
(i) 이전에 은퇴하세요.
길이(8),
연결 ID(8..160),
상태 비저장 재설정 토큰(128),
}

                 그림 39: NEW_CONNECTION_ID 프레임 형식

NEW_CONNECTION_ID 프레임에는 다음 필드가 포함됩니다.

시퀀스 번호: 연결 ID에 할당된 시퀀스 번호
발신자에 의해 가변 길이 정수로 인코딩됨 참조
섹션 5.1.1.

이전에 은퇴: 다음 중 하나를 나타내는 가변 길이 정수
연결 ID는 폐기되어야 합니다. 섹션 5.1.2를 참조하세요.

길이: 길이를 포함하는 8비트 부호 없는 정수
연결 ID입니다. 1보다 작거나 20보다 큰 값은 유효하지 않습니다.
그리고 연결 오류 유형으로 처리되어야 합니다.
프레임 인코딩 오류.

연결 ID: 지정된 길이의 연결 ID입니다.

상태 비저장 재설정 토큰: 다음에 사용될 128비트 값
연관된 연결 ID가 사용될 때 상태 비저장 재설정 참조
섹션 10.3.

현재 엔드포인트가 이 프레임을 요구하는 경우 엔드포인트는 이 프레임을 보내서는 안 됩니다.
피어가 길이가 0인 대상 연결 ID로 패킷을 보냅니다.
연결 ID의 길이를 0으로 변경하거나 0에서 변경하면
연결 ID 값이 변경된 시점을 식별하기 어렵습니다.
0 길이의 목적지를 갖는 패킷을 보내는 엔드포인트
연결 ID는 NEW_CONNECTION_ID 프레임 수신을 다음과 같이 처리해야 합니다.
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

전송 오류, 시간 초과 및 재전송으로 인해 다음이 발생할 수 있습니다.
동일한 NEW_CONNECTION_ID 프레임을 여러 번 수신합니다. 수신
동일한 프레임의 여러 번은 연결로 처리되어서는 안 됩니다.
오류. 수신기는 제공된 시퀀스 번호를 사용할 수 있습니다.
동일한 수신을 처리하기 위한 NEW_CONNECTION_ID 프레임
NEW_CONNECTION_ID 프레임을 여러 번 사용합니다.

엔드포인트가 반복되는 NEW_CONNECTION_ID 프레임을 수신하는 경우
이전에 발급된 연결 ID와 다른 Stateless Reset
토큰 필드 값 또는 다른 시퀀스 번호 필드 값 또는
시퀀스 번호는 다른 연결 ID, 엔드포인트에 사용됩니다.
해당 영수증을 연결 오류 유형으로 처리할 수 있습니다.
프로토콜 위반.

Retire Prior To 필드는 설정된 연결 ID에 적용됩니다.
연결 설정 중 및 선호하는 주소 전송
매개변수; 섹션 5.1.2 참조. Retire Prior To 필드의 값
반드시 시퀀스 번호 필드의 값보다 작거나 같아야 합니다.
Retire Prior To 필드에서 다음보다 큰 값을 수신합니다.
시퀀스 번호 필드에서 연결로 처리되어야 합니다.
FRAME_ENCODING_ERROR 유형의 오류입니다.

발신자가 Retire Prior To 값을 표시하면 더 작은 값이 전송됩니다.
이후 NEW_CONNECTION_ID 프레임에서는 효과가 없습니다. 수신기
증가하지 않는 Retire Prior To 필드는 반드시 무시해야 합니다.
가장 큰 수신 은퇴 전 가치.

시퀀스를 포함하는 NEW_CONNECTION_ID 프레임을 수신하는 엔드포인트
이전에 Retire Prior To 필드보다 작은 숫자
수신된 NEW_CONNECTION_ID 프레임은 해당 프레임을 보내야 합니다.
새로 수신된 연결을 종료하는 RETIRE_CONNECTION_ID 프레임
ID(해당 시퀀스 번호에 대해 이미 수행한 경우가 아니면)

19.16. RETIRE_CONNECTION_ID 프레임

엔드포인트는 RETIRE_CONNECTION_ID 프레임(유형=0x19)을 전송합니다.
발급된 연결 ID를 더 이상 사용하지 않을 것임을 나타냅니다.
피어에 의해. 여기에는 제공된 연결 ID가 포함됩니다.
핸드셰이크. RETIRE_CONNECTION_ID 프레임을 보내는 것도
향후 사용을 위해 추가 연결 ID를 보내달라고 피어에게 요청합니다.
섹션 5.1을 참조하세요. 새 연결 ID는 다음을 사용하여 피어에게 전달될 수 있습니다.
NEW_CONNECTION_ID 프레임(섹션 19.15).

연결 ID를 폐기하면 상태 비저장 재설정 토큰이 무효화됩니다.
해당 연결 ID와 연관됨.

RETIRE_CONNECTION_ID 프레임은 그림 40과 같이 포맷됩니다.

RETIRE_CONNECTION_ID 프레임 {
유형(i) = 0x19,
일련번호(i),
}

                그림 40: RETIRE_CONNECTION_ID 프레임 형식

RETIRE_CONNECTION_ID 프레임에는 다음 필드가 포함됩니다.

시퀀스 번호: 연결 ID의 시퀀스 번호
은퇴; 섹션 5.1.2 참조.

시퀀스 번호가 포함된 RETIRE_CONNECTION_ID 프레임 수신
이전에 피어에게 보낸 것보다 더 큰 것은 반드시 다음과 같이 처리되어야 합니다.
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

RETIRE_CONNECTION_ID 프레임에 지정된 시퀀스 번호는 다음과 같아야 합니다.
패킷의 대상 연결 ID 필드를 참조하지 마십시오.
프레임이 포함되어 있습니다. 피어는 이것을 다음과 같이 처리할 수 있습니다.
PROTOCOL_VIOLATION 유형의 연결 오류입니다.

0이 제공된 경우 엔드포인트는 이 프레임을 보낼 수 없습니다.
피어가 지정한 길이의 연결 ID입니다. 0을 제공하는 엔드포인트
길이 연결 ID는 RETIRE_CONNECTION_ID 수신을 처리해야 합니다.
프레임은 PROTOCOL_VIOLATION 유형의 연결 오류로 나타납니다.

19.17. PATH_CHALLENGE 프레임

엔드포인트는 PATH_CHALLENGE 프레임(유형=0x1a)을 사용하여 확인할 수 있습니다.
연결 중 피어에 대한 도달 가능성 및 경로 검증
이주.

PATH_CHALLENGE 프레임은 그림 41과 같이 포맷됩니다.

PATH_CHALLENGE 프레임 {
유형(i) = 0x1a,
데이터(64),
}

                   그림 41: PATH_CHALLENGE 프레임 형식

PATH_CHALLENGE 프레임에는 다음 필드가 포함됩니다.

데이터: 이 8바이트 필드에는 임의의 데이터가 들어 있습니다.

PATH_CHALLENGE 프레임에 64비트의 엔트로피를 포함하면 다음이 보장됩니다.
패킷을 받는 것이 값을 추측하는 것보다 더 쉽습니다.
바르게.

이 프레임의 수신자는 PATH_RESPONSE 프레임을 생성해야 합니다.
(섹션 19.18) 동일한 데이터 값을 포함합니다.

19.18. PATH_RESPONSE 프레임

PATH_RESPONSE 프레임(유형=0x1b)은 다음에 대한 응답으로 전송됩니다.
PATH_CHALLENGE 프레임.

PATH_RESPONSE 프레임은 그림 42에 표시된 대로 포맷됩니다.
PATH_RESPONSE 프레임의 경우 PATH_CHALLENGE 프레임과 동일합니다.
프레임; 섹션 19.17을 참조하세요.

PATH_RESPONSE 프레임 {
유형(i) = 0x1b,
데이터(64),
}

                   그림 42: PATH_RESPONSE 프레임 형식

PATH_RESPONSE 프레임의 내용이 다음 내용과 일치하지 않는 경우
엔드포인트에서 이전에 보낸 PATH_CHALLENGE 프레임, 엔드포인트
PROTOCOL_VIOLATION 유형의 연결 오류가 발생할 수 있습니다.

19.19. CONNECTION_CLOSE 프레임

엔드포인트는 CONNECTION_CLOSE 프레임(유형=0x1c 또는 0x1d)을 전송합니다.
연결이 닫히고 있음을 피어에게 알립니다.
0x1c 유형의 CONNECTION_CLOSE 프레임은 오류를 신호하는 데 사용됩니다.
QUIC 계층에서만 또는 오류가 없는 경우(NO_ERROR 포함)
코드). 0x1d 유형의 CONNECTION_CLOSE 프레임이 사용됩니다.
QUIC를 사용하는 애플리케이션에 오류를 알립니다.

명시적으로 닫히지 않은 열려 있는 스트림이 있는 경우
연결이 닫히면 암묵적으로 닫힙니다.

CONNECTION_CLOSE 프레임은 그림 43과 같이 포맷됩니다.

CONNECTION_CLOSE 프레임 {
유형 (i) = 0x1c..0x1d,
오류 코드(i),
[프레임 유형(i)],
이유 구문 길이(i),
이유 구문(..),
}

                  그림 43: CONNECTION_CLOSE 프레임 형식

CONNECTION_CLOSE 프레임에는 다음 필드가 포함됩니다.

오류 코드: 오류 원인을 나타내는 가변 길이 정수
이 연결을 닫습니다. 0x1c 유형의 CONNECTION_CLOSE 프레임
섹션 20.1에 정의된 공간의 코드를 사용합니다. A
0x1d 유형의 CONNECTION_CLOSE 프레임은 다음에 의해 정의된 코드를 사용합니다.
응용 프로그램 프로토콜; 섹션 20.2를 참조하세요.

프레임 유형: 프레임 유형을 인코딩하는 가변 길이 정수
오류를 유발한 값입니다. 0(언급과 동일)
PADDING 프레임의 경우 프레임 유형을 알 수 없는 경우 사용됩니다.
CONNECTION_CLOSE의 애플리케이션별 변형(유형 0x1d)은 다음과 같습니다.
이 필드는 포함하지 않습니다.

이유 구문 길이: 다음을 지정하는 가변 길이 정수
이유 구문의 길이(바이트). CONNECTION_CLOSE
프레임은 패킷 간에 분할될 수 없으며 패킷 크기에 제한이 있습니다.
또한 이유를 설명하는 데 사용할 수 있는 공간도 제한됩니다.

사유 문구: 폐쇄에 대한 추가 진단 정보입니다.
발신자가 세부 정보를 제공하지 않기로 선택한 경우 길이가 0이 될 수 있습니다.
오류 코드 값을 넘어선 값입니다. 이는 UTF-8로 인코딩되어야 합니다.
문자열 [RFC3629], 프레임은 정보를 전달하지 않지만,
예를 들어, 모든 엔터티의 이해를 돕는 언어 태그와 같은
텍스트를 만든 사람이 아닌 다른 사람.

CONNECTION_CLOSE의 애플리케이션별 변형(유형 0x1d)은 다음과 같습니다.
0-RTT 또는 1-RTT 패킷을 사용하여만 전송됩니다. 섹션 12.5를 참조하세요.
응용 프로그램이 핸드셰이크 중에 연결을 포기하려고 합니다.
엔드포인트는 오류와 함께 CONNECTION_CLOSE 프레임(유형 0x1c)을 보낼 수 있습니다.
초기 또는 핸드셰이크 패킷의 APPLICATION_ERROR 코드입니다.

19.20. HANDSHAKE_DONE 프레임

서버는 HANDSHAKE_DONE 프레임(type=0x1e)을 사용하여 신호를 보냅니다.
고객에게 악수를 확인합니다.

HANDSHAKE_DONE 프레임은 그림 44에 표시된 대로 포맷됩니다.
HANDSHAKE_DONE 프레임에 내용이 없음을 보여줍니다.

HANDSHAKE_DONE 프레임 {
유형(i) = 0x1e,
}

                   그림 44: HANDSHAKE_DONE 프레임 형식

HANDSHAKE_DONE 프레임은 서버에서만 전송할 수 있습니다. 서버는 반드시
핸드셰이크를 완료하기 전에 HANDSHAKE_DONE 프레임을 보내지 마십시오.
서버는 HANDSHAKE_DONE 프레임 수신을 연결로 처리해야 합니다.
PROTOCOL_VIOLATION 유형의 오류입니다.

19.21. 확장 프레임

QUIC 프레임은 자체 설명 인코딩을 사용하지 않습니다. 엔드포인트
따라서 모든 프레임의 구문을 이해해야 합니다.
패킷을 성공적으로 처리합니다. 이를 통해 효율적인 인코딩이 가능합니다.
프레임이지만 이는 엔드포인트가 유형의 프레임을 보낼 수 없음을 의미합니다.
다른 사람이 모르는 것.

새로운 유형의 프레임을 사용하려는 QUIC 확장은 다음을 수행해야 합니다.
먼저 동료가 프레임을 이해할 수 있는지 확인하십시오.
엔드포인트는 전송 매개변수를 사용하여 자신의 의지를 표시할 수 있습니다.
수신 확장 프레임 유형. 하나의 전송 매개변수는 다음을 나타낼 수 있습니다.
하나 이상의 확장 프레임 유형을 지원합니다.

핵심 프로토콜 기능을 수정하거나 대체하는 확장
(프레임 유형 포함) 다른 것과 결합하기 어려울 것입니다.
동일한 기능을 수정하거나 대체하는 확장 기능은 다음과 같습니다.
조합의 동작은 명시적으로 정의됩니다. 이러한 확장은
이전에 정의된 확장 프로그램과의 상호 작용을 정의해야 합니다.
동일한 프로토콜 구성 요소를 수정합니다.

확장 프레임은 혼잡 제어되어야 하며 ACK를 발생시켜야 합니다.
보낼 프레임입니다. 예외는 대체하거나 확장하는 프레임입니다.
ACK 프레임을 보완합니다. 확장 프레임은 흐름에 포함되지 않습니다.
확장자에 지정되지 않는 한 제어가 불가능합니다.

IANA 레지스트리는 프레임 유형 할당을 관리하는 데 사용됩니다. 참조
섹션 22.4.

20. 오류 코드

QUIC 전송 오류 코드와 애플리케이션 오류 코드는 62비트입니다.
부호 없는 정수.

20.1. 전송 오류 코드

이 섹션에서는 정의된 QUIC 전송 오류 코드를 나열합니다.
0x1c 유형의 CONNECTION_CLOSE 프레임에서 사용됩니다. 이러한 오류는
전체 연결에 적용됩니다.

NO_ERROR(0x00): 엔드포인트는 이것을 CONNECTION_CLOSE와 함께 사용합니다.
연결이 갑자기 끊어진다는 신호
어떠한 오류에 대해서도.

INTERNAL_ERROR(0x01): 엔드포인트에서 내부 오류가 발생했습니다.
연결을 계속할 수 없습니다.

CONNECTION_REFUSED(0x02): 서버가 새 연결을 수락하지 않았습니다.
연결.

FLOW_CONTROL_ERROR(0x03): 엔드포인트가 수신한 데이터 양이 너무 많습니다.
광고된 데이터 한도 내에서 허용됩니다. 섹션 4를 참조하세요.

STREAM_LIMIT_ERROR(0x04): 엔드포인트가 스트림에 대한 프레임을 수신했습니다.
광고된 스트림 제한을 초과한 식별자
해당 스트림 유형.

STREAM_STATE_ERROR(0x05): 엔드포인트가 스트림에 대한 프레임을 수신했습니다.
해당 프레임을 허용하는 상태가 아니었습니다. 섹션 3을 참조하세요.

FINAL_SIZE_ERROR(0x06): (1) 엔드포인트가 STREAM 프레임을 수신했습니다.
이전에 설정된 최종 데이터를 초과하는 데이터가 포함되어 있습니다.
크기, (2) 엔드포인트가 STREAM 프레임 또는 RESET_STREAM을 수신했습니다.
최종 크기가 프레임의 크기보다 작았습니다.
이미 수신된 스트림 데이터 또는 (3) 수신된 엔드포인트
다른 것을 포함하는 STREAM 프레임 또는 RESET_STREAM 프레임
최종 크기를 이미 설정된 크기에 맞춥니다.

FRAME_ENCODING_ERROR(0x07): 엔드포인트가 프레임을 수신했습니다.
형식이 잘못된 경우(예: 알 수 없는 유형의 프레임 또는
나머지보다 더 많은 확인 범위를 갖는 ACK 프레임
패킷에 담을 수 있는 짐의 양.

TRANSPORT_PARAMETER_ERROR(0x08): 엔드포인트가 전송을 수신했습니다.
형식이 잘못되었거나 잘못된 값이 포함된 매개변수
필수 전송 매개변수를 생략하고 금지된 매개변수를 포함했습니다.
전송 매개변수에 오류가 있었거나 그렇지 않은 경우.

CONNECTION_ID_LIMIT_ERROR(0x09): 연결 ID 수
피어가 제공한 것이 광고된 것보다 더 좋습니다.
활성_연결_ID_제한.

PROTOCOL_VIOLATION(0x0a): 엔드포인트에서 오류가 감지되었습니다.
더 구체적인 오류로 다루어지지 않은 프로토콜 준수
코드.

INVALID_TOKEN(0x0b): 서버가 클라이언트 Initial을 수신했습니다.
잘못된 토큰 필드가 포함되어 있습니다.

APPLICATION_ERROR(0x0c): 애플리케이션 또는 애플리케이션 프로토콜
연결이 끊어졌습니다.

CRYPTO_BUFFER_EXCEEDED(0x0d): 엔드포인트가 더 많은 데이터를 수신했습니다.
버퍼링할 수 있는 CRYPTO 프레임보다 많습니다.

KEY_UPDATE_ERROR(0x0e): 엔드포인트에서 업데이트 수행 중 오류가 감지되었습니다.
주요 업데이트; [QUIC-TLS]의 섹션 6을 참조하세요.

AEAD_LIMIT_REACHED(0x0f): 엔드포인트가 도달했습니다.
AEAD 알고리즘에 사용되는 기밀성 또는 무결성 한계
주어진 연결.

NO_VIABLE_PATH(0x10): 엔드포인트가 네트워크를 확인했습니다.
경로가 QUIC를 지원할 수 없습니다. 엔드포인트가
이 코드를 전달하는 CONNECTION_CLOSE 프레임을 수신합니다.
경로가 충분히 큰 MTU를 지원하지 않습니다.

CRYPTO_ERROR(0x0100-0x01ff): 암호화 핸드셰이크에 실패했습니다.
256개 값의 범위는 특정 오류 코드를 전달하기 위해 예약되어 있습니다.
사용되는 암호화 핸드셰이크에 대한 오류 코드
암호화 핸드셰이크에 TLS가 사용될 때 발생하는 문제는 다음과 같습니다.
[QUIC-TLS]의 섹션 4.8에 설명되어 있습니다.

새로운 오류 코드 등록에 대한 자세한 내용은 섹션 22.5를 참조하세요.

이러한 오류 코드를 정의할 때 몇 가지 원칙이 적용됩니다. 오류
특정 조치가 필요할 수 있는 조건
수신자에게는 고유 코드가 제공됩니다. 일반적인 오류를 나타내는 오류
조건에는 특정 코드가 지정됩니다. 이 중 어느 하나라도 없으면
조건, 오류 코드는 일반적인 기능을 식별하는 데 사용됩니다.
스택은 흐름 제어나 전송 매개변수 처리와 같습니다.
마지막으로, 다음과 같은 조건에 대한 일반 오류가 제공됩니다.
구현 시 더 구체적인 코드를 사용할 수 없거나 사용하려 하지 않습니다.

20.2. 애플리케이션 프로토콜 오류 코드

애플리케이션 오류 코드 관리가 애플리케이션에 맡겨집니다.
프로토콜. 응용 프로그램 프로토콜 오류 코드는 다음에 사용됩니다.
RESET_STREAM 프레임(섹션 19.4), STOP_SENDING 프레임
(섹션 19.5) 및 0x1d 유형의 CONNECTION_CLOSE 프레임
(섹션 19.19).

21. 보안 고려 사항

QUIC의 목표는 안전한 전송 연결을 제공하는 것입니다.
섹션 21.1에서는 해당 속성에 대한 개요를 제공합니다.
섹션에서는 이러한 속성에 대한 제약 조건과 주의 사항을 논의합니다.
알려진 공격과 대응책에 대한 설명을 포함합니다.

21.1. 보안 속성 개요

QUIC에 대한 완전한 보안 분석은 이 범위를 벗어납니다.
문서. 이 섹션에서는 다음에 대한 비공식적인 설명을 제공합니다.
구현자에게 도움이 되는 원하는 보안 속성
가이드 프로토콜 분석.

QUIC은 [SEC-CONS]에 설명된 위협 모델을 가정하고 제공합니다.
해당 모델에서 발생하는 많은 공격에 대한 보호 기능이 있습니다.

이를 위해 공격은 수동적 공격과 능동적 공격으로 구분된다.
공격. 수동 공격자는 패킷을 읽을 수 있는 능력이 있습니다.
네트워크, 활성 공격자는 또한 다음을 작성할 수 있습니다.
네트워크로 패킷을 전송합니다. 그러나 수동 공격에는 다음이 포함될 수 있습니다.
라우팅 변경이나 기타를 발생시킬 수 있는 공격자
연결을 구성하는 패킷의 경로가 변경되는 현상입니다.

공격자는 경로상 공격자 또는
경로 외 공격자. 경로 내 공격자는 읽기, 수정 또는 제거할 수 있습니다.
패킷이 더 이상 도달하지 않는 것을 관찰한 모든 패킷
목적지인 반면 경로 밖의 공격자는 패킷을 관찰하지만
원래 패킷이 의도한 대로 도달하는 것을 막을 수 없습니다.
목적지. 두 유형의 공격자 모두 임의의
패킷. 이 정의는 섹션 3.5의 정의와 다릅니다.
[SEC-CONS] 경로 밖의 공격자가 패킷을 관찰할 수 있다는 점입니다.

핸드셰이크, 보호 패킷 및 연결의 속성
이주는 별도로 고려됩니다.

21.1.1. 핸드셰이크

QUIC 핸드셰이크는 TLS 1.3 핸드셰이크를 통합하고 상속합니다.
[TLS13]의 부록 E.1에 설명된 암호화 속성.
QUIC의 많은 보안 속성은 TLS 핸드셰이크에 의존합니다.
이러한 속성을 제공합니다. TLS 핸드셰이크에 대한 모든 공격은
QUIC에 영향을 미칩니다.

TLS 핸드셰이크에 대한 모든 공격은 비밀 유지를 위협합니다.
세션 키의 고유성 또는 인증
참여하는 피어는 다른 보안 보장에 영향을 미칩니다.
해당 키에 의존하는 QUIC. 예를 들어, 마이그레이션(섹션 9)
기밀 보호의 효율성에 따라 달라집니다.
TLS 핸드셰이크를 사용한 키 협상 및 QUIC 패킷
보호, 네트워크 경로 간 연결성을 방지하기 위해.

TLS 핸드셰이크의 무결성에 대한 공격은 다음을 허용할 수 있습니다.
공격자가 애플리케이션 프로토콜 또는 QUIC 선택에 영향을 미치도록 함
버전.

TLS가 제공하는 속성 외에도 QUIC 핸드셰이크
핸드셰이크에 대한 DoS 공격에 대한 어느 정도의 방어 수단을 제공합니다.

21.1.1.1. 안티앰프

주소 검증(섹션 8)은 엔터티가 다음을 확인하는 데 사용됩니다.
주어진 주소가 해당 주소에서 패킷을 수신할 수 있다고 주장합니다.
주소 검증은 증폭 공격 대상을 주소로 제한합니다.
공격자가 패킷을 관찰할 수 있는 곳.

주소 검증 전에 엔드포인트는 다음과 같은 제한을 받습니다.
보낼 수 있습니다. 엔드포인트는 검증되지 않은 곳으로 데이터를 보낼 수 없습니다.
해당 주소에서 수신된 데이터의 3배를 초과하는 주소.

      | 참고: 반증폭 제한은 다음과 같은 경우에만 적용됩니다.
      | 엔드포인트는 검증되지 않은 패킷에 응답합니다.
      | 주소. 반증폭 제한은 적용되지 않습니다.
      | 클라이언트가 새 연결을 설정하거나 시작할 때
      | 연결 마이그레이션.

21.1.1.2. 서버 측 DoS

전체 핸드셰이크를 위한 서버의 첫 번째 비행을 계산하는 것은 다음과 같습니다.
서명과 키 교환이 모두 필요하므로 비용이 많이 들 수 있음
계산. 계산적 DoS 공격을 방지하기 위해
재시도 패킷은 저렴한 토큰 교환 메커니즘 을 제공합니다.
어떤 작업을 수행하기 전에 클라이언트의 IP 주소를 검증하기 위한 서버
단일 왕복 비용으로 값비싼 계산을 수행합니다.
성공적인 핸드셰이크가 이루어지면 서버는 클라이언트에게 새로운 토큰을 발급할 수 있습니다.
이 비용을 들이지 않고도 새로운 연결을 설정할 수 있습니다.

21.1.1.3. 경로 내 핸드셰이크 종료

경로 내 또는 경로 외 공격자는 다음을 통해 핸드셰이크가 실패하도록 강제할 수 있습니다.
초기 패킷을 교체하거나 경주합니다. 유효한 초기 패킷이 있으면
교환된 후 후속 핸드셰이크 패킷은 다음과 같이 보호됩니다.
핸드셰이크 키, 경로상 공격자는 핸드셰이크를 강제할 수 없습니다.
패킷을 삭제하여 엔드포인트가 포기되는 것 외의 실패
시도.

경로상 공격자는 패킷의 주소를 바꿀 수도 있습니다.
양쪽 모두 클라이언트 또는 서버가 다음을 갖도록 합니다.
원격 주소에 대한 잘못된 보기입니다. 이러한 공격은
NAT가 수행하는 기능과 구별할 수 없습니다.

21.1.1.4. 매개변수 협상

전체 핸드셰이크는 암호화되어 보호되며 초기
버전별 키와 핸드셰이크로 암호화되는 패킷
이후 패킷은 TLS 키에서 파생된 키로 암호화됩니다.
교환. 또한 매개변수 협상은 TLS에 통합됩니다.
전사본이므로 동일한 무결성 보장을 제공합니다.
일반적인 TLS 협상. 공격자는 클라이언트의
전송 매개변수(버전별 salt를 알고 있는 경우)
그러나 서버의 전송 매개변수를 관찰할 수 없으며
영향 매개변수 협상.

연결 ID는 암호화되지 않지만 모든 연결 ID의 무결성은 보호됩니다.
패킷.

이 QUIC 버전에는 버전 협상이 통합되어 있지 않습니다.
메커니즘; 호환되지 않는 버전의 구현은 단순히 실패할 것입니다.
연결을 설정하려면

21.1.2. 보호된 패킷

패킷 보호(섹션 12.1)는 인증된 암호화를 적용합니다.
버전 협상 패킷을 제외한 모든 패킷(초기 및
재시도 패킷은 버전 관리 사용으로 인해 보호가 제한됩니다.
특정 키잉 자료; 자세한 내용은 [QUIC-TLS]를 참조하세요.
섹션에서는 보호된 대상에 대한 수동 및 능동 공격을 고려합니다.
패킷.

경로 내 공격자와 경로 외 공격자 모두 수동 공격을 수행할 수 있습니다.
패킷에 대한 오프라인 공격을 위해 관찰된 패킷을 저장합니다.
미래의 보호; 이는 모든 관찰자에게 해당됩니다.
모든 네트워크의 패킷.

유효한 패킷을 관찰할 수 없이 패킷을 주입하는 공격자
연결을 위한 패킷은 패킷이 성공할 가능성이 낮습니다.
보호는 유효한 패킷이 엔드포인트에서만 생성되도록 보장합니다.
핸드셰이크 중에 확립된 주요 자료를 소유한 경우 참조
섹션 7 및 21.1.1. 마찬가지로, 관찰하는 모든 활성 공격자는
패킷 및 새 데이터를 삽입하거나 기존 데이터를 수정하려는 시도
해당 패킷은 유효한 것으로 간주되는 패킷을 생성할 수 없습니다.
초기 패킷을 제외한 수신 엔드포인트.

보호되지 않은 내용을 활성 공격자가 다시 쓰는 스푸핑 공격
패킷의 일부(예: 소스 또는)를 전달하거나 주입합니다.
대상 주소는 공격자가 전달할 수 있는 경우에만 효과적입니다.
패킷을 원래 엔드포인트로 전송합니다. 패킷 보호는 다음을 보장합니다.
패킷 페이로드는 완료된 엔드포인트에서만 처리될 수 있습니다.
핸드셰이크 및 유효하지 않은 패킷은 해당 엔드포인트에서 무시됩니다.

공격자는 패킷과 UDP 간의 경계를 수정할 수도 있습니다.
데이터그램을 통해 여러 패킷이 하나로 합쳐집니다.
데이터그램 또는 병합된 패킷을 여러 개의 데이터그램으로 분할합니다.
초기 패킷을 포함하는 데이터그램 외에 다음이 필요합니다.
패딩, 데이터그램에서 패킷이 배열되는 방식을 수정하는 것은 없습니다.
연결에 기능적 효과가 있지만 일부는 변경될 수 있습니다.
성능 특성.

21.1.3. 연결 마이그레이션

연결 마이그레이션(섹션 9)은 엔드포인트에 다음 기능을 제공합니다.
여러 경로의 IP 주소와 포트 간 전환을 위해 다음을 사용합니다.
비탐침 전송 및 수신을 위한 한 번에 하나의 경로
프레임. 경로 검증(섹션 8.2)은 피어가
특정 경로로 전송된 패킷을 수신할 의지와 능력이 모두 있습니다.
이는 주소 스푸핑의 영향을 제한하여 줄이는 데 도움이 됩니다.
위조된 주소로 전송된 패킷 수.

이 섹션에서는 연결의 의도된 보안 속성을 설명합니다.
다양한 유형의 DoS 공격에 따른 마이그레이션.

21.1.3.1. 경로 내 활성 공격

더 이상 패킷이 도달하지 못하도록 하는 공격자
의도된 목적지가 경로상 공격자로 간주됩니다.
공격자가 클라이언트와 서버 사이에 존재하고 엔드포인트는
공격자를 통해 패킷을 보내야 합니다.
주어진 경로의 연결성.

경로상 공격자는 다음을 수행할 수 있습니다.

* 패킷 검사

* IP 및 UDP 패킷 헤더 수정

* 새로운 패킷 주입

* 지연 패킷

* 패킷 재정렬

* 패킷 삭제

* 패킷 경계를 따라 데이터그램을 분할하고 병합합니다.

경로상 공격자는 다음을 수행할 수 없습니다.

* 패킷의 인증된 부분을 수정하고 다음을 발생시킵니다.
  수신자가 해당 패킷을 수락하도록 함

경로상 공격자는 자신이 사용하는 패킷을 수정할 수 있는 기회를 갖습니다.
관찰합니다. 그러나 인증된 부분에 대한 모든 수정 사항은
패킷은 수신 엔드포인트에서 삭제되도록 합니다.
패킷 페이로드는 인증되고 암호화되므로 유효하지 않습니다.

QUIC는 경로상 공격자의 역량을 제한하는 것을 목표로 합니다.
다음과 같습니다.

1. 경로 내 공격자는 경로 사용을 방지할 수 있습니다.
   연결, 사용할 수 없는 경우 연결이 실패합니다.
   공격자가 포함되지 않은 다른 경로입니다. 이는 다음과 같습니다.
   모든 패킷을 삭제하고 이를 수정하여 달성합니다.
   해독에 실패하거나 다른 방법이 있습니다.

2. 경로 내 공격자는 새로운 경로로의 마이그레이션을 방지할 수 있습니다.
   공격자는 경로 검증이 실패하도록 하여 경로에 있습니다.
   새로운 길로.

3. 경로상 공격자는 클라이언트가 다음 경로로 마이그레이션하는 것을 막을 수 없습니다.
   공격자가 경로에 없는 경로입니다.

4. 경로상 공격자는 연결 처리량을 다음과 같이 줄일 수 있습니다.
   패킷을 지연시키거나 삭제합니다.

5. 경로상 공격자는 엔드포인트가 패킷을 수락하도록 할 수 없습니다.
   인증된 부분을 수정한 경우
   패킷.

21.1.3.2. 경로 외 능동 공격

경로 외 공격자는 클라이언트와 경로 사이에 직접 존재하지 않습니다.
서버이지만 전송된 일부 또는 모든 패킷의 사본을 얻을 수 있습니다.
클라이언트와 서버 사이. 또한 사본을 보낼 수도 있습니다.
해당 패킷을 두 엔드포인트 중 하나로 보냅니다.

경로 외 공격자는 다음을 수행할 수 있습니다.

* 패킷 검사

* 새로운 패킷 주입

* 주입된 패킷을 재정렬합니다.

경로 외 공격자는 다음을 수행할 수 없습니다.

* 엔드포인트에서 보낸 패킷 수정

* 지연 패킷

* 패킷 삭제

* 원래 패킷을 다시 주문하세요

경로 외 공격자는 패킷의 수정된 복사본을 생성할 수 있습니다.
해당 사본을 관찰하고 네트워크에 주입할 가능성이 있습니다.
위조된 출발지 및 목적지 주소가 있습니다.

이 논의의 목적을 위해 오프 패스가 가정됩니다.
공격자는 패킷의 수정된 사본을 주입할 수 있는 능력을 가지고 있습니다.
목적지 종단점에 도달할 네트워크
공격자가 관찰한 원래 패킷의 도착. 다른 경우
즉, 공격자는 지속적으로 경쟁에서 "승리"할 수 있는 능력을 가지고 있습니다.
엔드포인트 간의 합법적인 패킷은 잠재적으로 다음을 발생시킵니다.
수신자가 원래 패킷을 무시합니다.

또한 공격자는 필요한 리소스를 가지고 있다고 가정합니다.
NAT 상태에 영향을 미칩니다. 특히 공격자는 엔드포인트를
NAT 바인딩을 잃은 후 동일한 포트를 사용하여 가져옵니다.
자체 교통.

QUIC는 경로 외 공격자의 역량을 제한하는 것을 목표로 합니다.
다음과 같습니다.

1. 경로 외 공격자는 패킷을 경쟁시키고 공격자가 되려고 시도할 수 있습니다.
   "제한된" 경로상의 공격자.

2. 경로 외 공격자는 경로 검증이 성공하도록 할 수 있습니다.
   소스 주소가 오프패스로 나열된 패킷을 전달합니다.
   공격자는 더 나은 연결성을 제공할 수 있는 한
   클라이언트와 서버.

3. 경로 외 공격자는 연결이 끊어지는 원인이 될 수 없습니다.
   악수가 완료되었습니다.

4. 경로 외 공격자는 새 경로로의 마이그레이션이 실패하도록 할 수 없습니다.
   새로운 경로를 관찰할 수 없는 경우.

5. 경로 외 공격자는 제한된 경로 내 공격자가 될 수 있습니다.
   새로운 경로로의 마이그레이션은 또한 오프 경로입니다.
   공격자.

6. 경로 외 공격자는 다음을 통해 제한된 경로 내 공격자가 될 수 있습니다.
   공유 NAT 상태에 영향을 미쳐 패킷을 전송합니다.
   클라이언트와 동일한 IP 주소 및 포트의 서버
   원래 사용됨.

21.1.3.3. 제한된 경로 내 활성 공격

제한된 경로 내 공격자는 제공된 경로 외 공격자입니다.
원본을 복제하고 전달하여 패킷 라우팅을 개선했습니다.
서버와 클라이언트 간의 패킷을 통해 해당 패킷이
원본 패킷이 도착하기 전에 원본 사본이 도착하도록 합니다.
대상 엔드포인트에 의해 삭제되었습니다.

제한된 경로 공격자는 경로 공격자와 다릅니다.
이는 종점 사이의 원래 경로에 없으므로
엔드포인트에서 보낸 원래 패킷이 여전히 해당 위치에 도달 중입니다.
목적지. 이는 향후 경로 복사 실패를 의미합니다.
패킷이 원래 경로보다 더 빠르게 목적지로 전송되지 않습니다.
원래 패킷이 목적지에 도달하는 것을 방지합니다.

제한된 경로상의 공격자는 다음을 수행할 수 있습니다.

* 패킷 검사

* 새로운 패킷 주입

* 암호화되지 않은 패킷 헤더 수정

* 패킷 재정렬

제한된 경로상의 공격자는 다음을 수행할 수 없습니다.

* 패킷이 전송된 시간보다 늦게 도착하도록 패킷을 지연시킵니다.
  원래 경로

* 패킷 삭제

* 패킷의 인증 및 암호화된 부분을 수정하고
  수신자가 해당 패킷을 수락하도록 합니다.

제한된 경로상의 공격자는 패킷을 해당 지점까지만 지연시킬 수 있습니다.
원본 패킷이 중복 패킷보다 먼저 도착한다는 점입니다.
즉, 더 나쁜 지연 시간으로 라우팅을 제공할 수 없다는 의미입니다.
원래 경로. 제한된 경로 공격자가 패킷을 삭제하는 경우
원본 사본은 목적지에 도착하게 됩니다.

QUIC는 제한된 오프패스의 기능을 제한하는 것을 목표로 합니다.
공격자는 다음과 같습니다.

1. 제한된 경로상의 공격자는 연결을 닫을 수 없습니다.
   악수가 끝나면.

2. 제한된 경로상의 공격자는 유휴 연결을 발생시킬 수 없습니다.
   클라이언트가 먼저 활동을 재개하면 닫힙니다.

3. 제한된 경로 공격자는 유휴 연결을 유발할 수 있습니다.
   서버가 먼저 활동을 재개하면 손실된 것으로 간주됩니다.

이러한 보증은 모든 보증에 대해 제공되는 것과 동일하다는 점에 유의하십시오.
NAT도 같은 이유입니다.

21.2. 핸드셰이크 서비스 거부

암호화되고 인증된 전송으로서 QUIC는 다양한 기능을 제공합니다.
서비스 거부에 대한 보호. 암호화가
핸드셰이크가 완료되면 QUIC 엔드포인트는 대부분의 패킷을 삭제합니다.
인증되지 않아 공격자의 능력이 크게 제한됩니다.
기존 연결을 방해합니다.

연결이 설정되면 QUIC 엔드포인트는 일부를 허용할 수 있습니다.
인증되지 않은 ICMP 패킷(섹션 14.2.1 참조)을 사용하지만
이 패킷은 매우 제한적입니다. 다른 유형의 패킷은 다음과 같습니다.
엔드포인트가 허용할 수 있는 것은 상태 비저장 재설정(섹션 10.3)입니다.
토큰은 사용될 때까지 비밀로 유지되어야 합니다.

연결 생성 중에 QUIC는 보호 기능만 제공합니다.
네트워크 경로 외부의 공격에 대비합니다. 모든 QUIC 패킷에는 다음이 포함됩니다.
수신자가 상대방으로부터 이전 패킷을 보았다는 증거입니다.

핸드셰이크 동안 주소는 변경될 수 없으므로 엔드포인트는
다른 네트워크 경로에서 수신된 패킷을 삭제합니다.

소스 및 대상 연결 ID 필드는 기본 수단입니다.
핸드셰이크 중 경로 외 공격에 대한 보호 참조
섹션 8.1. 이는 피어가 설정한 것과 일치해야 합니다.
초기 및 상태 비저장 재설정을 제외하고 엔드포인트는 다음을 허용합니다.
대상 연결 ID 필드와 일치하는 패킷
이전에 선택한 엔드포인트 값입니다. 이것이 유일한 보호입니다.
버전 협상 패킷에 제공됩니다.

초기 패킷의 대상 연결 ID 필드가 선택되었습니다.
고객이 예측할 수 없도록 하는 것이 추가적인 목적입니다.
암호화 핸드셰이크를 전달하는 패킷은 다음으로 보호됩니다.
이 연결 ID에서 파생된 키와 특정 salt
QUIC 버전. 이를 통해 엔드포인트는 동일한 프로세스를 사용할 수 있습니다.
사용 후 수신한 패킷을 인증합니다.
암호화 핸드셰이크가 완료됩니다. 패킷은
인증된 패킷은 삭제됩니다. 이런 방식으로 패킷을 보호합니다.
패킷을 보낸 사람이 패킷을 확인했다는 강력한 확신을 제공합니다.
초기 패킷을 읽고 이해했습니다.

이러한 보호는 다음에 대해 효과적이도록 의도되지 않았습니다.
연결 전에 QUIC 패킷을 수신할 수 있는 공격자
확립되고 있습니다. 이러한 공격자는 잠재적으로 패킷을 보낼 수 있습니다.
QUIC 엔드포인트에서 허용됩니다. 이 QUIC 버전은
이러한 종류의 공격을 감지하려고 시도하지만 엔드포인트가
복구하기보다는 연결을 설정하지 못할 것입니다.
대부분의 경우 암호화 핸드셰이크 프로토콜[QUIC-TLS]은
핸드셰이크 중에 변조를 감지하는 역할을 담당합니다.

엔드포인트는 다른 방법을 사용하여 감지하고 시도할 수 있습니다.
핸드셰이크 간섭으로부터 복구합니다. 잘못된 패킷이 발생할 수 있습니다.
다른 방법을 사용하여 식별하고 폐기하지만 특정 방법은 없습니다.
이 문서에서는 의무적으로 요구됩니다.

21.3. 증폭 공격

공격자는 주소 검증 토큰을 받을 수 있습니다.
(섹션 8) 서버에서 해당 IP 주소를 해제한 후
해당 토큰을 획득합니다. 나중에 공격자는 다음을 시작할 수 있습니다.
동일한 주소를 스푸핑하여 서버와 0-RTT 연결
이제 다른 (피해자) 엔드포인트를 처리할 수 있습니다. 공격자는
따라서 잠재적으로 서버가 초기 혼잡을 보낼 수 있습니다.
피해자에게 윈도우의 데이터 양만큼 전송합니다.

서버는 이 공격에 대한 완화책을 제공해야 합니다.
주소 검증 토큰의 사용 및 수명은 섹션 8.1.3을 참조하세요.

21.4. 낙관적 ACK 공격

수신하지 못한 패킷을 인식하는 엔드포인트는 다음과 같은 문제를 일으킬 수 있습니다.
전송 속도를 초과하는 속도로 전송을 허용하는 혼잡 제어기
네트워크가 지원합니다. 엔드포인트는 패킷을 전송할 때 패킷 번호를 건너뛸 수 있습니다.
패킷을 통해 이러한 동작을 감지합니다. 그러면 엔드포인트는 즉시
연결 오류 유형으로 연결을 닫습니다.
프로토콜 위반; 섹션 10.2를 참조하세요.

21.5. 요청 위조 공격

요청 위조 공격은 엔드포인트가 피어에게 다음을 발생시키는 경우 발생합니다.
피해자에게 요청을 발행하고 요청은 다음에 의해 제어됩니다.
엔드포인트. 요청 위조 공격은 공격자에게 다음을 제공하는 것을 목표로 합니다.
그렇지 않으면 접근이 불가능할 동료의 역량에 대한 접근
공격자가 사용할 수 없습니다. 네트워킹 프로토콜의 경우 요청
위조 공격은 종종 암묵적 권한을 악용하는 데 사용됩니다.
피해자가 동료의 위치로 인해 동료에게 부여한 것
회로망.

요청 위조가 효과적이려면 공격자는 다음을 수행할 수 있어야 합니다.
피어가 어떤 패킷을 보내는지, 그리고 이 패킷이 어디에 있는지에 영향을 미칩니다.
전송됨. 공격자가 취약한 서비스를 표적으로 삼을 수 있는 경우
제어된 페이로드의 경우 해당 서비스는 다음과 같은 작업을 수행할 수 있습니다.
공격자의 동료에게 기인하지만 공격자가 결정합니다.

예를 들어, 웹에서의 CSRF(Cross Site Request Forgery) 공격
클라이언트가 권한 부여 쿠키를 포함하는 요청을 발행하도록 합니다.
[쿠키]를 사용하면 한 사이트에서 정보 및 작업에 액세스할 수 있습니다.
다른 사이트로 제한되도록 의도되었습니다.

QUIC는 UDP를 통해 실행되므로 우려되는 주요 공격 방식은 다음과 같습니다.
공격자가 피어가 UDP를 보낼 주소를 선택할 수 있는 곳
데이터그램을 제어하고 해당 데이터그램의 보호되지 않은 콘텐츠 중 일부를 제어할 수 있습니다.
패킷. QUIC 엔드포인트에서 전송되는 대부분의 데이터는 보호되므로
여기에는 암호문에 대한 제어가 포함됩니다. 공격이 성공한 경우는 다음과 같습니다.
공격자는 피어가 호스트에 UDP 데이터그램을 보내도록 할 수 있습니다.
데이터그램의 내용에 따라 어떤 동작을 수행합니다.

이 섹션에서는 QUIC가 요청에 사용될 수 있는 방법에 대해 설명합니다.
위조 공격.

이 섹션에서는 또한 제한된 대책에 대해서도 설명합니다.
QUIC 엔드포인트에서 구현됩니다. 이러한 완화책을 사용할 수 있습니다.
QUIC 구현이나 배포를 통해 일방적으로
요청 위조 공격의 잠재적인 대상에 대한 조치를 취하고 있습니다.
그러나 UDP 기반에서는 이러한 대책이 충분하지 않을 수 있습니다.
서비스가 요청을 제대로 승인하지 않습니다.

21.5.4절에 기술된 마이그레이션 공격은 매우
강력하지만 적절한 대책이 없는 QUIC 서버
구현에서는 공격자가 이를 발생시킬 수 있다고 가정해야 합니다.
임의의 목적지로 임의의 UDP 페이로드를 생성합니다. QUIC
서버는 인그레스를 배포하지 않는 네트워크에 배포되어서는 안 됩니다.
필터링[BCP38]이 없고 UDP 엔드포인트 보안이 제대로 이루어지지 않았습니다.

일반적으로 클라이언트가 다음 사항을 보장할 수는 없지만
취약한 엔드포인트와 함께 배치된 이 버전의 QUIC는
서버가 마이그레이션되도록 허용하여 스푸핑된 마이그레이션 공격을 방지합니다.
클라이언트에서. 서버 마이그레이션을 허용하는 향후 확장 프로그램은 반드시
또한 위조 공격에 대한 대응책도 정의합니다.

21.5.1. 엔드포인트에 대한 제어 옵션

QUIC는 공격자가 영향을 미치거나
피어가 UDP 데이터그램을 보내는 위치를 제어합니다.

* 초기 연결 설정(섹션 7), 서버가 있는 경우
  클라이언트가 데이터그램을 보낼 위치를 선택할 수 있습니다. 예를 들어,
  DNS 레코드 채우기

* 서버가 가능한 기본 주소(섹션 9.6)
  클라이언트가 데이터그램을 보낼 위치를 선택합니다.

* 클라이언트가 있는 스푸핑된 연결 마이그레이션(섹션 9.3.1)
  소스 주소 스푸핑을 사용하여 서버가 보낼 위치를 선택할 수 있습니다.
  이후의 데이터그램 및

* 서버가 버전 협상을 보내도록 하는 스푸핑 패킷
  패킷(섹션 21.5.5).

모든 경우에 공격자는 피어가 데이터그램을 보내도록 할 수 있습니다.
QUIC를 이해하지 못할 수 있는 피해자. 즉, 이러한 패킷은
주소 검증 전에 피어가 보낸 메시지입니다. 섹션 8을 참조하세요.

패킷의 암호화된 부분 외부에서 QUIC는 엔드포인트를 제공합니다.
UDP 데이터그램의 내용을 제어하기 위한 여러 옵션
피어가 전송합니다. 대상 연결 ID 필드는 직접 연결을 제공합니다.
피어가 보낸 패킷에 일찍 나타나는 바이트에 대한 제어; 참조
섹션 5.1. 초기 패킷의 토큰 필드는 서버를 제공합니다.
초기 패킷의 다른 바이트에 대한 제어; 섹션 17.2.2 참조.

이 QUIC 버전에는 간접적인 문제를 방지하기 위한 조치가 없습니다.
패킷의 암호화된 부분을 제어해야 합니다.
엔드포인트가 프레임의 내용을 제어할 수 있다고 가정합니다.
피어는 특히 애플리케이션 데이터를 전달하는 프레임을 보냅니다.
STREAM 프레임과 같은 경우. 이는 어느 정도 세부 사항에 따라 달라집니다.
응용 프로그램 프로토콜의 경우 많은 제어가 가능합니다.
프로토콜 사용 컨텍스트. 공격자가 패킷에 액세스할 수 있으므로
보호 키는 어떻게 될지 예측할 수 있는 가능성이 높습니다.
피어가 향후 패킷을 암호화합니다. 데이터그램을 성공적으로 제어합니다.
그러면 콘텐츠는 공격자가 다음을 예측할 수 있어야만 합니다.
패킷 번호 및 패킷 내 프레임 배치
신뢰할 수 있음.

이 섹션에서는 데이터그램 콘텐츠에 대한 제어를 제한한다고 가정합니다.
실행 가능하지 않습니다. 후속 섹션의 완화책의 초점은 다음과 같습니다.
이전에 전송된 데이터그램의 방식을 제한하는 것에 관하여
주소 검증은 요청 위조에 사용될 수 있습니다.

21.5.2. 클라이언트 초기 패킷을 이용한 요청 위조

서버 역할을 하는 공격자는 IP 주소와 포트를 선택할 수 있습니다.
이것이 사용 가능함을 광고하므로 클라이언트의 초기 패킷
이러한 종류의 공격에 사용할 수 있다고 가정합니다.
핸드셰이크에 내재된 주소 검증은 다음을 보장합니다.
새로운 연결 -- 클라이언트는 다른 유형의 패킷을 보내지 않습니다.
QUIC를 이해하지 못하거나 수락할 의향이 없는 대상
QUIC 연결.

초기 패킷 보호([QUIC-TLS]의 섹션 5.2)를 통해
서버가 전송된 초기 패킷의 내용을 제어하기 어려움
고객이 예측할 수 없는 목적지를 선택하는 경우
연결 ID는 서버가 다음을 제어할 수 없도록 보장합니다.
클라이언트의 초기 패킷의 암호화된 부분입니다.

그러나 토큰 필드는 서버 제어에 열려 있으며 다음을 허용합니다.
서버가 클라이언트를 사용하여 요청 위조 공격을 실행합니다.
NEW_TOKEN 프레임(섹션 8.1.3)과 함께 제공되는 토큰은 다음을 제공합니다.
연결 설정 중에 요청 위조를 위한 유일한 옵션입니다.

하지만 클라이언트는 NEW_TOKEN 프레임을 사용할 의무가 없습니다.
토큰 필드에 의존하는 요청 위조 공격은 피할 수 있습니다.
서버 주소가 비어 있을 때 클라이언트가 빈 토큰 필드를 보내는 경우
NEW_TOKEN 프레임을 수신한 시점부터 변경되었습니다.

서버 주소가 변경되면 클라이언트는 NEW_TOKEN을 사용하지 않아도 됩니다.
그러나 토큰 필드를 포함하지 않으면 부정적인 영향을 미칠 수 있습니다.
성능. 서버는 NEW_TOKEN을 사용하여 전송을 활성화할 수 있습니다.
데이터 전송 제한의 3배를 초과하는 데이터의 경우 참조
섹션 8.1. 특히 이는 클라이언트가 사용하는 경우에 영향을 미칩니다.
0-RTT는 서버에 데이터를 요청하는 방식입니다.

재시도 패킷(섹션 17.2.5)을 보내면 서버에 다음 옵션이 제공됩니다.
토큰 필드를 변경하세요. 재시도를 보낸 후 서버는
후속 초기 연결의 대상 연결 ID 필드를 제어합니다.
클라이언트의 패킷. 이를 통해 간접적으로 제어할 수도 있습니다.
초기 패킷의 암호화된 내용. 그러나 교환은
재시도 패킷은 서버의 주소를 검증하여 다음을 방지합니다.
요청 위조를 위해 후속 초기 패킷을 사용합니다.

21.5.3. 선호 주소를 사용한 요청 위조

서버는 선호하는 주소를 지정할 수 있으며, 이후 클라이언트는 해당 주소를 마이그레이션합니다.
핸드셰이크를 확인한 후; 섹션 9.6 참조. 목적지
클라이언트가 선호하는 패킷에 보내는 연결 ID 필드
주소는 요청 위조에 사용될 수 있습니다.

클라이언트는 선호하는 주소로 비탐색 프레임을 보내서는 안 됩니다.
해당 주소를 검증하기 전에 섹션 8을 참조하세요. 이것은 매우 중요합니다.
암호화된 내용을 제어하기 위해 서버가 선택할 수 있는 옵션을 줄입니다.
데이터그램의 일부.

이 문서는 추가적인 대책을 제시하지 않습니다.
선호하는 주소 사용에 특화되어 있으며 다음을 통해 구현할 수 있습니다.
종료점. 섹션 21.5.6에 설명된 일반적인 측정값은 다음과 같습니다.
추가적인 완화책으로 사용됨.

21.5.4. 스푸핑된 마이그레이션을 통한 요청 위조

클라이언트는 위조된 소스 주소를 다음의 일부로 제시할 수 있습니다.
서버가 데이터그램을 보내도록 하는 명백한 연결 마이그레이션
그 주소.

서버가 전송하는 모든 패킷의 대상 연결 ID 필드
이후 이 위조된 주소로 전송하면 요청에 사용할 수 있습니다.
위조. 의뢰인은 암호문에 영향을 미칠 수도 있습니다.

주소로 프로빙 패킷(섹션 9.1)만 전송하는 서버
주소 검증 전에 공격자에게 제한된 권한만 제공합니다.
데이터그램의 암호화된 부분에 대한 제어. 그러나
특히 NAT 리바인딩의 경우 이는 부정적인 영향을 미칠 수 있습니다.
성능. 서버가 애플리케이션 데이터를 전달하는 프레임을 보내는 경우
공격자는 대부분의 콘텐츠를 제어할 수 있습니다.
데이터그램.

이 문서는 구체적인 대책을 제시하지 않습니다.
일반적인 측정 외에도 엔드포인트에서 구현됨
섹션 21.5.6에서. 그러나 주소 스푸핑에 대한 대책은
네트워크 수준(특히, 유입 필터링[BCP38])은 다음과 같습니다.
특히 스푸핑을 사용하고 발생하는 공격에 효과적입니다.
외부 네트워크에서.

21.5.5. 버전 협상을 통한 요청 위조

패킷에 위조된 소스 주소를 제시할 수 있는 클라이언트
서버가 버전 협상 패킷을 보내도록 할 수 있습니다.
(섹션 17.2.1) 해당 주소로.

연결 ID 필드에 크기 제한이 없음
알 수 없는 버전의 패킷은 데이터 양을 증가시킵니다.
결과 데이터그램에서 클라이언트 제어. 이 데이터그램의 첫 번째 바이트
패킷이 클라이언트 제어를 받지 않으며 다음 4바이트가 0입니다.
하지만 클라이언트는 최대 512바이트까지 제어할 수 있습니다.
다섯 번째 바이트.

이 공격에 대한 구체적인 대책은 제공되지 않았습니다.
일반적인 보호(섹션 21.5.6)가 적용될 수 있습니다. 이 경우,
유입 필터링[BCP38]도 효과적입니다.

21.5.6. 일반 요청 위조 대응책

요청 위조 공격에 대한 가장 효과적인 방어는 다음과 같습니다.
취약한 서비스를 수정하여 강력한 인증을 사용하도록 합니다. 그러나
이는 항상 QUIC의 제어 범위 내에 있는 것은 아닙니다.
배포. 이 섹션에서는 QUIC에서 수행하는 몇 가지 다른 단계를 간략하게 설명합니다.
엔드포인트는 일방적으로 취할 수 있습니다. 이러한 추가 단계는 모두
상황에 따라 재량에 따라 달라질 수 있기 때문에
합법적인 사용을 방해하거나 방해합니다.

루프백 인터페이스를 통해 제공되는 서비스는 종종 적절한 기능이 부족합니다.
인증. 엔드포인트는 연결 시도를 방지할 수 있습니다.
루프백 주소로의 마이그레이션. 엔드포인트는 다음을 허용해서는 안 됩니다.
동일한 서비스가 루프백 주소로 연결되거나 마이그레이션되는 경우
이전에 다른 인터페이스에서 사용 가능했거나 주소가
루프백이 아닌 주소의 서비스에서 제공되었습니다. 엔드포인트
이러한 기능에 따라 이를 비활성화하는 옵션을 제공할 수 있습니다.
보호.

마찬가지로, 엔드포인트는 링크 로컬에 대한 주소 변경을 간주할 수 있습니다.
주소 [RFC4291] 또는 개인 사용 범위 [RFC1918]의 주소
글로벌, 고유 로컬 [RFC4193] 또는 비공개가 아닌 주소
요청 위조 시도 가능성이 있습니다. 엔드포인트는 사용을 거부할 수 있습니다.
이 주소는 전적으로 그렇지만 상당한 위험을 수반합니다.
합법적인 사용을 방해합니다. 엔드포인트는 사용을 거부해서는 안 됩니다.
네트워크에 대한 구체적인 지식이 없는 한 주소
주어진 주소에서 검증되지 않은 주소로 데이터그램을 보내는 것을 나타냅니다.
범위가 안전하지 않습니다.

엔드포인트는 요청 위조 위험을 줄이기 위해 다음을 선택할 수 있습니다.
초기 패킷에 NEW_TOKEN 프레임의 값을 포함하거나
주소 완료 전에 패킷으로 프로빙 프레임 보내기
유효성 검사. 이것이 공격자가 사용하는 것을 막지는 않는다는 점에 유의하세요.
공격에 대한 대상 연결 ID 필드입니다.

엔드포인트에는 특정 정보가 있을 것으로 예상되지 않습니다.
요청의 취약한 대상이 될 수 있는 서버의 위치
위조 공격. 그러나 시간이 지남에 따라 식별이 가능할 수 있습니다.
공격의 일반적인 대상인 특정 UDP 포트 또는 특정
공격에 사용되는 데이터그램의 패턴. 엔드포인트는
이러한 포트로 데이터그램을 보내지 않도록 선택하거나 보내지 마십시오.
이러한 패턴과 일치하는 데이터그램을 검증하기 전에
대상 주소. 엔드포인트는 다음을 포함하는 연결 ID를 폐기할 수 있습니다.
이를 사용하지 않고도 문제가 있는 것으로 알려진 패턴.

      | 참고: 이러한 보호 기능을 적용하기 위해 엔드포인트를 수정하는 것이 더 쉽습니다.
      | 네트워크 기반 보호 기능을 배포하는 것보다 효율적입니다.
      | 엔드포인트는 추가 처리를 수행할 필요가 없습니다.
      | 검증된 주소로 전송합니다.

21.6. 슬로로리스 공격

일반적으로 Slowloris [SLOWLORIS]로 알려진 공격은 많은 것을 유지하려고 시도합니다.
대상 엔드포인트에 대한 연결이 열려 있고 다음 시간 동안 열려 있는 상태로 유지됩니다.
가능합니다. 이러한 공격은 QUIC 엔드포인트에 대해 다음을 통해 실행될 수 있습니다.
피하기 위해 필요한 최소한의 활동을 생성합니다.
비활성으로 인해 닫혔습니다. 여기에는 소량의
데이터, 점차적으로 흐름 제어 창을 열어 제어합니다.
발신자 속도 또는 높은 손실을 시뮬레이션하는 ACK 프레임 제조
비율.

QUIC 배포는 Slowloris에 대한 완화책을 제공해야 합니다.
서버의 최대 클라이언트 수를 늘리는 것과 같은 공격
단일 IP 주소에 대한 연결 수를 제한하여 허용합니다.
최소 전송 속도에 제한을 가하여 허용
연결이 허용되며 연결 시간이 제한됩니다.
엔드포인트는 연결된 상태를 유지할 수 있습니다.

21.7. 스트림 조각화 및 재조립 공격

적대적인 발신자는 의도적으로 메시지의 일부를 보내지 않을 수 있습니다.
스트림 데이터를 통해 수신기가 전송되지 않은 데이터에 대한 리소스를 커밋하도록 합니다.
데이터. 이로 인해 수신 버퍼 메모리가 불균형해질 수 있습니다.
약속 및/또는 대규모 비효율적인 데이터 생성
수신기의 구조.

적대적 수신기는 의도적으로 패킷을 인식하지 못할 수 있습니다.
보낸 사람이 저장하도록 강제하기 위해 스트림 데이터를 포함하는
재전송을 위한 확인되지 않은 스트림 데이터.

흐름 제어 창이 있는 경우 수신기에 대한 공격이 완화됩니다.
사용 가능한 메모리에 해당합니다. 그러나 일부 수신기는
메모리를 과도하게 할당하고 집계에서 흐름 제어 오프셋을 광고합니다.
실제 사용 가능한 메모리를 초과합니다. 오버 커밋 전략은
엔드포인트가 제대로 동작하면 더 나은 성능을 얻을 수 있지만
스트림 조각화 공격에 엔드포인트가 취약해집니다.

QUIC 배포는 스트림 조각화에 대한 완화책을 제공해야 합니다.
공격. 완화책은 과도한 약속을 피하는 것으로 구성될 수 있습니다.
메모리, 추적 데이터 구조의 크기 제한, 지연
STREAM 프레임 재조립, 연령 기반 휴리스틱 구현
그리고 재조립 구멍의 지속 시간 또는 이러한 것들의 조합.

21.8. 스트림 커밋 공격

적대적 엔드포인트는 많은 수의 스트림을 열 수 있습니다.
엔드포인트에서 소모적인 상태. 적대적 엔드포인트는
많은 수의 연결에서 프로세스를 반복합니다.
TCP의 SYN 플러딩 공격과 유사합니다.

일반적으로 클라이언트는 다음에서 설명한 대로 스트림을 순차적으로 엽니다.
섹션 2.1. 그러나 여러 스트림이 짧은 시간에 시작되면
간격, 손실 또는 재정렬로 인해 STREAM 프레임이 열릴 수 있습니다.
순서 없이 수신되는 스트림. 더 높은 순서로 수신 시
번호가 매겨진 스트림 ID의 경우 수신기는 모든 중간 스트림을 열어야 합니다.
동일한 유형의 스트림; 섹션 3.2를 참조하세요. 따라서 새로운
연결, 스트림 4000000을 열면 100만과 1 클라이언트가 열립니다.
양방향 스트림을 시작했습니다.

활성 스트림의 수는 다음에 의해 제한됩니다.
initial_max_streams_bidi 및 initial_max_streams_uni 전송
수신된 MAX_STREAMS 프레임에 의해 업데이트된 매개변수
4.6절에서 설명했습니다. 신중하게 선택하면 이러한 제한이 적용됩니다.
스트림 커밋 공격의 효과를 완화합니다. 그러나
제한을 너무 낮게 설정하면 응용 프로그램 성능에 영향을 미칠 수 있습니다.
많은 수의 스트림이 오픈될 것으로 예상됩니다.

21.9. 피어 서비스 거부

QUIC와 TLS는 모두 합법적인 프레임이나 메시지를 포함합니다.
일부 맥락에서 사용되지만 이러한 프레임이나 메시지는 다음과 같은 경우에 남용될 수 있습니다.
피어가 처리 리소스를 소모하도록 합니다.
연결 상태에 눈에 띄는 영향이 나타납니다.

메시지는 소규모 또는
예를 들어, 흐름에 작은 증분을 보내는 것과 같은 중요하지 않은 방법
관리 한계.

처리 비용이 다른 비용에 비해 비례적으로 큰 경우
대역폭 소모 또는 상태에 미치는 영향이 있는 경우 이를 허용할 수 있습니다.
악의적인 피어가 처리 용량을 고갈시킵니다.

모든 메시지에는 합법적인 용도가 있지만 구현은 다음과 같습니다.
진행 상황 및 치료에 대한 처리 비용을 추적해야 합니다.
비생산적인 패킷의 과도한 양은 다음을 나타냅니다.
공격. 엔드포인트는 연결로 이 조건에 응답할 수 있습니다.
오류 또는 패킷 삭제.

21.10. 명시적 혼잡 알림 공격

경로상 공격자는 ECN 필드의 값을 조작할 수 있습니다.
발신자의 속도에 영향을 미치는 IP 헤더. [RFC3168]에서 논의합니다.
조작과 그 효과에 대해 더 자세히 설명합니다.

제한된 경로상의 공격자는 패킷을 복제하여 보낼 수 있습니다.
발신자 요금에 영향을 미치도록 ECN 필드를 수정했습니다. 중복되는 경우
패킷이 수신기에 의해 삭제되면 공격자는 경쟁해야 합니다.
이것에 성공하려면 원본 패킷에 대한 중복 패킷이 필요합니다.
공격. 따라서 QUIC 엔드포인트는 IP의 ECN 필드를 무시합니다.
해당 IP 패킷에 적어도 하나의 QUIC 패킷이 없는 경우 패킷
성공적으로 처리되었습니다. 섹션 13.4를 참조하세요.

21.11. 상태 비저장 Oracle 재설정

상태 비저장 재설정은 유사한 서비스 거부 공격을 생성할 수 있습니다.
TCP 재설정 주입에. 이 공격은 공격자가
상태 비저장 재설정 토큰이 생성되도록 할 수 있습니다.
선택된 연결 ID로 연결. 공격자는 다음을 유발할 수 있습니다.
생성된 이 토큰은 활성 연결을 재설정할 수 있습니다.
동일한 연결 ID.

패킷이 정적을 공유하는 다른 인스턴스로 라우팅될 수 있는 경우
키 -- 예를 들어 IP 주소나 포트를 변경하면 --
공격자는 서버가 상태 비저장 재설정을 보내도록 할 수 있습니다. 방어하려면
이러한 서비스 거부 스타일을 방지하기 위해 다음을 공유하는 엔드포인트가 있습니다.
상태 비저장 재설정을 위한 정적 키(섹션 10.3.2 참조)를 반드시 준비해야 합니다.
따라서 주어진 연결 ID가 있는 패킷은 항상 다음 위치에 도착합니다.
연결이 없는 경우를 제외하고 연결 상태가 있는 인스턴스
더 이상 활동하지 않음.

더 일반적으로 서버는 다음과 같은 경우 상태 비저장 재설정을 생성해서는 안 됩니다.
해당 연결 ID를 사용한 연결이 활성화될 수 있습니다.
동일한 정적 키를 사용하는 모든 엔드포인트.

동적 부하 분산을 사용하는 클러스터의 경우
로드 밸런서 구성이 변경될 가능성이 있습니다.
활성 인스턴스가 연결 상태를 유지하는 동안.
인스턴스는 연결 상태를 유지하고 라우팅이 변경됩니다.
결과적으로 상태 비저장 재설정이 이루어지면 연결이 끊어집니다.
종료되었습니다. 패킷이 라우팅될 가능성이 없는 경우
올바른 인스턴스에서는 대기하는 것보다 상태 비저장 재설정을 보내는 것이 더 좋습니다.
연결 시간이 초과될 수 있습니다. 그러나 이는 다음 경우에만 허용됩니다.
라우팅은 공격자의 영향을 받을 수 없습니다.

21.12. 버전 다운그레이드

이 문서는 QUIC 버전 협상 패킷(섹션 6)을 정의합니다.
두 개의 QUIC 버전 간에 사용되는 QUIC 버전을 협상하는 데 사용할 수 있습니다.
끝점. 그러나 이 문서에서는 이것이 어떻게 되는지 지정하지 않습니다.
이 버전과 후속 버전 간에 협상이 수행됩니다.
향후 버전. 특히 버전 협상 패킷은
버전 다운그레이드 공격을 방지하는 메커니즘이 포함되어 있지 않습니다. 향후
버전 협상 패킷을 사용하는 QUIC 버전은 다음을 정의해야 합니다.
버전 다운그레이드 공격에 강력한 메커니즘입니다.

21.13. 라우팅을 통한 타겟 공격

배포는 공격자가 새로운 대상을 타겟팅하는 능력을 제한해야 합니다.
특정 서버 인스턴스에 대한 연결입니다. 이상적으로는 라우팅
결정은 클라이언트가 선택한 값과 관계없이 독립적으로 이루어집니다.
주소. 인스턴스가 선택되면 연결 ID를 지정할 수 있습니다.
이후 패킷이 동일한 인스턴스로 라우팅되도록 선택되었습니다.

21.14. 트래픽 분석

QUIC 패킷의 길이는 패킷 길이에 대한 정보를 나타낼 수 있습니다.
해당 패킷의 내용입니다. 패딩 프레임은 다음과 같이 제공됩니다.
엔드포인트에는 패킷 내용의 길이를 가릴 수 있는 기능이 있습니다.
섹션 19.1을 참조하세요.

트래픽 분석을 극복하는 것은 어렵고 적극적인 주제입니다.
연구. 정보가 유출될 수 있는 유일한 방법은 길이가 아닙니다.
엔드포인트는 다른 쪽을 통해 민감한 정보를 공개할 수도 있습니다.
패킷의 타이밍과 같은 채널.

22. IANA 고려 사항

이 문서는 관리를 위한 여러 레지스트리를 설정합니다.
QUIC의 코드포인트. 이러한 레지스트리는 공통된 집합에서 작동합니다.
섹션 22.1에 정의된 정책.

22.1. QUIC 레지스트리 등록 정책

모든 QUIC 레지스트리는 임시 및 영구를 모두 허용합니다.
코드포인트 등록. 이 섹션에서는 다음과 같은 정책을 설명합니다.
이러한 레지스트리에는 공통적인 사항이 있습니다.

22.1.1. 임시 등록

코드포인트의 임시 등록은 다음을 허용하기 위한 것입니다.
QUIC 확장을 통한 개인 사용 및 실험. 임시
등록에는 코드포인트 값만 포함하면 됩니다.
연락처 정보. 그러나 임시 등록은 가능합니다.
회수되어 다른 목적으로 재할당되었습니다.

임시 등록에는 전문가 검토가 필요합니다.
[RFC8126]의 섹션 4.5. 지정된 전문가 또는 전문가들은
과도한 비율의 등록만 권장됩니다.
남은 코드 포인트 공간 또는 할당되지 않은 첫 번째 값(참조
섹션 22.1.2)은 거부될 수 있습니다.

임시 등록에는 다음을 나타내는 날짜 필드가 포함됩니다.
등록이 마지막으로 업데이트된 날짜입니다. 날짜 업데이트 요청
임시 등록은 검토 없이 이루어질 수 있습니다.
지정된 전문가.

모든 QUIC 레지스트리에는 다음 필드가 포함되어 있습니다.
임시 등록:

값: 할당된 코드포인트.
상태: "영구" 또는 "임시".
사양: 공개적으로 사용 가능한 사양에 대한 참조
가치.
날짜: 등록이 마지막으로 업데이트된 날짜입니다.
변경 관리자: 정의를 담당하는 엔터티
등록의.
연락처: 등록자의 연락처 정보입니다.
참고사항: 등록에 대한 추가 참고사항.

임시 등록에는 사양 및 참고 사항이 생략될 수 있습니다.
필드와 추가적으로 필요할 수 있는 필드
영구 등록. 날짜 필드는 필수가 아닙니다.
등록을 요청하는 경우 등록 날짜로 설정되어 있습니다.
생성되거나 업데이트됩니다.

22.1.2. 코드포인트 선택

QUIC 레지스트리의 코드 포인트에 대한 새로운 요청은 다음을 사용해야 합니다.
기존 할당을 모두 제외하는 무작위로 선택된 코드 포인트
그리고 선택된 공간에서 할당되지 않은 첫 번째 코드포인트. 요청
여러 코드포인트의 경우 연속된 범위를 사용할 수 있습니다. 이렇게 하면
동일한 것에 대해 서로 다른 의미론이 부여될 위험이 있습니다.
다양한 구현에 따른 코드포인트.

첫 번째 할당되지 않은 코드포인트의 사용은 할당을 위해 예약됩니다.
표준 조치 정책을 사용합니다. [RFC8126]의 섹션 4.9를 참조하세요.
조기 코드 포인트 할당 프로세스[EARLY-ASSIGN]는 다음에 사용할 수 있습니다.
이러한 가치들.

가변 길이 정수로 인코딩된 코드 포인트의 경우
(섹션 16) 프레임 유형, 4개 또는 그 이상으로 인코딩하는 코드 포인트 등
8바이트(즉, 2^14 이상의 값)는 다음 경우를 제외하고는 사용해야 합니다.
특히 인코딩이 길어질수록 사용법이 민감해집니다.

QUIC 레지스트리에 코드포인트를 등록하기 위한 애플리케이션에는 다음이 포함될 수 있습니다.
등록의 일부로 요청된 코드포인트. IANA는 다음을 할당해야 합니다.
코드 포인트가 할당되지 않은 경우 선택된 코드 포인트
등록 정책의 요구 사항을 충족합니다.

22.1.3. 임시 코드포인트 회수

사용되지 않은 임시 등록을 제거하라는 요청이 있을 수 있습니다.
레지스트리에서 레지스트리의 공간이나 일부를 회수하기 위해
레지스트리(예: 코드포인트를 사용하는 경우 64-16383 범위)
가변 길이 인코딩). 이것은 다음에 대해서만 수행되어야 합니다.
가장 빠른 기록 날짜를 가진 코드 포인트와 다음 항목이 있습니다.
1년 이내에 업데이트된 정보는 다시 청구할 수 없습니다.

코드포인트를 제거하라는 요청은 지정된 담당자가 검토해야 합니다.
전문가. 전문가는 코드포인트가
아직 사용 중입니다. 전문가는 나열된 연락처로 문의하시기 바랍니다.
등록을 위해서는 프로토콜 구현자 집합이 최대한 넓어야 합니다.
코드포인트의 사용이 있는지 여부를 확인하기 위해 가능합니다.
알려져 있습니다. 전문가들은 또한 최소 4주를 허용하도록 조언합니다.
응답.

이 검색이나
등록을 업데이트하라는 요청이 있을 경우 코드포인트는 다음과 같아야 합니다.
회수되었습니다. 대신 등록 날짜가 업데이트됩니다. 참고 사항
등록 기록 관련 정보를 추가할 수 있습니다.
그것은 배웠습니다.

코드포인트 사용이 식별되지 않았고 요청이 이루어지지 않은 경우
등록을 업데이트하면 코드 포인트가 제거될 수 있습니다.
기재.

이 검토 및 협의 프로세스는 요청에도 적용됩니다.
임시 등록을 영구 등록으로 변경합니다.
단, 목적은 사용이 없는지 여부를 판별하는 것이 아닙니다.
코드포인트이지만 등록이 정확한지 확인하려면
배포된 모든 사용의 표현입니다.

22.1.4. 영구 등록

QUIC 레지스트리의 영구 등록은 사양을 사용합니다.
필수 정책(RFC8126의 섹션 4.6)(다른 경우가 아닌 한)
지정된 전문가 또는 전문가들은 다음을 확인합니다.
사양이 존재하고 쉽게 접근할 수 있습니다. 전문가는
등록을 승인하는 데 편향되도록 권장됩니다.
학대적이거나 경솔하거나 적극적으로 해롭습니다(단순히 미적으로만 해롭지 않음)
불쾌하거나 구조적으로 의심스럽습니다). 레지스트리 생성
영구 등록에 대한 추가적인 제약 조건을 지정할 수 있습니다.

레지스트리 생성은 다양한 코드포인트를 식별할 수 있습니다.
등록은 다른 등록 정책에 따라 관리됩니다.
예를 들어, "QUIC 프레임 유형" 레지스트리(섹션 22.4)에는
0~63 범위의 코드포인트에 대한 정책이 더욱 엄격해졌습니다.

영구 등록에 대한 더 엄격한 요구 사항은 다음을 방해하지 않습니다.
영향을 받는 코드포인트에 대한 임시 등록. 예를 들어,
61 프레임 유형에 대한 임시 등록을 요청할 수 있습니다.

Standards Track 출판물에 의해 만들어진 모든 등록은 반드시
영구적인.

이 문서의 모든 등록에는 영구 상태가 지정됩니다.
IETF의 변경 관리자와 QUIC의 연락처를 나열합니다.
워킹그룹(quic@ietf.org).

22.2. QUIC 버전 레지스트리

IANA는 "QUIC" 제목 아래에 "QUIC 버전"에 대한 레지스트리를 추가했습니다.

"QUIC 버전" 레지스트리는 32비트 공간을 관리합니다. 섹션 15를 참조하세요.
이 레지스트리는 섹션 22.1의 등록 정책을 따릅니다.
이 등록소의 영구 등록은 다음을 사용하여 할당됩니다.
사양 필수 정책(RFC8126의 섹션 4.6).

프로토콜의 0x00000001 코드포인트는 다음과 같이 할당됩니다.
이 문서에 정의된 프로토콜에 대한 영구적 상태입니다.
0x00000000의 코드포인트는 영구적으로 예약되어 있습니다. 이에 대한 참고 사항
코드포인트는 이 버전이 버전용으로 예약되어 있음을 나타냅니다.
협상.

0x?a?a?a?a 패턴을 따르는 모든 코드 포인트는 예약되어 있어야 합니다.
IANA에서 할당되지 않으며 목록에 나타나서는 안 됩니다.
할당된 값.

22.3. QUIC 전송 매개변수 레지스트리

IANA는 "QUIC 전송 매개변수"에 대한 레지스트리를 추가했습니다.
"QUIC" 제목.

"QUIC 전송 매개변수" 레지스트리는 62비트 공간을 관리합니다.
이 레지스트리는 섹션 22.1의 등록 정책을 따릅니다.
이 등록소의 영구 등록은 다음을 사용하여 할당됩니다.
사양 필수 정책([RFC8126]의 섹션 4.6)은 다음을 제외합니다.
0x00과 0x3f 사이의 값(16진수)
정의된 대로 표준 조치 또는 IESG 승인을 사용하여 할당됨
[RFC8126]의 섹션 4.9 및 4.10.

22.1.1절에 나열된 필드 외에도 영구
이 레지스트리에 등록하려면 다음 필드가 포함되어야 합니다.

매개변수 이름: 매개변수에 대한 짧은 니모닉입니다.

이 레지스트리의 초기 내용은 표 6에 나와 있습니다.

      +=======+=====================================+==============+
      | 값 | 매개변수 이름 | 사양 |
      +=======+=====================================+==============+
      | 0x00 | original_destination_connection_id | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x01 | max_idle_timeout | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x02 | stateless_reset_token | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x03 | max_udp_payload_size | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x04 | initial_max_data | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x05 | initial_max_stream_data_bidi_local | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x06 | initial_max_stream_data_bidi_remote | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x07 | initial_max_stream_data_uni | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x08 | initial_max_streams_bidi | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x09 | initial_max_streams_uni | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x0a | ack_delay_exponent | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x0b | max_ack_delay | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x0c | disable_active_migration | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x0d | 선호하는 주소 | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x0e | active_connection_id_limit | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x0f | initial_source_connection_id | 섹션 18.2 |
      +-------+-------------------------------------+---------------+
      | 0x10 | retry_source_connection_id | 섹션 18.2 |
      +-------+-------------------------------------+---------------+

        표 6: 초기 QUIC 전송 매개변수 레지스트리 항목

N의 정수 값에 대한 "31 * N + 27" 형태의 각 값(
27, 58, 89, ...)는 예약되어 있습니다. 이 값은 할당되어서는 안 됩니다.
IANA에 의해 지정되며 할당된 값 목록에 나타나서는 안 됩니다.

22.4. QUIC 프레임 유형 레지스트리

IANA는 "QUIC" 아래에 "QUIC 프레임 유형"에 대한 레지스트리를 추가했습니다.
표제.

"QUIC 프레임 유형" 레지스트리는 62비트 공간을 관리합니다.
레지스트리는 섹션 22.1의 등록 정책을 따릅니다.
이 등록소의 영구 등록은 다음을 사용하여 할당됩니다.
사양 필수 정책([RFC8126]의 섹션 4.6)은 다음을 제외합니다.
0x00과 0x3f 사이의 값(16진수)
정의된 대로 표준 조치 또는 IESG 승인을 사용하여 할당됨
[RFC8126]의 섹션 4.9 및 4.10.

22.1.1절에 나열된 필드 외에도 영구
이 레지스트리에 등록하려면 다음 필드가 포함되어야 합니다.

프레임 유형 이름: 프레임 유형에 대한 짧은 니모닉입니다.

22.1절의 조언 외에 새로운 사양
영구 등록에는 다음 수단이 설명되어야 합니다.
엔드포인트는 식별된 유형을 보낼 수 있다고 판단할 수 있습니다.
프레임. 동반되는 전송 매개변수 등록이 예상됩니다.
대부분의 등록에 대해 섹션 22.3을 참조하세요. 사양
영구 등록에는 형식과 할당된 내용도 설명해야 합니다.
프레임 내의 모든 필드의 의미론.

이 레지스트리의 초기 내용은 표 3에 정리되어 있습니다. 참고
레지스트리에 "Pkts" 및 "Spec" 열이 포함되지 않습니다.
표 3.

22.5. QUIC 전송 오류 코드 레지스트리

IANA는 "QUIC 전송 오류 코드"에 대한 레지스트리를 추가했습니다.
"QUIC" 제목.

"QUIC 전송 오류 코드" 레지스트리는 62비트 공간을 관리합니다.
이 공간은 서로 다른 세 가지 범위로 나뉩니다.
정책. 이 레지스트리의 영구 등록은 할당됩니다.
사양 요구 정책([RFC8126]의 섹션 4.6)을 사용하여
0x00과 0x3f 사이의 값(16진수)을 제외하고
정의된 대로 표준 조치 또는 IESG 승인을 사용하여 할당됨
[RFC8126]의 섹션 4.9 및 4.10에서.

22.1.1절에 나열된 필드 외에도 영구
이 레지스트리에 등록하려면 다음 필드가 포함되어야 합니다.

코드: 매개변수에 대한 짧은 니모닉입니다.

설명: 오류 코드 의미론에 대한 간략한 설명입니다.
사양 참조가 제공되는 경우 요약일 수 있습니다.

이 레지스트리의 초기 내용은 표 7에 나와 있습니다.

+=======+===========================+================+==============+
|값 | 코드 |설명 |사양 |
+=======+===========================+================+==============+
|0x00 | NO_ERROR |오류 없음 |섹션 20 |
+-------+-----------------+----------------+--------------+
|0x01 | 내부 오류 | 구현 | 섹션 20 |
| | |오류 | |
+-------+-----------------+----------------+--------------+
|0x02 | CONNECTION_REFUSED |서버가 섹션 20을 거부했습니다.
| | |연결 | |
+-------+-----------------+----------------+--------------+
|0x03 | FLOW_CONTROL_ERROR |흐름 제어 |섹션 20 |
| | |오류 | |
+-------+-----------------+----------------+--------------+
|0x04 | STREAM_LIMIT_ERROR |스트림이 너무 많습니다.|섹션 20 |
| | |열었다 | |
+-------+-----------------+----------------+--------------+
|0x05 | STREAM_STATE_ERROR |프레임 수신 |섹션 20 |
| | |잘못된 | |
| | |스트림 상태 | |
+-------+-----------------+----------------+--------------+
|0x06 |FINAL_SIZE_ERROR |최종 변경 |섹션 20 |
| | |사이즈 | |
+-------+-----------------+----------------+--------------+
|0x07 | FRAME_ENCODING_ERROR |프레임 인코딩 |섹션 20 |
| | |오류 | |
+-------+-----------------+----------------+--------------+
|0x08 |TRANSPORT_PARAMETER_ERROR |섹션 20에서 오류 발생 |
| | |운송 | |
| | |매개변수 | |
+-------+-----------------+----------------+--------------+
|0x09 | CONNECTION_ID_LIMIT_ERROR |섹션 20이 너무 많습니다.
| | |연결 ID | |
| | |받았습니다 | |
+-------+-----------------+----------------+--------------+
|0x0a | PROTOCOL_VIOLATION |일반 프로토콜|섹션 20 |
| | |위반 | |
+-------+-----------------+----------------+--------------+
|0x0b | INVALID_TOKEN |잘못된 토큰 |섹션 20 |
| | |받았습니다 | |
+-------+-----------------+----------------+--------------+
|0x0c |APPLICATION_ERROR |응용 프로그램 |섹션 20 |
| | |오류 | |
+-------+-----------------+----------------+--------------+
|0x0d | CRYPTO_BUFFER_EXCEEDED |CRYPTO 데이터 |섹션 20 |
| | |버퍼 | |
| | |넘쳤다 | |
+-------+-----------------+----------------+--------------+
|0x0e | KEY_UPDATE_ERROR |잘못된 패킷 |섹션 20 |
| | |보호 | |
| | |업데이트 | |
+-------+-----------------+----------------+--------------+
|0x0f |AEAD_LIMIT_REACHED |섹션 20의 과도한 사용 |
| | |패킷 | |
| | |보호 키 | |
+-------+-----------------+----------------+--------------+
|0x10 | NO_VIABLE_PATH |실행 가능하지 않음 |섹션 20 |
| | |네트워크 경로 | |
| | |존재한다 | |
+-------+-----------------+----------------+--------------+
|0x0100-| CRYPTO_ERROR |TLS 경고 코드 |섹션 20 |
|0x01ff | | | |
+-------+-----------------+----------------+--------------+

        표 7: 초기 QUIC 전송 오류 코드 레지스트리 항목

23. 참고문헌

23.1. 규범적 참조

[BCP38] Ferguson, P. 및 D. Senie, "네트워크 유입 필터링:
IP 소스를 사용하는 서비스 거부 공격 차단
주소 스푸핑, BCP 38, RFC 2827, 2000년 5월.

              <https://www.rfc-editor.org/info/bcp38>

[DPLPMTUD] Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., 및 T.
Völker, "패킷화 계층 경로 MTU 검색
데이터그램 전송", RFC 8899, DOI 10.17487/RFC8899,
2020년 9월, <https://www.rfc-editor.org/info/rfc8899>.

[조기 배정]
Cotton, M., "초기 IANA 표준 트랙 코드 할당"
포인트", BCP 100, RFC 7120, DOI 10.17487/RFC7120, 1월
2014, <https://www.rfc-editor.org/info/rfc7120>.

[IPv4] Postel, J., "인터넷 프로토콜", STD 5, RFC 791,
DOI 10.17487/RFC0791, 1981년 9월,
<https://www.rfc-editor.org/info/rfc791>.

[빠른 불변성]
Thomson, M., "QUIC의 버전 독립적 속성",
RFC 8999, DOI 10.17487/RFC8999, 2021년 5월,
<https://www.rfc-editor.org/info/rfc8999>.

[빠른 복구]
아옌가, J., 에드. 및 I. Swett, Ed., "QUIC 손실 감지
및 혼잡 제어", RFC 9002, DOI 10.17487/RFC9002,
2021년 5월, <https://www.rfc-editor.org/info/rfc9002>.

[QUIC-TLS] Thomson, M., Ed. 및 S. Turner, Ed., "TLS를 사용하여 보안
QUIC", RFC 9001, DOI 10.17487/RFC9001, 2021년 5월,
<https://www.rfc-editor.org/info/rfc9001>.

[RFC1191] Mogul, J. 및 S. Deering, "Path MTU 검색", RFC 1191,
DOI 10.17487/RFC1191, 1990년 11월,
<https://www.rfc-editor.org/info/rfc1191>.

[RFC2119] Bradner, S., "RFC에서 사용하는 키워드는 다음을 나타냅니다.
요구 사항 수준", BCP 14, RFC 2119,
DOI 10.17487/RFC2119, 1997년 3월,
<https://www.rfc-editor.org/info/rfc2119>.

[RFC3168] Ramakrishnan, K., Floyd, S., 및 D. Black, "추가
IP에 대한 명시적 혼잡 알림(ECN)의 경우,
RFC 3168, DOI 10.17487/RFC3168, 2001년 9월,
<https://www.rfc-editor.org/info/rfc3168>.

[RFC3629] Yergeau, F., "UTF-8, ISO의 변환 형식
10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, 11월
2003, <https://www.rfc-editor.org/info/rfc3629>.

[RFC6437] Amante, S., Carpenter, B., Jiang, S. 및 J. Rajahalme,
"IPv6 흐름 레이블 사양", RFC 6437,
DOI 10.17487/RFC6437, 2011년 11월,
<https://www.rfc-editor.org/info/rfc6437>.

[RFC8085] Eggert, L., Fairhurst, G., 및 G. Shepherd, "UDP 사용
지침", BCP 145, RFC 8085, DOI 10.17487/RFC8085,
2017년 3월, <https://www.rfc-editor.org/info/rfc8085>.

[RFC8126] Cotton, M., Leiba, B. 및 T. Narten, "지침"
RFC에서 IANA 고려 사항 섹션 작성", BCP 26,
RFC 8126, DOI 10.17487/RFC8126, 2017년 6월,
<https://www.rfc-editor.org/info/rfc8126>.

[RFC8174] Leiba, B., "RFC에서 대문자와 소문자의 모호성"
2119 키워드", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
2017년 5월, <https://www.rfc-editor.org/info/rfc8174>.

[RFC8201] McCann, J., Deering, S., Mogul, J., 및 R. Hinden, Ed.,
"IP 버전 6에 대한 경로 MTU 검색", STD 87, RFC 8201,
DOI 10.17487/RFC8201, 2017년 7월,
<https://www.rfc-editor.org/info/rfc8201>.

[RFC8311] Black, D., "명시적 혼잡에 대한 제한 완화
알림(ECN) 실험", RFC 8311,
DOI 10.17487/RFC8311, 2018년 1월,
<https://www.rfc-editor.org/info/rfc8311>.

[TLS13] Rescorla, E., "전송 계층 보안(TLS) 프로토콜
버전 1.3", RFC 8446, DOI 10.17487/RFC8446, 2018년 8월,
<https://www.rfc-editor.org/info/rfc8446>.

[UDP] Postel, J., "사용자 데이터그램 프로토콜", STD 6, RFC 768,
DOI 10.17487/RFC0768, 1980년 8월,
<https://www.rfc-editor.org/info/rfc768>.

23.2. 정보 참고 자료

[AEAD] McGrew, D., "인증된 인터페이스를 위한 인터페이스 및 알고리즘
암호화", RFC 5116, DOI 10.17487/RFC5116, 2008년 1월,
<https://www.rfc-editor.org/info/rfc5116>.

[ALPN] Friedl, S., Popov, A., Langley, A., 및 E. Stephan,
"전송 계층 보안(TLS) 애플리케이션 계층 프로토콜
협상 확장", RFC 7301, DOI 10.17487/RFC7301,
2014년 7월, <https://www.rfc-editor.org/info/rfc7301>.

[ALTSVC] Nottingham, M., McManus, P., 및 J. Reschke, "HTTP
대체 서비스", RFC 7838, DOI 10.17487/RFC7838,
2016년 4월, <https://www.rfc-editor.org/info/rfc7838>.

[쿠키] Barth, A., "HTTP 상태 관리 메커니즘", RFC 6265,
DOI 10.17487/RFC6265, 2011년 4월,
<https://www.rfc-editor.org/info/rfc6265>.

[CSRF] Barth, A., Jackson, C., 및 J. Mitchell, "강력한 방어
"사이트 간 요청 위조", 제15회 회의록
ACM 컴퓨터 및 통신 보안 컨퍼런스 -
CCS '08, DOI 10.1145/1455770.1455782, 2008,
<https://doi.org/10.1145/1455770.1455782>.

[초기 설계]
Roskind, J., "QUIC: 다중화된 스트림 전송
UDP", 2013년 12월 2일, <https://docs.google.com/document/
d/1RNHkx_VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/
편집?usp=공유>.

[게이트웨이] Hätönen, S., Nyrhinen, A., Eggert, L., Strowes, S.,
Sarolahti, P. 및 M. Kojo, "가정에 대한 실험 연구
게이트웨이 특성", 제10회 ACM 회의록
인터넷 측정에 관한 SIGCOMM 컨퍼런스 - IMC '10,
DOI 10.1145/1879141.1879174, 2010년 11월,
<https://doi.org/10.1145/1879141.1879174>.

[HTTP2] Belshe, M., Peon, R., 및 M. Thomson, 편집자, "하이퍼텍스트
전송 프로토콜 버전 2(HTTP/2)", RFC 7540,
DOI 10.17487/RFC7540, 2015년 5월,
<https://www.rfc-editor.org/info/rfc7540>.

[IPv6] Deering, S. 및 R. Hinden, "인터넷 프로토콜, 버전 6
(IPv6) 사양", STD 86, RFC 8200,
DOI 10.17487/RFC8200, 2017년 7월,
<https://www.rfc-editor.org/info/rfc8200>.

[빠른 관리성]
Kuehlewind, M. 및 B. Trammell, "QUIC의 관리성
전송 프로토콜", 진행 중인 작업, 인터넷 초안,
draft-ietf-quic-manageability-11, 2021년 4월 21일,
<https://tools.ietf.org/html/draft-ietf-quic-
관리 용이성-11>.

[랜덤] Eastlake 3rd, D., Schiller, J., 및 S. Crocker,
"보안을 위한 무작위성 요구 사항", BCP 106, RFC 4086,
DOI 10.17487/RFC4086, 2005년 6월,
<https://www.rfc-editor.org/info/rfc4086>.

[RFC1812] Baker, F., Ed., "IP 버전 4 라우터에 대한 요구 사항",
RFC 1812, DOI 10.17487/RFC1812, 1995년 6월,
<https://www.rfc-editor.org/info/rfc1812>.

[RFC1918] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.
J. 및 E. Lear, "개인용 주소 할당
인터넷", BCP 5, RFC 1918, DOI 10.17487/RFC1918,
1996년 2월, <https://www.rfc-editor.org/info/rfc1918>.

[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., 및 A. Romanow, "TCP
선택적 확인 옵션", RFC 2018,
DOI 10.17487/RFC2018, 1996년 10월,
<https://www.rfc-editor.org/info/rfc2018>.

[RFC2104] Krawczyk, H., Bellare, M., 및 R. Canetti, "HMAC: 키-
메시지 인증을 위한 해싱", RFC 2104,
DOI 10.17487/RFC2104, 1997년 2월,
<https://www.rfc-editor.org/info/rfc2104>.

[RFC3449] Balakrishnan, H., Padmanabhan, V., Fairhurst, G., 및 M.
Sooriyabandara, "네트워크의 TCP 성능 의미"
경로 비대칭", BCP 69, RFC 3449, DOI 10.17487/RFC3449,
2002년 12월, <https://www.rfc-editor.org/info/rfc3449>.

[RFC4193] Hinden, R. 및 B. Haberman, "고유 로컬 IPv6 유니캐스트
주소", RFC 4193, DOI 10.17487/RFC4193, 2005년 10월,
<https://www.rfc-editor.org/info/rfc4193>.

[RFC4291] Hinden, R. 및 S. Deering, "IP 버전 6 주소 지정
아키텍처", RFC 4291, DOI 10.17487/RFC4291, 2월
2006, <https://www.rfc-editor.org/info/rfc4291>.

[RFC4443] Conta, A., Deering, S., 및 M. Gupta, 편집자, "인터넷
인터넷을 위한 제어 메시지 프로토콜(ICMPv6)
프로토콜 버전 6(IPv6) 사양", STD 89,
RFC 4443, DOI 10.17487/RFC4443, 2006년 3월,
<https://www.rfc-editor.org/info/rfc4443>.

[RFC4787] Audet, F., Ed. 및 C. Jennings, "네트워크 주소
유니캐스트에 대한 변환(NAT) 동작 요구 사항
UDP", BCP 127, RFC 4787, DOI 10.17487/RFC4787, 1월
2007, <https://www.rfc-editor.org/info/rfc4787>.

[RFC5681] Allman, M., Paxson, V., 및 E. Blanton, "TCP 혼잡
제어", RFC 5681, DOI 10.17487/RFC5681, 2009년 9월,
<https://www.rfc-editor.org/info/rfc5681>.

[RFC5869] Krawczyk, H. 및 P. Eronen, "HMAC 기반 추출 및 확장
키 유도 함수(HKDF)", RFC 5869,
DOI 10.17487/RFC5869, 2010년 5월,
<https://www.rfc-editor.org/info/rfc5869>.

[RFC7983] Petit-Huguenin, M. 및 G. Salgueiro, "멀티플렉싱 방식
보안 실시간 전송 프로토콜(SRTP) 업데이트
데이터그램 전송 계층 보안(DTLS)에 대한 확장",
RFC 7983, DOI 10.17487/RFC7983, 2016년 9월,
<https://www.rfc-editor.org/info/rfc7983>.

[RFC8087] Fairhurst, G. 및 M. Welzl, "사용의 이점
명시적 혼잡 알림(ECN)", RFC 8087,
DOI 10.17487/RFC8087, 2017년 3월,
<https://www.rfc-editor.org/info/rfc8087>.

[RFC8981] Gont, F., Krishnan, S., Narten, T. 및 R. Draves,
"무국적 주소에 대한 임시 주소 확장
IPv6의 자동 구성", RFC 8981,
DOI 10.17487/RFC8981, 2021년 2월,
<https://www.rfc-editor.org/info/rfc8981>.

[SEC-CONS] Rescorla, E. 및 B. Korver, "RFC 작성 지침
보안 고려 사항에 대한 텍스트", BCP 72, RFC 3552,
DOI 10.17487/RFC3552, 2003년 7월,
<https://www.rfc-editor.org/info/rfc3552>.

[슬로로리스]
"RSnake" Hansen, R., "Slowloris에 오신 것을 환영합니다 - 낮은
대역폭은 충분하지만 탐욕스럽고 독이 있는 HTTP 클라이언트입니다!", 6월
2009, <https://web.archive.org/web/20150315054838/
http://ha.ckers.org/slowloris/>.

부록 A. 의사코드

이 섹션의 의사코드는 샘플 알고리즘을 설명합니다.
알고리즘은 정확하고 명확해야 합니다.
최적의 성능.

이 섹션의 의사코드 세그먼트는 코드로 라이센스됩니다.
구성 요소; 저작권 고지를 참조하세요.

A.1. 가변 길이 정수 디코딩 샘플

그림 45의 의사코드는 가변 길이 정수가 어떻게 가능한지 보여줍니다.
바이트 스트림에서 읽습니다. ReadVarint 함수는 다음을 사용합니다.
단일 인수 -- 네트워크에서 읽을 수 있는 바이트 시퀀스
바이트 순서.

ReadVarint(데이터):
// 가변 길이 정수의 길이는 다음에 인코딩됩니다.
// 첫 번째 바이트의 처음 두 비트.
v = 데이터.다음_바이트()
접두사 = v >> 6
길이 = 1 << 접두사

     // 길이가 알려지면 이 비트를 제거하고 다음을 읽습니다.
     // 남은 바이트.
     v = v & 0x3f
     반복 길이-1번:
       v = (v << 8) + 데이터.다음_바이트()
     v를 반환하다

        그림 45: 가변 길이 정수 디코딩 알고리즘 샘플

예를 들어, 8바이트 시퀀스 0xc2197c5eff14e88c는 다음으로 디코딩됩니다.
10진수 값 151,288,809,941,952,652; 4바이트 시퀀스
0x9d7f3e7d는 494,878,333으로 디코딩됩니다. 2바이트 시퀀스 0x7bbd
15,293으로 디코딩되고 단일 바이트 0x25는 37로 디코딩됩니다(
2바이트 시퀀스 0x4025).

A.2. 샘플 패킷 번호 인코딩 알고리즘

그림 46의 의사코드는 구현이 어떻게 선택할 수 있는지 보여줍니다.
패킷 번호 인코딩에 적합한 크기입니다.

EncodePacketNumber 함수는 두 개의 인수를 사용합니다.

* full_pn은 전송되는 패킷의 전체 패킷 번호입니다.

* largest_acked는 가장 큰 패킷 번호입니다.
  현재 패킷 번호 공간에서 피어가 인식한 경우
  어느.

EncodePacketNumber(full_pn, largest_acked):

     // 비트 수는 최소한 하나 이상이어야 합니다.
     // 연속된 수의 밑이 2인 로그보다
     // 새로운 패킷을 포함한 확인되지 않은 패킷 번호.
     largest_acked가 None인 경우:
       num_unacked = full_pn + 1
     또 다른:
       num_unacked = full_pn - largest_acked

     최소 비트 = log(취소된 수, 2) + 1
     num_bytes = ceil(최소_비트/8)

     // 정수 값을 인코딩하고 잘라냅니다.
     // 최하위 바이트 num_bytes.
     encode(full_pn, num_bytes)를 반환합니다.

             그림 46: 샘플 패킷 번호 인코딩 알고리즘

예를 들어, 엔드포인트가 패킷에 대한 확인을 받은 경우
0xabe8b3이며 0xac5c02 번호의 패킷을 보내고 있습니다.
29,519(0x734f)개의 미처리 패킷 번호.
이 범위의 최소 2배(59,038 패킷 또는 0xe69e)에는 16비트가 있습니다.
필수의.

동일한 상태에서 0xace8fe 번호를 갖는 패킷을 보내는 것은 다음과 같습니다.
24비트 인코딩은 최소 18비트가 필요하기 때문에
범위(131,222 패킷 또는 0x020096)의 두 배를 나타냅니다.

A.3. 샘플 패킷 번호 디코딩 알고리즘

그림 47의 의사코드에는 다음 알고리즘의 예가 포함되어 있습니다.
헤더 보호가 제거된 후 패킷 번호를 디코딩합니다.

DecodePacketNumber 함수는 세 개의 인수를 사용합니다.

* largest_pn은 성공적으로 처리된 가장 큰 패킷 번호입니다.
  현재 패킷 번호 공간에서 처리됩니다.

* truncated_pn은 패킷 번호 필드의 값입니다.

* pn_nbits는 패킷 번호 필드의 비트 수(8, 16,
  24, 또는 32).

DecodePacketNumber(가장 큰 pn, 잘린 pn, pn_n비트):
예상 pn = 가장 큰 pn + 1
pn_win = 1 << pn_n비트
pn_hwin = pn_win / 2
pn_mask = pn_win - 1
// 수신 패킷 번호는 다음보다 커야 합니다.
// expected_pn - pn_hwin 및 이보다 작거나 같음
// 예상_pn + pn_hwin
//
// 이것은 우리가 후행 비트를 그냥 제거할 수 없다는 것을 의미합니다.
// expected_pn과 truncated_pn을 추가합니다.
// 창 밖의 값을 생성합니다.
//
// 다음 코드는 후보 값을 계산합니다.
// 패킷 번호 창 내에 있는지 확인합니다.
// 오버플로와 언더플로를 방지하기 위한 추가 검사에 주목하세요.
후보_pn = (예상_pn & ~pn_마스크) | 잘린_pn
candidate_pn <= expected_pn - pn_hwin이고
후보_pn < (1 << 62) - pn_win:
candidate_pn + pn_win을 반환합니다.
candidate_pn > expected_pn + pn_hwin이고
후보_pn >= pn_win:
candidate_pn - pn_win을 반환합니다.
candidate_pn을 반환합니다

             그림 47: 샘플 패킷 번호 디코딩 알고리즘

예를 들어, 가장 성공적으로 인증된 패킷이 다음과 같은 경우
패킷 번호가 0xa82f30ea이면 16비트 값을 포함하는 패킷입니다.
0x9b32는 0xa82f9b32로 디코딩됩니다.

A.4. ECN 검증 알고리즘 샘플

엔드포인트가 새로운 네트워크 경로로 전송을 시작할 때마다
경로가 ECN을 지원하는지 여부를 결정합니다. 섹션 13.4를 참조하세요.
경로가 ECN을 지원하므로 목표는 ECN을 사용하는 것입니다. 엔드포인트도
ECN을 지원하지 않는 것으로 결정된 경로를 주기적으로 재평가합니다.

이 섹션에서는 새로운 경로를 테스트하는 한 가지 방법을 설명합니다.
알고리즘은 ECN에 대한 경로를 테스트하는 방법을 보여주기 위한 것입니다.
지원. 엔드포인트는 다양한 메서드를 구현할 수 있습니다.

경로에는 "테스트" 중 하나인 ECN 상태가 지정됩니다.
"알 수 없음", "실패" 또는 "가능". "테스트 중" 또는
"가능" 상태에서 엔드포인트는 ECT 표시가 있는 패킷을 보냅니다.
기본적으로 ECT(0)입니다. 그렇지 않으면 엔드포인트는 표시되지 않은 패킷을 보냅니다.

경로 테스트를 시작하려면 ECN 상태를 "테스트"로 설정하고
기존 ECN 수는 기준으로 기억됩니다.

테스트 기간은 여러 패킷 또는 제한된 시간 동안 실행됩니다.
종료 지점에 의해 결정됩니다. 목표는 기간을 제한하는 것이 아닙니다.
테스트 기간이지만 충분한 표시된 패킷이 전송되도록 보장합니다.
수신된 ECN 수를 통해 경로가 어떻게 되는지 명확하게 표시하기 위해
표시된 패킷을 처리합니다. 섹션 13.4.2에서는 이를 10개로 제한할 것을 제안합니다.
패킷 또는 PTO의 3배.

테스트 기간이 종료되면 경로의 ECN 상태가 다음과 같이 됩니다.
"알 수 없음". "알 수 없음" 상태에서 성공적인 검증이 이루어짐
ACK 프레임의 ECN 카운트(섹션 13.4.2.1 참조)로 인해 ECN이 발생합니다.
표시된 패킷이 없는 경우 경로가 "가능" 상태가 되도록 합니다.
인정되었습니다.

ECN 카운트 검증이 언제든지 실패하면 ECN 상태는 다음과 같습니다.
영향을 받는 경로는 "실패" 상태가 됩니다. 엔드포인트는 ECN을 표시할 수도 있습니다.
표시된 패킷이 모두 손실된 것으로 선언된 경우 경로 상태를 "실패"로 지정합니다.
또는 모두 ECN-CE 마크를 받았을 수도 있습니다.

이 알고리즘을 따르면 ECN이 거의 비활성화되지 않습니다.
ECN을 제대로 지원하는 경로. ECN을 잘못 수정하는 경로
표시로 인해 ECN이 비활성화됩니다. 다음과 같은 드문 경우
표시된 패킷은 경로에 의해 삭제되고 지속 시간이 짧습니다.
테스트 기간은 발생하는 손실 수를 제한합니다.

기여자

이 프로토콜의 원래 설계 및 근거는 다음과 같습니다.
Jim Roskind[초기 디자인]의 작업에서 중요한 부분을 차지합니다.

IETF QUIC 워킹 그룹은 엄청난 양의 지원을 받았습니다.
많은 사람들로부터. 다음 사람들은 실질적인 정보를 제공했습니다.
이 문서에 대한 기여:

* 알레산드로 게디니
* 앨리사 윌크
* 앙투안 델리그나-라보
* 브라이언 트래멀
* 크리스찬 휘테마
* 콜린 퍼킨스
* 데이비드 쉬나지
* 드미트리 티코노프
* 에릭 키니어
* 에릭 레스콜라
* 고리 페어허스트
* 이안 스웨트
* 이고르 루바셰프
* 奥 一穂(오쿠 카즈호)
* 라스 에거트
* 루카스 파듀
* 마그누스 베스터룬드
* 마르텐 제만
* 마틴 듀크
* 마이크 비숍
* 미켈 파뇌 요르겐센
* 미르야 퀼레빈트
* 닉 뱅크스
* 닉 하퍼
* 패트릭 맥매너스
* 로베르토 페온
* 라이언 해밀턴
* 수보드 아이옌가르
* 츠지카와 타츠히로
* 테드 하디
* 톰 존스
* 빅터 바실리예프

저자 주소

자나 아이옌가르(편집자)
빠르게

이메일: jri.ietf@gmail.com

마틴 톰슨(편집자)
모질라

이메일: mt@lowentropy.net